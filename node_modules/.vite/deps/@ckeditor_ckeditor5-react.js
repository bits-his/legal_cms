import {
  require_react
} from "./chunk-OU5AQDZK.js";
import {
  __commonJS,
  __esm,
  __export,
  __publicField,
  __toCommonJS
} from "./chunk-EWTE5DHJ.js";

// node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var hasSymbol = typeof Symbol === "function" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
        function isValidElementType(type) {
          return typeof type === "string" || typeof type === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
          type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object.type;
                switch (type) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
            }
          }
          return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
        }
        function isConcurrentMode(object) {
          return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement2(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        exports.AsyncMode = AsyncMode;
        exports.ConcurrentMode = ConcurrentMode;
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement2;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/react-is/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development();
    }
  }
});

// node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "node_modules/object-assign/index.js"(exports, module) {
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i = 0; i < 10; i++) {
          test2["_" + String.fromCharCode(i)] = i;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
          return test2[n];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    module.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from;
      var to = toObject(target);
      var symbols;
      for (var s = 1; s < arguments.length; s++) {
        from = Object(arguments[s]);
        for (var key in from) {
          if (hasOwnProperty.call(from, key)) {
            to[key] = from[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from);
          for (var i = 0; i < symbols.length; i++) {
            if (propIsEnumerable.call(from, symbols[i])) {
              to[symbols[i]] = from[symbols[i]];
            }
          }
        }
      }
      return to;
    };
  }
});

// node_modules/prop-types/lib/ReactPropTypesSecret.js
var require_ReactPropTypesSecret = __commonJS({
  "node_modules/prop-types/lib/ReactPropTypesSecret.js"(exports, module) {
    "use strict";
    var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    module.exports = ReactPropTypesSecret;
  }
});

// node_modules/prop-types/lib/has.js
var require_has = __commonJS({
  "node_modules/prop-types/lib/has.js"(exports, module) {
    module.exports = Function.call.bind(Object.prototype.hasOwnProperty);
  }
});

// node_modules/prop-types/checkPropTypes.js
var require_checkPropTypes = __commonJS({
  "node_modules/prop-types/checkPropTypes.js"(exports, module) {
    "use strict";
    var printWarning = function() {
    };
    if (true) {
      ReactPropTypesSecret = require_ReactPropTypesSecret();
      loggedTypeFailures = {};
      has2 = require_has();
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      };
    }
    var ReactPropTypesSecret;
    var loggedTypeFailures;
    var has2;
    function checkPropTypes(typeSpecs, values2, location, componentName, getStack) {
      if (true) {
        for (var typeSpecName in typeSpecs) {
          if (has2(typeSpecs, typeSpecName)) {
            var error;
            try {
              if (typeof typeSpecs[typeSpecName] !== "function") {
                var err = Error(
                  (componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
                );
                err.name = "Invariant Violation";
                throw err;
              }
              error = typeSpecs[typeSpecName](values2, typeSpecName, componentName, location, null, ReactPropTypesSecret);
            } catch (ex) {
              error = ex;
            }
            if (error && !(error instanceof Error)) {
              printWarning(
                (componentName || "React class") + ": type specification of " + location + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
              );
            }
            if (error instanceof Error && !(error.message in loggedTypeFailures)) {
              loggedTypeFailures[error.message] = true;
              var stack = getStack ? getStack() : "";
              printWarning(
                "Failed " + location + " type: " + error.message + (stack != null ? stack : "")
              );
            }
          }
        }
      }
    }
    checkPropTypes.resetWarningCache = function() {
      if (true) {
        loggedTypeFailures = {};
      }
    };
    module.exports = checkPropTypes;
  }
});

// node_modules/prop-types/factoryWithTypeCheckers.js
var require_factoryWithTypeCheckers = __commonJS({
  "node_modules/prop-types/factoryWithTypeCheckers.js"(exports, module) {
    "use strict";
    var ReactIs = require_react_is();
    var assign2 = require_object_assign();
    var ReactPropTypesSecret = require_ReactPropTypesSecret();
    var has2 = require_has();
    var checkPropTypes = require_checkPropTypes();
    var printWarning = function() {
    };
    if (true) {
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      };
    }
    function emptyFunctionThatReturnsNull() {
      return null;
    }
    module.exports = function(isValidElement, throwOnDirectAccess) {
      var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
        if (typeof iteratorFn === "function") {
          return iteratorFn;
        }
      }
      var ANONYMOUS = "<<anonymous>>";
      var ReactPropTypes = {
        array: createPrimitiveTypeChecker("array"),
        bigint: createPrimitiveTypeChecker("bigint"),
        bool: createPrimitiveTypeChecker("boolean"),
        func: createPrimitiveTypeChecker("function"),
        number: createPrimitiveTypeChecker("number"),
        object: createPrimitiveTypeChecker("object"),
        string: createPrimitiveTypeChecker("string"),
        symbol: createPrimitiveTypeChecker("symbol"),
        any: createAnyTypeChecker(),
        arrayOf: createArrayOfTypeChecker,
        element: createElementTypeChecker(),
        elementType: createElementTypeTypeChecker(),
        instanceOf: createInstanceTypeChecker,
        node: createNodeChecker(),
        objectOf: createObjectOfTypeChecker,
        oneOf: createEnumTypeChecker,
        oneOfType: createUnionTypeChecker,
        shape: createShapeTypeChecker,
        exact: createStrictShapeTypeChecker
      };
      function is(x, y) {
        if (x === y) {
          return x !== 0 || 1 / x === 1 / y;
        } else {
          return x !== x && y !== y;
        }
      }
      function PropTypeError(message, data) {
        this.message = message;
        this.data = data && typeof data === "object" ? data : {};
        this.stack = "";
      }
      PropTypeError.prototype = Error.prototype;
      function createChainableTypeChecker(validate) {
        if (true) {
          var manualPropTypeCallCache = {};
          var manualPropTypeWarningCount = 0;
        }
        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
          componentName = componentName || ANONYMOUS;
          propFullName = propFullName || propName;
          if (secret !== ReactPropTypesSecret) {
            if (throwOnDirectAccess) {
              var err = new Error(
                "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
              );
              err.name = "Invariant Violation";
              throw err;
            } else if (typeof console !== "undefined") {
              var cacheKey = componentName + ":" + propName;
              if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
              manualPropTypeWarningCount < 3) {
                printWarning(
                  "You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
                );
                manualPropTypeCallCache[cacheKey] = true;
                manualPropTypeWarningCount++;
              }
            }
          }
          if (props[propName] == null) {
            if (isRequired) {
              if (props[propName] === null) {
                return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
              }
              return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
            }
            return null;
          } else {
            return validate(props, propName, componentName, location, propFullName);
          }
        }
        var chainedCheckType = checkType.bind(null, false);
        chainedCheckType.isRequired = checkType.bind(null, true);
        return chainedCheckType;
      }
      function createPrimitiveTypeChecker(expectedType) {
        function validate(props, propName, componentName, location, propFullName, secret) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== expectedType) {
            var preciseType = getPreciseType(propValue);
            return new PropTypeError(
              "Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."),
              { expectedType }
            );
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createAnyTypeChecker() {
        return createChainableTypeChecker(emptyFunctionThatReturnsNull);
      }
      function createArrayOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
          }
          var propValue = props[propName];
          if (!Array.isArray(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
          }
          for (var i = 0; i < propValue.length; i++) {
            var error = typeChecker(propValue, i, componentName, location, propFullName + "[" + i + "]", ReactPropTypesSecret);
            if (error instanceof Error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!isValidElement(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!ReactIs.isValidElementType(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createInstanceTypeChecker(expectedClass) {
        function validate(props, propName, componentName, location, propFullName) {
          if (!(props[propName] instanceof expectedClass)) {
            var expectedClassName = expectedClass.name || ANONYMOUS;
            var actualClassName = getClassName(props[propName]);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createEnumTypeChecker(expectedValues) {
        if (!Array.isArray(expectedValues)) {
          if (true) {
            if (arguments.length > 1) {
              printWarning(
                "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
              );
            } else {
              printWarning("Invalid argument supplied to oneOf, expected an array.");
            }
          }
          return emptyFunctionThatReturnsNull;
        }
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          for (var i = 0; i < expectedValues.length; i++) {
            if (is(propValue, expectedValues[i])) {
              return null;
            }
          }
          var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
            var type = getPreciseType(value);
            if (type === "symbol") {
              return String(value);
            }
            return value;
          });
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createObjectOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
          }
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
          }
          for (var key in propValue) {
            if (has2(propValue, key)) {
              var error = typeChecker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
              if (error instanceof Error) {
                return error;
              }
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createUnionTypeChecker(arrayOfTypeCheckers) {
        if (!Array.isArray(arrayOfTypeCheckers)) {
          true ? printWarning("Invalid argument supplied to oneOfType, expected an instance of array.") : void 0;
          return emptyFunctionThatReturnsNull;
        }
        for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
          var checker = arrayOfTypeCheckers[i];
          if (typeof checker !== "function") {
            printWarning(
              "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i + "."
            );
            return emptyFunctionThatReturnsNull;
          }
        }
        function validate(props, propName, componentName, location, propFullName) {
          var expectedTypes = [];
          for (var i2 = 0; i2 < arrayOfTypeCheckers.length; i2++) {
            var checker2 = arrayOfTypeCheckers[i2];
            var checkerResult = checker2(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
            if (checkerResult == null) {
              return null;
            }
            if (checkerResult.data && has2(checkerResult.data, "expectedType")) {
              expectedTypes.push(checkerResult.data.expectedType);
            }
          }
          var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createNodeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          if (!isNode(props[propName])) {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function invalidValidatorError(componentName, location, propFullName, key, type) {
        return new PropTypeError(
          (componentName || "React class") + ": " + location + " type `" + propFullName + "." + key + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + type + "`."
        );
      }
      function createShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          for (var key in shapeTypes) {
            var checker = shapeTypes[key];
            if (typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createStrictShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          var allKeys = assign2({}, props[propName], shapeTypes);
          for (var key in allKeys) {
            var checker = shapeTypes[key];
            if (has2(shapeTypes, key) && typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            if (!checker) {
              return new PropTypeError(
                "Invalid " + location + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  ")
              );
            }
            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function isNode(propValue) {
        switch (typeof propValue) {
          case "number":
          case "string":
          case "undefined":
            return true;
          case "boolean":
            return !propValue;
          case "object":
            if (Array.isArray(propValue)) {
              return propValue.every(isNode);
            }
            if (propValue === null || isValidElement(propValue)) {
              return true;
            }
            var iteratorFn = getIteratorFn(propValue);
            if (iteratorFn) {
              var iterator = iteratorFn.call(propValue);
              var step;
              if (iteratorFn !== propValue.entries) {
                while (!(step = iterator.next()).done) {
                  if (!isNode(step.value)) {
                    return false;
                  }
                }
              } else {
                while (!(step = iterator.next()).done) {
                  var entry = step.value;
                  if (entry) {
                    if (!isNode(entry[1])) {
                      return false;
                    }
                  }
                }
              }
            } else {
              return false;
            }
            return true;
          default:
            return false;
        }
      }
      function isSymbol3(propType, propValue) {
        if (propType === "symbol") {
          return true;
        }
        if (!propValue) {
          return false;
        }
        if (propValue["@@toStringTag"] === "Symbol") {
          return true;
        }
        if (typeof Symbol === "function" && propValue instanceof Symbol) {
          return true;
        }
        return false;
      }
      function getPropType(propValue) {
        var propType = typeof propValue;
        if (Array.isArray(propValue)) {
          return "array";
        }
        if (propValue instanceof RegExp) {
          return "object";
        }
        if (isSymbol3(propType, propValue)) {
          return "symbol";
        }
        return propType;
      }
      function getPreciseType(propValue) {
        if (typeof propValue === "undefined" || propValue === null) {
          return "" + propValue;
        }
        var propType = getPropType(propValue);
        if (propType === "object") {
          if (propValue instanceof Date) {
            return "date";
          } else if (propValue instanceof RegExp) {
            return "regexp";
          }
        }
        return propType;
      }
      function getPostfixForTypeWarning(value) {
        var type = getPreciseType(value);
        switch (type) {
          case "array":
          case "object":
            return "an " + type;
          case "boolean":
          case "date":
          case "regexp":
            return "a " + type;
          default:
            return type;
        }
      }
      function getClassName(propValue) {
        if (!propValue.constructor || !propValue.constructor.name) {
          return ANONYMOUS;
        }
        return propValue.constructor.name;
      }
      ReactPropTypes.checkPropTypes = checkPropTypes;
      ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
      ReactPropTypes.PropTypes = ReactPropTypes;
      return ReactPropTypes;
    };
  }
});

// node_modules/prop-types/index.js
var require_prop_types = __commonJS({
  "node_modules/prop-types/index.js"(exports, module) {
    if (true) {
      ReactIs = require_react_is();
      throwOnDirectAccess = true;
      module.exports = require_factoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
    } else {
      module.exports = null();
    }
    var ReactIs;
    var throwOnDirectAccess;
  }
});

// node_modules/@ckeditor/ckeditor5-watchdog/src/watchdog.js
var Watchdog;
var init_watchdog = __esm({
  "node_modules/@ckeditor/ckeditor5-watchdog/src/watchdog.js"() {
    Watchdog = class {
      /**
       * @param {module:watchdog/watchdog~WatchdogConfig} config The watchdog plugin configuration.
       */
      constructor(config) {
        /**
         * An array of crashes saved as an object with the following properties:
         *
         * * `message`: `String`,
         * * `stack`: `String`,
         * * `date`: `Number`,
         * * `filename`: `String | undefined`,
         * * `lineno`: `Number | undefined`,
         * * `colno`: `Number | undefined`,
         */
        __publicField(this, "crashes", []);
        /**
         * Specifies the state of the item watched by the watchdog. The state can be one of the following values:
         *
         * * `initializing` &ndash; Before the first initialization, and after crashes, before the item is ready.
         * * `ready` &ndash; A state when the user can interact with the item.
         * * `crashed` &ndash; A state when an error occurs. It quickly changes to `initializing` or `crashedPermanently`
         * depending on how many and how frequent errors have been caught recently.
         * * `crashedPermanently` &ndash; A state when the watchdog stops reacting to errors and keeps the item it is watching crashed,
         * * `destroyed` &ndash; A state when the item is manually destroyed by the user after calling `watchdog.destroy()`.
         */
        __publicField(this, "state", "initializing");
        /**
         * @see module:watchdog/watchdog~WatchdogConfig
         */
        __publicField(this, "_crashNumberLimit");
        /**
         * Returns the result of the `Date.now()` call. It can be overridden in tests to mock time as some popular
         * approaches like `sinon.useFakeTimers()` do not work well with error handling.
         */
        __publicField(this, "_now", Date.now);
        /**
         * @see module:watchdog/watchdog~WatchdogConfig
         */
        __publicField(this, "_minimumNonErrorTimePeriod");
        /**
         * Checks if the event error comes from the underlying item and restarts the item.
         */
        __publicField(this, "_boundErrorHandler");
        /**
         * A dictionary of event emitter listeners.
         */
        __publicField(this, "_listeners");
        this.crashes = [];
        this._crashNumberLimit = typeof config.crashNumberLimit === "number" ? config.crashNumberLimit : 3;
        this._minimumNonErrorTimePeriod = typeof config.minimumNonErrorTimePeriod === "number" ? config.minimumNonErrorTimePeriod : 5e3;
        this._boundErrorHandler = (evt) => {
          const error = "error" in evt ? evt.error : evt.reason;
          if (error instanceof Error) {
            this._handleError(error, evt);
          }
        };
        this._listeners = {};
        if (!this._restart) {
          throw new Error("The Watchdog class was split into the abstract `Watchdog` class and the `EditorWatchdog` class. Please, use `EditorWatchdog` if you have used the `Watchdog` class previously.");
        }
      }
      /**
       * Destroys the watchdog and releases the resources.
       */
      destroy() {
        this._stopErrorHandling();
        this._listeners = {};
      }
      /**
       * Starts listening to a specific event name by registering a callback that will be executed
       * whenever an event with a given name fires.
       *
       * Note that this method differs from the CKEditor 5's default `EventEmitterMixin` implementation.
       *
       * @param eventName The event name.
       * @param callback A callback which will be added to event listeners.
       */
      on(eventName, callback) {
        if (!this._listeners[eventName]) {
          this._listeners[eventName] = [];
        }
        this._listeners[eventName].push(callback);
      }
      /**
       * Stops listening to the specified event name by removing the callback from event listeners.
       *
       * Note that this method differs from the CKEditor 5's default `EventEmitterMixin` implementation.
       *
       * @param eventName The event name.
       * @param callback A callback which will be removed from event listeners.
       */
      off(eventName, callback) {
        this._listeners[eventName] = this._listeners[eventName].filter((cb) => cb !== callback);
      }
      /**
       * Fires an event with a given event name and arguments.
       *
       * Note that this method differs from the CKEditor 5's default `EventEmitterMixin` implementation.
       */
      _fire(eventName, ...args) {
        const callbacks = this._listeners[eventName] || [];
        for (const callback of callbacks) {
          callback.apply(this, [null, ...args]);
        }
      }
      /**
       * Starts error handling by attaching global error handlers.
       */
      _startErrorHandling() {
        window.addEventListener("error", this._boundErrorHandler);
        window.addEventListener("unhandledrejection", this._boundErrorHandler);
      }
      /**
       * Stops error handling by detaching global error handlers.
       */
      _stopErrorHandling() {
        window.removeEventListener("error", this._boundErrorHandler);
        window.removeEventListener("unhandledrejection", this._boundErrorHandler);
      }
      /**
       * Checks if an error comes from the watched item and restarts it.
       * It reacts to {@link module:utils/ckeditorerror~CKEditorError `CKEditorError` errors} only.
       *
       * @fires error
       * @param error Error.
       * @param evt An error event.
       */
      _handleError(error, evt) {
        if (this._shouldReactToError(error)) {
          this.crashes.push({
            message: error.message,
            stack: error.stack,
            // `evt.filename`, `evt.lineno` and `evt.colno` are available only in ErrorEvent events
            filename: evt instanceof ErrorEvent ? evt.filename : void 0,
            lineno: evt instanceof ErrorEvent ? evt.lineno : void 0,
            colno: evt instanceof ErrorEvent ? evt.colno : void 0,
            date: this._now()
          });
          const causesRestart = this._shouldRestart();
          this.state = "crashed";
          this._fire("stateChange");
          this._fire("error", { error, causesRestart });
          if (causesRestart) {
            this._restart();
          } else {
            this.state = "crashedPermanently";
            this._fire("stateChange");
          }
        }
      }
      /**
       * Checks whether an error should be handled by the watchdog.
       *
       * @param error An error that was caught by the error handling process.
       */
      _shouldReactToError(error) {
        return error.is && error.is("CKEditorError") && error.context !== void 0 && // In some cases the watched item should not be restarted - e.g. during the item initialization.
        // That's why the `null` was introduced as a correct error context which does cause restarting.
        error.context !== null && // Do not react to errors if the watchdog is in states other than `ready`.
        this.state === "ready" && this._isErrorComingFromThisItem(error);
      }
      /**
       * Checks if the watchdog should restart the underlying item.
       */
      _shouldRestart() {
        if (this.crashes.length <= this._crashNumberLimit) {
          return true;
        }
        const lastErrorTime = this.crashes[this.crashes.length - 1].date;
        const firstMeaningfulErrorTime = this.crashes[this.crashes.length - 1 - this._crashNumberLimit].date;
        const averageNonErrorTimePeriod = (lastErrorTime - firstMeaningfulErrorTime) / this._crashNumberLimit;
        return averageNonErrorTimePeriod > this._minimumNonErrorTimePeriod;
      }
    };
  }
});

// node_modules/es-toolkit/dist/compat/array/castArray.mjs
function castArray(value) {
  if (arguments.length === 0) {
    return [];
  }
  return Array.isArray(value) ? value : [value];
}
var init_castArray = __esm({
  "node_modules/es-toolkit/dist/compat/array/castArray.mjs"() {
  }
});

// node_modules/es-toolkit/dist/array/chunk.mjs
function chunk(arr, size2) {
  if (!Number.isInteger(size2) || size2 <= 0) {
    throw new Error("Size must be an integer greater than zero.");
  }
  const chunkLength = Math.ceil(arr.length / size2);
  const result2 = Array(chunkLength);
  for (let index = 0; index < chunkLength; index++) {
    const start = index * size2;
    const end = start + size2;
    result2[index] = arr.slice(start, end);
  }
  return result2;
}
var init_chunk = __esm({
  "node_modules/es-toolkit/dist/array/chunk.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/_internal/toArray.mjs
function toArray(value) {
  return Array.isArray(value) ? value : Array.from(value);
}
var init_toArray = __esm({
  "node_modules/es-toolkit/dist/compat/_internal/toArray.mjs"() {
  }
});

// node_modules/es-toolkit/dist/predicate/isLength.mjs
function isLength(value) {
  return Number.isSafeInteger(value) && value >= 0;
}
var init_isLength = __esm({
  "node_modules/es-toolkit/dist/predicate/isLength.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/predicate/isArrayLike.mjs
function isArrayLike(value) {
  return value != null && typeof value !== "function" && isLength(value.length);
}
var init_isArrayLike = __esm({
  "node_modules/es-toolkit/dist/compat/predicate/isArrayLike.mjs"() {
    init_isLength();
  }
});

// node_modules/es-toolkit/dist/compat/array/chunk.mjs
function chunk2(arr, size2 = 1) {
  size2 = Math.max(Math.floor(size2), 0);
  if (size2 === 0 || !isArrayLike(arr)) {
    return [];
  }
  return chunk(toArray(arr), size2);
}
var init_chunk2 = __esm({
  "node_modules/es-toolkit/dist/compat/array/chunk.mjs"() {
    init_chunk();
    init_toArray();
    init_isArrayLike();
  }
});

// node_modules/es-toolkit/dist/array/compact.mjs
function compact(arr) {
  const result2 = [];
  for (let i = 0; i < arr.length; i++) {
    const item = arr[i];
    if (item) {
      result2.push(item);
    }
  }
  return result2;
}
var init_compact = __esm({
  "node_modules/es-toolkit/dist/array/compact.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/array/compact.mjs
function compact2(arr) {
  if (!isArrayLike(arr)) {
    return [];
  }
  return compact(Array.from(arr));
}
var init_compact2 = __esm({
  "node_modules/es-toolkit/dist/compat/array/compact.mjs"() {
    init_compact();
    init_isArrayLike();
  }
});

// node_modules/es-toolkit/dist/array/flatten.mjs
function flatten(arr, depth = 1) {
  const result2 = [];
  const flooredDepth = Math.floor(depth);
  const recursive = (arr2, currentDepth) => {
    for (let i = 0; i < arr2.length; i++) {
      const item = arr2[i];
      if (Array.isArray(item) && currentDepth < flooredDepth) {
        recursive(item, currentDepth + 1);
      } else {
        result2.push(item);
      }
    }
  };
  recursive(arr, 0);
  return result2;
}
var init_flatten = __esm({
  "node_modules/es-toolkit/dist/array/flatten.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/array/concat.mjs
function concat(...values2) {
  return flatten(values2);
}
var init_concat = __esm({
  "node_modules/es-toolkit/dist/compat/array/concat.mjs"() {
    init_flatten();
  }
});

// node_modules/es-toolkit/dist/function/identity.mjs
function identity(x) {
  return x;
}
var init_identity = __esm({
  "node_modules/es-toolkit/dist/function/identity.mjs"() {
  }
});

// node_modules/es-toolkit/dist/_internal/isUnsafeProperty.mjs
function isUnsafeProperty(key) {
  return key === "__proto__";
}
var init_isUnsafeProperty = __esm({
  "node_modules/es-toolkit/dist/_internal/isUnsafeProperty.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/_internal/isDeepKey.mjs
function isDeepKey(key) {
  switch (typeof key) {
    case "number":
    case "symbol": {
      return false;
    }
    case "string": {
      return key.includes(".") || key.includes("[") || key.includes("]");
    }
  }
}
var init_isDeepKey = __esm({
  "node_modules/es-toolkit/dist/compat/_internal/isDeepKey.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/_internal/toKey.mjs
function toKey(value) {
  var _a;
  if (typeof value === "string" || typeof value === "symbol") {
    return value;
  }
  if (Object.is((_a = value == null ? void 0 : value.valueOf) == null ? void 0 : _a.call(value), -0)) {
    return "-0";
  }
  return String(value);
}
var init_toKey = __esm({
  "node_modules/es-toolkit/dist/compat/_internal/toKey.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/util/toPath.mjs
function toPath(deepKey) {
  const result2 = [];
  const length = deepKey.length;
  if (length === 0) {
    return result2;
  }
  let index = 0;
  let key = "";
  let quoteChar = "";
  let bracket = false;
  if (deepKey.charCodeAt(0) === 46) {
    result2.push("");
    index++;
  }
  while (index < length) {
    const char = deepKey[index];
    if (quoteChar) {
      if (char === "\\" && index + 1 < length) {
        index++;
        key += deepKey[index];
      } else if (char === quoteChar) {
        quoteChar = "";
      } else {
        key += char;
      }
    } else if (bracket) {
      if (char === '"' || char === "'") {
        quoteChar = char;
      } else if (char === "]") {
        bracket = false;
        result2.push(key);
        key = "";
      } else {
        key += char;
      }
    } else {
      if (char === "[") {
        bracket = true;
        if (key) {
          result2.push(key);
          key = "";
        }
      } else if (char === ".") {
        if (key) {
          result2.push(key);
          key = "";
        }
      } else {
        key += char;
      }
    }
    index++;
  }
  if (key) {
    result2.push(key);
  }
  return result2;
}
var init_toPath = __esm({
  "node_modules/es-toolkit/dist/compat/util/toPath.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/object/get.mjs
function get(object, path, defaultValue) {
  if (object == null) {
    return defaultValue;
  }
  switch (typeof path) {
    case "string": {
      if (isUnsafeProperty(path)) {
        return defaultValue;
      }
      const result2 = object[path];
      if (result2 === void 0) {
        if (isDeepKey(path)) {
          return get(object, toPath(path), defaultValue);
        } else {
          return defaultValue;
        }
      }
      return result2;
    }
    case "number":
    case "symbol": {
      if (typeof path === "number") {
        path = toKey(path);
      }
      const result2 = object[path];
      if (result2 === void 0) {
        return defaultValue;
      }
      return result2;
    }
    default: {
      if (Array.isArray(path)) {
        return getWithPath(object, path, defaultValue);
      }
      if (Object.is(path == null ? void 0 : path.valueOf(), -0)) {
        path = "-0";
      } else {
        path = String(path);
      }
      if (isUnsafeProperty(path)) {
        return defaultValue;
      }
      const result2 = object[path];
      if (result2 === void 0) {
        return defaultValue;
      }
      return result2;
    }
  }
}
function getWithPath(object, path, defaultValue) {
  if (path.length === 0) {
    return defaultValue;
  }
  let current = object;
  for (let index = 0; index < path.length; index++) {
    if (current == null) {
      return defaultValue;
    }
    if (isUnsafeProperty(path[index])) {
      return defaultValue;
    }
    current = current[path[index]];
  }
  if (current === void 0) {
    return defaultValue;
  }
  return current;
}
var init_get = __esm({
  "node_modules/es-toolkit/dist/compat/object/get.mjs"() {
    init_isUnsafeProperty();
    init_isDeepKey();
    init_toKey();
    init_toPath();
  }
});

// node_modules/es-toolkit/dist/compat/object/property.mjs
function property(path) {
  return function(object) {
    return get(object, path);
  };
}
var init_property = __esm({
  "node_modules/es-toolkit/dist/compat/object/property.mjs"() {
    init_get();
  }
});

// node_modules/es-toolkit/dist/compat/predicate/isObject.mjs
function isObject(value) {
  return value !== null && (typeof value === "object" || typeof value === "function");
}
var init_isObject = __esm({
  "node_modules/es-toolkit/dist/compat/predicate/isObject.mjs"() {
  }
});

// node_modules/es-toolkit/dist/predicate/isPrimitive.mjs
function isPrimitive(value) {
  return value == null || typeof value !== "object" && typeof value !== "function";
}
var init_isPrimitive = __esm({
  "node_modules/es-toolkit/dist/predicate/isPrimitive.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/util/eq.mjs
function eq(value, other) {
  return value === other || Number.isNaN(value) && Number.isNaN(other);
}
var init_eq = __esm({
  "node_modules/es-toolkit/dist/compat/util/eq.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/predicate/isMatchWith.mjs
function isMatchWith(target, source, compare) {
  if (typeof compare !== "function") {
    return isMatch(target, source);
  }
  return isMatchWithInternal(target, source, function doesMatch(objValue, srcValue, key, object, source2, stack) {
    const isEqual2 = compare(objValue, srcValue, key, object, source2, stack);
    if (isEqual2 !== void 0) {
      return Boolean(isEqual2);
    }
    return isMatchWithInternal(objValue, srcValue, doesMatch, stack);
  }, /* @__PURE__ */ new Map());
}
function isMatchWithInternal(target, source, compare, stack) {
  if (source === target) {
    return true;
  }
  switch (typeof source) {
    case "object": {
      return isObjectMatch(target, source, compare, stack);
    }
    case "function": {
      const sourceKeys = Object.keys(source);
      if (sourceKeys.length > 0) {
        return isMatchWithInternal(target, { ...source }, compare, stack);
      }
      return eq(target, source);
    }
    default: {
      if (!isObject(target)) {
        return eq(target, source);
      }
      if (typeof source === "string") {
        return source === "";
      }
      return true;
    }
  }
}
function isObjectMatch(target, source, compare, stack) {
  if (source == null) {
    return true;
  }
  if (Array.isArray(source)) {
    return isArrayMatch(target, source, compare, stack);
  }
  if (source instanceof Map) {
    return isMapMatch(target, source, compare, stack);
  }
  if (source instanceof Set) {
    return isSetMatch(target, source, compare, stack);
  }
  const keys2 = Object.keys(source);
  if (target == null) {
    return keys2.length === 0;
  }
  if (keys2.length === 0) {
    return true;
  }
  if (stack && stack.has(source)) {
    return stack.get(source) === target;
  }
  if (stack) {
    stack.set(source, target);
  }
  try {
    for (let i = 0; i < keys2.length; i++) {
      const key = keys2[i];
      if (!isPrimitive(target) && !(key in target)) {
        return false;
      }
      if (source[key] === void 0 && target[key] !== void 0) {
        return false;
      }
      if (source[key] === null && target[key] !== null) {
        return false;
      }
      const isEqual2 = compare(target[key], source[key], key, target, source, stack);
      if (!isEqual2) {
        return false;
      }
    }
    return true;
  } finally {
    if (stack) {
      stack.delete(source);
    }
  }
}
function isMapMatch(target, source, compare, stack) {
  if (source.size === 0) {
    return true;
  }
  if (!(target instanceof Map)) {
    return false;
  }
  for (const [key, sourceValue] of source.entries()) {
    const targetValue = target.get(key);
    const isEqual2 = compare(targetValue, sourceValue, key, target, source, stack);
    if (isEqual2 === false) {
      return false;
    }
  }
  return true;
}
function isArrayMatch(target, source, compare, stack) {
  if (source.length === 0) {
    return true;
  }
  if (!Array.isArray(target)) {
    return false;
  }
  const countedIndex = /* @__PURE__ */ new Set();
  for (let i = 0; i < source.length; i++) {
    const sourceItem = source[i];
    let found = false;
    for (let j = 0; j < target.length; j++) {
      if (countedIndex.has(j)) {
        continue;
      }
      const targetItem = target[j];
      let matches2 = false;
      const isEqual2 = compare(targetItem, sourceItem, i, target, source, stack);
      if (isEqual2) {
        matches2 = true;
      }
      if (matches2) {
        countedIndex.add(j);
        found = true;
        break;
      }
    }
    if (!found) {
      return false;
    }
  }
  return true;
}
function isSetMatch(target, source, compare, stack) {
  if (source.size === 0) {
    return true;
  }
  if (!(target instanceof Set)) {
    return false;
  }
  return isArrayMatch([...target], [...source], compare, stack);
}
var init_isMatchWith = __esm({
  "node_modules/es-toolkit/dist/compat/predicate/isMatchWith.mjs"() {
    init_isMatch();
    init_isObject();
    init_isPrimitive();
    init_eq();
  }
});

// node_modules/es-toolkit/dist/compat/predicate/isMatch.mjs
function isMatch(target, source) {
  return isMatchWith(target, source, () => void 0);
}
var init_isMatch = __esm({
  "node_modules/es-toolkit/dist/compat/predicate/isMatch.mjs"() {
    init_isMatchWith();
  }
});

// node_modules/es-toolkit/dist/compat/_internal/getSymbols.mjs
function getSymbols(object) {
  return Object.getOwnPropertySymbols(object).filter((symbol) => Object.prototype.propertyIsEnumerable.call(object, symbol));
}
var init_getSymbols = __esm({
  "node_modules/es-toolkit/dist/compat/_internal/getSymbols.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/_internal/getTag.mjs
function getTag(value) {
  if (value == null) {
    return value === void 0 ? "[object Undefined]" : "[object Null]";
  }
  return Object.prototype.toString.call(value);
}
var init_getTag = __esm({
  "node_modules/es-toolkit/dist/compat/_internal/getTag.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/_internal/tags.mjs
var regexpTag, stringTag, numberTag, booleanTag, argumentsTag, symbolTag, dateTag, mapTag, setTag, arrayTag, functionTag, arrayBufferTag, objectTag, errorTag, dataViewTag, uint8ArrayTag, uint8ClampedArrayTag, uint16ArrayTag, uint32ArrayTag, bigUint64ArrayTag, int8ArrayTag, int16ArrayTag, int32ArrayTag, bigInt64ArrayTag, float32ArrayTag, float64ArrayTag;
var init_tags = __esm({
  "node_modules/es-toolkit/dist/compat/_internal/tags.mjs"() {
    regexpTag = "[object RegExp]";
    stringTag = "[object String]";
    numberTag = "[object Number]";
    booleanTag = "[object Boolean]";
    argumentsTag = "[object Arguments]";
    symbolTag = "[object Symbol]";
    dateTag = "[object Date]";
    mapTag = "[object Map]";
    setTag = "[object Set]";
    arrayTag = "[object Array]";
    functionTag = "[object Function]";
    arrayBufferTag = "[object ArrayBuffer]";
    objectTag = "[object Object]";
    errorTag = "[object Error]";
    dataViewTag = "[object DataView]";
    uint8ArrayTag = "[object Uint8Array]";
    uint8ClampedArrayTag = "[object Uint8ClampedArray]";
    uint16ArrayTag = "[object Uint16Array]";
    uint32ArrayTag = "[object Uint32Array]";
    bigUint64ArrayTag = "[object BigUint64Array]";
    int8ArrayTag = "[object Int8Array]";
    int16ArrayTag = "[object Int16Array]";
    int32ArrayTag = "[object Int32Array]";
    bigInt64ArrayTag = "[object BigInt64Array]";
    float32ArrayTag = "[object Float32Array]";
    float64ArrayTag = "[object Float64Array]";
  }
});

// node_modules/es-toolkit/dist/predicate/isTypedArray.mjs
function isTypedArray(x) {
  return ArrayBuffer.isView(x) && !(x instanceof DataView);
}
var init_isTypedArray = __esm({
  "node_modules/es-toolkit/dist/predicate/isTypedArray.mjs"() {
  }
});

// node_modules/es-toolkit/dist/object/cloneDeepWith.mjs
function cloneDeepWith(obj, cloneValue) {
  return cloneDeepWithImpl(obj, void 0, obj, /* @__PURE__ */ new Map(), cloneValue);
}
function cloneDeepWithImpl(valueToClone, keyToClone, objectToClone, stack = /* @__PURE__ */ new Map(), cloneValue = void 0) {
  const cloned = cloneValue == null ? void 0 : cloneValue(valueToClone, keyToClone, objectToClone, stack);
  if (cloned != null) {
    return cloned;
  }
  if (isPrimitive(valueToClone)) {
    return valueToClone;
  }
  if (stack.has(valueToClone)) {
    return stack.get(valueToClone);
  }
  if (Array.isArray(valueToClone)) {
    const result2 = new Array(valueToClone.length);
    stack.set(valueToClone, result2);
    for (let i = 0; i < valueToClone.length; i++) {
      result2[i] = cloneDeepWithImpl(valueToClone[i], i, objectToClone, stack, cloneValue);
    }
    if (Object.hasOwn(valueToClone, "index")) {
      result2.index = valueToClone.index;
    }
    if (Object.hasOwn(valueToClone, "input")) {
      result2.input = valueToClone.input;
    }
    return result2;
  }
  if (valueToClone instanceof Date) {
    return new Date(valueToClone.getTime());
  }
  if (valueToClone instanceof RegExp) {
    const result2 = new RegExp(valueToClone.source, valueToClone.flags);
    result2.lastIndex = valueToClone.lastIndex;
    return result2;
  }
  if (valueToClone instanceof Map) {
    const result2 = /* @__PURE__ */ new Map();
    stack.set(valueToClone, result2);
    for (const [key, value] of valueToClone) {
      result2.set(key, cloneDeepWithImpl(value, key, objectToClone, stack, cloneValue));
    }
    return result2;
  }
  if (valueToClone instanceof Set) {
    const result2 = /* @__PURE__ */ new Set();
    stack.set(valueToClone, result2);
    for (const value of valueToClone) {
      result2.add(cloneDeepWithImpl(value, void 0, objectToClone, stack, cloneValue));
    }
    return result2;
  }
  if (typeof Buffer !== "undefined" && Buffer.isBuffer(valueToClone)) {
    return valueToClone.subarray();
  }
  if (isTypedArray(valueToClone)) {
    const result2 = new (Object.getPrototypeOf(valueToClone)).constructor(valueToClone.length);
    stack.set(valueToClone, result2);
    for (let i = 0; i < valueToClone.length; i++) {
      result2[i] = cloneDeepWithImpl(valueToClone[i], i, objectToClone, stack, cloneValue);
    }
    return result2;
  }
  if (valueToClone instanceof ArrayBuffer || typeof SharedArrayBuffer !== "undefined" && valueToClone instanceof SharedArrayBuffer) {
    return valueToClone.slice(0);
  }
  if (valueToClone instanceof DataView) {
    const result2 = new DataView(valueToClone.buffer.slice(0), valueToClone.byteOffset, valueToClone.byteLength);
    stack.set(valueToClone, result2);
    copyProperties(result2, valueToClone, objectToClone, stack, cloneValue);
    return result2;
  }
  if (typeof File !== "undefined" && valueToClone instanceof File) {
    const result2 = new File([valueToClone], valueToClone.name, {
      type: valueToClone.type
    });
    stack.set(valueToClone, result2);
    copyProperties(result2, valueToClone, objectToClone, stack, cloneValue);
    return result2;
  }
  if (valueToClone instanceof Blob) {
    const result2 = new Blob([valueToClone], { type: valueToClone.type });
    stack.set(valueToClone, result2);
    copyProperties(result2, valueToClone, objectToClone, stack, cloneValue);
    return result2;
  }
  if (valueToClone instanceof Error) {
    const result2 = new valueToClone.constructor();
    stack.set(valueToClone, result2);
    result2.message = valueToClone.message;
    result2.name = valueToClone.name;
    result2.stack = valueToClone.stack;
    result2.cause = valueToClone.cause;
    copyProperties(result2, valueToClone, objectToClone, stack, cloneValue);
    return result2;
  }
  if (typeof valueToClone === "object" && isCloneableObject(valueToClone)) {
    const result2 = Object.create(Object.getPrototypeOf(valueToClone));
    stack.set(valueToClone, result2);
    copyProperties(result2, valueToClone, objectToClone, stack, cloneValue);
    return result2;
  }
  return valueToClone;
}
function copyProperties(target, source, objectToClone = target, stack, cloneValue) {
  const keys2 = [...Object.keys(source), ...getSymbols(source)];
  for (let i = 0; i < keys2.length; i++) {
    const key = keys2[i];
    const descriptor = Object.getOwnPropertyDescriptor(target, key);
    if (descriptor == null || descriptor.writable) {
      target[key] = cloneDeepWithImpl(source[key], key, objectToClone, stack, cloneValue);
    }
  }
}
function isCloneableObject(object) {
  switch (getTag(object)) {
    case argumentsTag:
    case arrayTag:
    case arrayBufferTag:
    case dataViewTag:
    case booleanTag:
    case dateTag:
    case float32ArrayTag:
    case float64ArrayTag:
    case int8ArrayTag:
    case int16ArrayTag:
    case int32ArrayTag:
    case mapTag:
    case numberTag:
    case objectTag:
    case regexpTag:
    case setTag:
    case stringTag:
    case symbolTag:
    case uint8ArrayTag:
    case uint8ClampedArrayTag:
    case uint16ArrayTag:
    case uint32ArrayTag: {
      return true;
    }
    default: {
      return false;
    }
  }
}
var init_cloneDeepWith = __esm({
  "node_modules/es-toolkit/dist/object/cloneDeepWith.mjs"() {
    init_getSymbols();
    init_getTag();
    init_tags();
    init_isPrimitive();
    init_isTypedArray();
  }
});

// node_modules/es-toolkit/dist/object/cloneDeep.mjs
function cloneDeep(obj) {
  return cloneDeepWithImpl(obj, void 0, obj, /* @__PURE__ */ new Map(), void 0);
}
var init_cloneDeep = __esm({
  "node_modules/es-toolkit/dist/object/cloneDeep.mjs"() {
    init_cloneDeepWith();
  }
});

// node_modules/es-toolkit/dist/compat/predicate/matches.mjs
function matches(source) {
  source = cloneDeep(source);
  return (target) => {
    return isMatch(target, source);
  };
}
var init_matches = __esm({
  "node_modules/es-toolkit/dist/compat/predicate/matches.mjs"() {
    init_isMatch();
    init_cloneDeep();
  }
});

// node_modules/es-toolkit/dist/compat/object/cloneDeepWith.mjs
function cloneDeepWith2(obj, customizer) {
  return cloneDeepWith(obj, (value, key, object, stack) => {
    const cloned = customizer == null ? void 0 : customizer(value, key, object, stack);
    if (cloned != null) {
      return cloned;
    }
    if (typeof obj !== "object") {
      return void 0;
    }
    switch (Object.prototype.toString.call(obj)) {
      case numberTag:
      case stringTag:
      case booleanTag: {
        const result2 = new obj.constructor(obj == null ? void 0 : obj.valueOf());
        copyProperties(result2, obj);
        return result2;
      }
      case argumentsTag: {
        const result2 = {};
        copyProperties(result2, obj);
        result2.length = obj.length;
        result2[Symbol.iterator] = obj[Symbol.iterator];
        return result2;
      }
      default: {
        return void 0;
      }
    }
  });
}
var init_cloneDeepWith2 = __esm({
  "node_modules/es-toolkit/dist/compat/object/cloneDeepWith.mjs"() {
    init_cloneDeepWith();
    init_tags();
  }
});

// node_modules/es-toolkit/dist/compat/object/cloneDeep.mjs
function cloneDeep2(obj) {
  return cloneDeepWith2(obj);
}
var init_cloneDeep2 = __esm({
  "node_modules/es-toolkit/dist/compat/object/cloneDeep.mjs"() {
    init_cloneDeepWith2();
  }
});

// node_modules/es-toolkit/dist/compat/_internal/isIndex.mjs
function isIndex(value, length = Number.MAX_SAFE_INTEGER) {
  switch (typeof value) {
    case "number": {
      return Number.isInteger(value) && value >= 0 && value < length;
    }
    case "symbol": {
      return false;
    }
    case "string": {
      return IS_UNSIGNED_INTEGER.test(value);
    }
  }
}
var IS_UNSIGNED_INTEGER;
var init_isIndex = __esm({
  "node_modules/es-toolkit/dist/compat/_internal/isIndex.mjs"() {
    IS_UNSIGNED_INTEGER = /^(?:0|[1-9]\d*)$/;
  }
});

// node_modules/es-toolkit/dist/compat/predicate/isArguments.mjs
function isArguments(value) {
  return value !== null && typeof value === "object" && getTag(value) === "[object Arguments]";
}
var init_isArguments = __esm({
  "node_modules/es-toolkit/dist/compat/predicate/isArguments.mjs"() {
    init_getTag();
  }
});

// node_modules/es-toolkit/dist/compat/object/has.mjs
function has(object, path) {
  let resolvedPath;
  if (Array.isArray(path)) {
    resolvedPath = path;
  } else if (typeof path === "string" && isDeepKey(path) && (object == null ? void 0 : object[path]) == null) {
    resolvedPath = toPath(path);
  } else {
    resolvedPath = [path];
  }
  if (resolvedPath.length === 0) {
    return false;
  }
  let current = object;
  for (let i = 0; i < resolvedPath.length; i++) {
    const key = resolvedPath[i];
    if (current == null || !Object.hasOwn(current, key)) {
      const isSparseIndex = (Array.isArray(current) || isArguments(current)) && isIndex(key) && key < current.length;
      if (!isSparseIndex) {
        return false;
      }
    }
    current = current[key];
  }
  return true;
}
var init_has = __esm({
  "node_modules/es-toolkit/dist/compat/object/has.mjs"() {
    init_isDeepKey();
    init_isIndex();
    init_isArguments();
    init_toPath();
  }
});

// node_modules/es-toolkit/dist/compat/predicate/matchesProperty.mjs
function matchesProperty(property2, source) {
  switch (typeof property2) {
    case "object": {
      if (Object.is(property2 == null ? void 0 : property2.valueOf(), -0)) {
        property2 = "-0";
      }
      break;
    }
    case "number": {
      property2 = toKey(property2);
      break;
    }
  }
  source = cloneDeep2(source);
  return function(target) {
    const result2 = get(target, property2);
    if (result2 === void 0) {
      return has(target, property2);
    }
    if (source === void 0) {
      return result2 === void 0;
    }
    return isMatch(result2, source);
  };
}
var init_matchesProperty = __esm({
  "node_modules/es-toolkit/dist/compat/predicate/matchesProperty.mjs"() {
    init_isMatch();
    init_toKey();
    init_cloneDeep2();
    init_get();
    init_has();
  }
});

// node_modules/es-toolkit/dist/compat/util/iteratee.mjs
function iteratee(value) {
  if (value == null) {
    return identity;
  }
  switch (typeof value) {
    case "function": {
      return value;
    }
    case "object": {
      if (Array.isArray(value) && value.length === 2) {
        return matchesProperty(value[0], value[1]);
      }
      return matches(value);
    }
    case "string":
    case "symbol":
    case "number": {
      return property(value);
    }
  }
}
var init_iteratee = __esm({
  "node_modules/es-toolkit/dist/compat/util/iteratee.mjs"() {
    init_identity();
    init_property();
    init_matches();
    init_matchesProperty();
  }
});

// node_modules/es-toolkit/dist/compat/array/countBy.mjs
function countBy(collection, iteratee$1) {
  if (collection == null) {
    return {};
  }
  const array = isArrayLike(collection) ? Array.from(collection) : Object.values(collection);
  const mapper = iteratee(iteratee$1 ?? void 0);
  const result2 = /* @__PURE__ */ Object.create(null);
  for (let i = 0; i < array.length; i++) {
    const item = array[i];
    const key = mapper(item);
    result2[key] = (result2[key] ?? 0) + 1;
  }
  return result2;
}
var init_countBy = __esm({
  "node_modules/es-toolkit/dist/compat/array/countBy.mjs"() {
    init_isArrayLike();
    init_iteratee();
  }
});

// node_modules/es-toolkit/dist/array/difference.mjs
function difference(firstArr, secondArr) {
  const secondSet = new Set(secondArr);
  return firstArr.filter((item) => !secondSet.has(item));
}
var init_difference = __esm({
  "node_modules/es-toolkit/dist/array/difference.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/predicate/isObjectLike.mjs
function isObjectLike(value) {
  return typeof value === "object" && value !== null;
}
var init_isObjectLike = __esm({
  "node_modules/es-toolkit/dist/compat/predicate/isObjectLike.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/predicate/isArrayLikeObject.mjs
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}
var init_isArrayLikeObject = __esm({
  "node_modules/es-toolkit/dist/compat/predicate/isArrayLikeObject.mjs"() {
    init_isArrayLike();
    init_isObjectLike();
  }
});

// node_modules/es-toolkit/dist/compat/array/difference.mjs
function difference2(arr, ...values2) {
  if (!isArrayLikeObject(arr)) {
    return [];
  }
  const arr1 = toArray(arr);
  const arr2 = [];
  for (let i = 0; i < values2.length; i++) {
    const value = values2[i];
    if (isArrayLikeObject(value)) {
      arr2.push(...Array.from(value));
    }
  }
  return difference(arr1, arr2);
}
var init_difference2 = __esm({
  "node_modules/es-toolkit/dist/compat/array/difference.mjs"() {
    init_difference();
    init_toArray();
    init_isArrayLikeObject();
  }
});

// node_modules/es-toolkit/dist/array/last.mjs
function last(arr) {
  return arr[arr.length - 1];
}
var init_last = __esm({
  "node_modules/es-toolkit/dist/array/last.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/array/last.mjs
function last2(array) {
  if (!isArrayLike(array)) {
    return void 0;
  }
  return last(toArray(array));
}
var init_last2 = __esm({
  "node_modules/es-toolkit/dist/compat/array/last.mjs"() {
    init_last();
    init_toArray();
    init_isArrayLike();
  }
});

// node_modules/es-toolkit/dist/array/differenceBy.mjs
function differenceBy(firstArr, secondArr, mapper) {
  const mappedSecondSet = new Set(secondArr.map((item) => mapper(item)));
  return firstArr.filter((item) => {
    return !mappedSecondSet.has(mapper(item));
  });
}
var init_differenceBy = __esm({
  "node_modules/es-toolkit/dist/array/differenceBy.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/_internal/flattenArrayLike.mjs
function flattenArrayLike(values2) {
  const result2 = [];
  for (let i = 0; i < values2.length; i++) {
    const arrayLike = values2[i];
    if (!isArrayLikeObject(arrayLike)) {
      continue;
    }
    for (let j = 0; j < arrayLike.length; j++) {
      result2.push(arrayLike[j]);
    }
  }
  return result2;
}
var init_flattenArrayLike = __esm({
  "node_modules/es-toolkit/dist/compat/_internal/flattenArrayLike.mjs"() {
    init_isArrayLikeObject();
  }
});

// node_modules/es-toolkit/dist/compat/array/differenceBy.mjs
function differenceBy2(arr, ..._values) {
  if (!isArrayLikeObject(arr)) {
    return [];
  }
  const iteratee$1 = last2(_values);
  const values2 = flattenArrayLike(_values);
  if (isArrayLikeObject(iteratee$1)) {
    return difference(Array.from(arr), values2);
  }
  return differenceBy(Array.from(arr), values2, iteratee(iteratee$1));
}
var init_differenceBy2 = __esm({
  "node_modules/es-toolkit/dist/compat/array/differenceBy.mjs"() {
    init_last2();
    init_difference();
    init_differenceBy();
    init_flattenArrayLike();
    init_isArrayLikeObject();
    init_iteratee();
  }
});

// node_modules/es-toolkit/dist/array/differenceWith.mjs
function differenceWith(firstArr, secondArr, areItemsEqual) {
  return firstArr.filter((firstItem) => {
    return secondArr.every((secondItem) => {
      return !areItemsEqual(firstItem, secondItem);
    });
  });
}
var init_differenceWith = __esm({
  "node_modules/es-toolkit/dist/array/differenceWith.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/array/differenceWith.mjs
function differenceWith2(array, ...values2) {
  if (!isArrayLikeObject(array)) {
    return [];
  }
  const comparator = last2(values2);
  const flattenedValues = flattenArrayLike(values2);
  if (typeof comparator === "function") {
    return differenceWith(Array.from(array), flattenedValues, comparator);
  }
  return difference(Array.from(array), flattenedValues);
}
var init_differenceWith2 = __esm({
  "node_modules/es-toolkit/dist/compat/array/differenceWith.mjs"() {
    init_last2();
    init_difference();
    init_differenceWith();
    init_flattenArrayLike();
    init_isArrayLikeObject();
  }
});

// node_modules/es-toolkit/dist/array/drop.mjs
function drop(arr, itemsCount) {
  itemsCount = Math.max(itemsCount, 0);
  return arr.slice(itemsCount);
}
var init_drop = __esm({
  "node_modules/es-toolkit/dist/array/drop.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/predicate/isSymbol.mjs
function isSymbol(value) {
  return typeof value === "symbol" || value instanceof Symbol;
}
var init_isSymbol = __esm({
  "node_modules/es-toolkit/dist/compat/predicate/isSymbol.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/util/toNumber.mjs
function toNumber(value) {
  if (isSymbol(value)) {
    return NaN;
  }
  return Number(value);
}
var init_toNumber = __esm({
  "node_modules/es-toolkit/dist/compat/util/toNumber.mjs"() {
    init_isSymbol();
  }
});

// node_modules/es-toolkit/dist/compat/util/toFinite.mjs
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === Infinity || value === -Infinity) {
    const sign = value < 0 ? -1 : 1;
    return sign * Number.MAX_VALUE;
  }
  return value === value ? value : 0;
}
var init_toFinite = __esm({
  "node_modules/es-toolkit/dist/compat/util/toFinite.mjs"() {
    init_toNumber();
  }
});

// node_modules/es-toolkit/dist/compat/util/toInteger.mjs
function toInteger(value) {
  const finite = toFinite(value);
  const remainder = finite % 1;
  return remainder ? finite - remainder : finite;
}
var init_toInteger = __esm({
  "node_modules/es-toolkit/dist/compat/util/toInteger.mjs"() {
    init_toFinite();
  }
});

// node_modules/es-toolkit/dist/compat/array/drop.mjs
function drop2(collection, itemsCount = 1, guard) {
  if (!isArrayLike(collection)) {
    return [];
  }
  itemsCount = guard ? 1 : toInteger(itemsCount);
  return drop(toArray(collection), itemsCount);
}
var init_drop2 = __esm({
  "node_modules/es-toolkit/dist/compat/array/drop.mjs"() {
    init_drop();
    init_toArray();
    init_isArrayLike();
    init_toInteger();
  }
});

// node_modules/es-toolkit/dist/array/dropRight.mjs
function dropRight(arr, itemsCount) {
  itemsCount = Math.min(-itemsCount, 0);
  if (itemsCount === 0) {
    return arr.slice();
  }
  return arr.slice(0, itemsCount);
}
var init_dropRight = __esm({
  "node_modules/es-toolkit/dist/array/dropRight.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/array/dropRight.mjs
function dropRight2(collection, itemsCount = 1, guard) {
  if (!isArrayLike(collection)) {
    return [];
  }
  itemsCount = guard ? 1 : toInteger(itemsCount);
  return dropRight(toArray(collection), itemsCount);
}
var init_dropRight2 = __esm({
  "node_modules/es-toolkit/dist/compat/array/dropRight.mjs"() {
    init_dropRight();
    init_toArray();
    init_isArrayLike();
    init_toInteger();
  }
});

// node_modules/es-toolkit/dist/array/dropRightWhile.mjs
function dropRightWhile(arr, canContinueDropping) {
  for (let i = arr.length - 1; i >= 0; i--) {
    if (!canContinueDropping(arr[i], i, arr)) {
      return arr.slice(0, i + 1);
    }
  }
  return [];
}
var init_dropRightWhile = __esm({
  "node_modules/es-toolkit/dist/array/dropRightWhile.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/array/dropRightWhile.mjs
function dropRightWhile2(arr, predicate = identity) {
  if (!isArrayLike(arr)) {
    return [];
  }
  return dropRightWhileImpl(Array.from(arr), predicate);
}
function dropRightWhileImpl(arr, predicate) {
  switch (typeof predicate) {
    case "function": {
      return dropRightWhile(arr, (item, index, arr2) => Boolean(predicate(item, index, arr2)));
    }
    case "object": {
      if (Array.isArray(predicate) && predicate.length === 2) {
        const key = predicate[0];
        const value = predicate[1];
        return dropRightWhile(arr, matchesProperty(key, value));
      } else {
        return dropRightWhile(arr, matches(predicate));
      }
    }
    case "symbol":
    case "number":
    case "string": {
      return dropRightWhile(arr, property(predicate));
    }
  }
}
var init_dropRightWhile2 = __esm({
  "node_modules/es-toolkit/dist/compat/array/dropRightWhile.mjs"() {
    init_dropRightWhile();
    init_identity();
    init_property();
    init_isArrayLike();
    init_matches();
    init_matchesProperty();
  }
});

// node_modules/es-toolkit/dist/array/dropWhile.mjs
function dropWhile(arr, canContinueDropping) {
  const dropEndIndex = arr.findIndex((item, index, arr2) => !canContinueDropping(item, index, arr2));
  if (dropEndIndex === -1) {
    return [];
  }
  return arr.slice(dropEndIndex);
}
var init_dropWhile = __esm({
  "node_modules/es-toolkit/dist/array/dropWhile.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/array/dropWhile.mjs
function dropWhile2(arr, predicate = identity) {
  if (!isArrayLike(arr)) {
    return [];
  }
  return dropWhileImpl(toArray(arr), predicate);
}
function dropWhileImpl(arr, predicate) {
  switch (typeof predicate) {
    case "function": {
      return dropWhile(arr, (item, index, arr2) => Boolean(predicate(item, index, arr2)));
    }
    case "object": {
      if (Array.isArray(predicate) && predicate.length === 2) {
        const key = predicate[0];
        const value = predicate[1];
        return dropWhile(arr, matchesProperty(key, value));
      } else {
        return dropWhile(arr, matches(predicate));
      }
    }
    case "number":
    case "symbol":
    case "string": {
      return dropWhile(arr, property(predicate));
    }
  }
}
var init_dropWhile2 = __esm({
  "node_modules/es-toolkit/dist/compat/array/dropWhile.mjs"() {
    init_dropWhile();
    init_identity();
    init_toArray();
    init_property();
    init_isArrayLike();
    init_matches();
    init_matchesProperty();
  }
});

// node_modules/es-toolkit/dist/math/range.mjs
function range(start, end, step = 1) {
  if (end == null) {
    end = start;
    start = 0;
  }
  if (!Number.isInteger(step) || step === 0) {
    throw new Error(`The step value must be a non-zero integer.`);
  }
  const length = Math.max(Math.ceil((end - start) / step), 0);
  const result2 = new Array(length);
  for (let i = 0; i < length; i++) {
    result2[i] = start + i * step;
  }
  return result2;
}
var init_range = __esm({
  "node_modules/es-toolkit/dist/math/range.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/array/forEach.mjs
function forEach(collection, callback = identity) {
  if (!collection) {
    return collection;
  }
  const keys2 = isArrayLike(collection) || Array.isArray(collection) ? range(0, collection.length) : Object.keys(collection);
  for (let i = 0; i < keys2.length; i++) {
    const key = keys2[i];
    const value = collection[key];
    const result2 = callback(value, key, collection);
    if (result2 === false) {
      break;
    }
  }
  return collection;
}
var init_forEach = __esm({
  "node_modules/es-toolkit/dist/compat/array/forEach.mjs"() {
    init_identity();
    init_range();
    init_isArrayLike();
  }
});

// node_modules/es-toolkit/dist/compat/array/forEachRight.mjs
function forEachRight(collection, callback = identity) {
  if (!collection) {
    return collection;
  }
  const keys2 = isArrayLike(collection) ? range(0, collection.length) : Object.keys(collection);
  for (let i = keys2.length - 1; i >= 0; i--) {
    const key = keys2[i];
    const value = collection[key];
    const result2 = callback(value, key, collection);
    if (result2 === false) {
      break;
    }
  }
  return collection;
}
var init_forEachRight = __esm({
  "node_modules/es-toolkit/dist/compat/array/forEachRight.mjs"() {
    init_identity();
    init_range();
    init_isArrayLike();
  }
});

// node_modules/es-toolkit/dist/compat/_internal/isIterateeCall.mjs
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  if (typeof index === "number" && isArrayLike(object) && isIndex(index) && index < object.length || typeof index === "string" && index in object) {
    return eq(object[index], value);
  }
  return false;
}
var init_isIterateeCall = __esm({
  "node_modules/es-toolkit/dist/compat/_internal/isIterateeCall.mjs"() {
    init_isIndex();
    init_isArrayLike();
    init_isObject();
    init_eq();
  }
});

// node_modules/es-toolkit/dist/compat/array/every.mjs
function every(source, doesMatch, guard) {
  if (!source) {
    return true;
  }
  if (guard && isIterateeCall(source, doesMatch, guard)) {
    doesMatch = void 0;
  }
  if (!doesMatch) {
    doesMatch = identity;
  }
  let predicate;
  switch (typeof doesMatch) {
    case "function": {
      predicate = doesMatch;
      break;
    }
    case "object": {
      if (Array.isArray(doesMatch) && doesMatch.length === 2) {
        const key = doesMatch[0];
        const value = doesMatch[1];
        predicate = matchesProperty(key, value);
      } else {
        predicate = matches(doesMatch);
      }
      break;
    }
    case "symbol":
    case "number":
    case "string": {
      predicate = property(doesMatch);
    }
  }
  if (!isArrayLike(source)) {
    const keys2 = Object.keys(source);
    for (let i = 0; i < keys2.length; i++) {
      const key = keys2[i];
      const value = source[key];
      if (!predicate(value, key, source)) {
        return false;
      }
    }
    return true;
  }
  for (let i = 0; i < source.length; i++) {
    if (!predicate(source[i], i, source)) {
      return false;
    }
  }
  return true;
}
var init_every = __esm({
  "node_modules/es-toolkit/dist/compat/array/every.mjs"() {
    init_identity();
    init_isIterateeCall();
    init_property();
    init_isArrayLike();
    init_matches();
    init_matchesProperty();
  }
});

// node_modules/es-toolkit/dist/array/fill.mjs
function fill(array, value, start = 0, end = array.length) {
  const length = array.length;
  const finalStart = Math.max(start >= 0 ? start : length + start, 0);
  const finalEnd = Math.min(end >= 0 ? end : length + end, length);
  for (let i = finalStart; i < finalEnd; i++) {
    array[i] = value;
  }
  return array;
}
var init_fill = __esm({
  "node_modules/es-toolkit/dist/array/fill.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/predicate/isString.mjs
function isString(value) {
  return typeof value === "string" || value instanceof String;
}
var init_isString = __esm({
  "node_modules/es-toolkit/dist/compat/predicate/isString.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/array/fill.mjs
function fill2(array, value, start = 0, end = array ? array.length : 0) {
  if (!isArrayLike(array)) {
    return [];
  }
  if (isString(array)) {
    return array;
  }
  start = Math.floor(start);
  end = Math.floor(end);
  if (!start) {
    start = 0;
  }
  if (!end) {
    end = 0;
  }
  return fill(array, value, start, end);
}
var init_fill2 = __esm({
  "node_modules/es-toolkit/dist/compat/array/fill.mjs"() {
    init_fill();
    init_isArrayLike();
    init_isString();
  }
});

// node_modules/es-toolkit/dist/compat/array/filter.mjs
function filter(source, predicate = identity) {
  if (!source) {
    return [];
  }
  predicate = iteratee(predicate);
  if (!Array.isArray(source)) {
    const result3 = [];
    const keys2 = Object.keys(source);
    const length2 = isArrayLike(source) ? source.length : keys2.length;
    for (let i = 0; i < length2; i++) {
      const key = keys2[i];
      const value = source[key];
      if (predicate(value, key, source)) {
        result3.push(value);
      }
    }
    return result3;
  }
  const result2 = [];
  const length = source.length;
  for (let i = 0; i < length; i++) {
    const value = source[i];
    if (predicate(value, i, source)) {
      result2.push(value);
    }
  }
  return result2;
}
var init_filter = __esm({
  "node_modules/es-toolkit/dist/compat/array/filter.mjs"() {
    init_identity();
    init_isArrayLike();
    init_iteratee();
  }
});

// node_modules/es-toolkit/dist/compat/array/find.mjs
function find(source, _doesMatch = identity, fromIndex = 0) {
  if (!source) {
    return void 0;
  }
  if (fromIndex < 0) {
    fromIndex = Math.max(source.length + fromIndex, 0);
  }
  const doesMatch = iteratee(_doesMatch);
  if (typeof doesMatch === "function" && !Array.isArray(source)) {
    const keys2 = Object.keys(source);
    for (let i = fromIndex; i < keys2.length; i++) {
      const key = keys2[i];
      const value = source[key];
      if (doesMatch(value, key, source)) {
        return value;
      }
    }
    return void 0;
  }
  const values2 = Array.isArray(source) ? source.slice(fromIndex) : Object.values(source).slice(fromIndex);
  return values2.find(doesMatch);
}
var init_find = __esm({
  "node_modules/es-toolkit/dist/compat/array/find.mjs"() {
    init_identity();
    init_iteratee();
  }
});

// node_modules/es-toolkit/dist/compat/array/findIndex.mjs
function findIndex(arr, doesMatch, fromIndex = 0) {
  if (!arr) {
    return -1;
  }
  if (fromIndex < 0) {
    fromIndex = Math.max(arr.length + fromIndex, 0);
  }
  const subArray = Array.from(arr).slice(fromIndex);
  let index = -1;
  switch (typeof doesMatch) {
    case "function": {
      index = subArray.findIndex(doesMatch);
      break;
    }
    case "object": {
      if (Array.isArray(doesMatch) && doesMatch.length === 2) {
        const key = doesMatch[0];
        const value = doesMatch[1];
        index = subArray.findIndex(matchesProperty(key, value));
      } else {
        index = subArray.findIndex(matches(doesMatch));
      }
      break;
    }
    case "number":
    case "symbol":
    case "string": {
      index = subArray.findIndex(property(doesMatch));
    }
  }
  return index === -1 ? -1 : index + fromIndex;
}
var init_findIndex = __esm({
  "node_modules/es-toolkit/dist/compat/array/findIndex.mjs"() {
    init_property();
    init_matches();
    init_matchesProperty();
  }
});

// node_modules/es-toolkit/dist/compat/array/findLast.mjs
function findLast(source, _doesMatch = identity, fromIndex) {
  if (!source) {
    return void 0;
  }
  const length = Array.isArray(source) ? source.length : Object.keys(source).length;
  fromIndex = toInteger(fromIndex ?? length - 1);
  if (fromIndex < 0) {
    fromIndex = Math.max(length + fromIndex, 0);
  } else {
    fromIndex = Math.min(fromIndex, length - 1);
  }
  const doesMatch = iteratee(_doesMatch);
  if (typeof doesMatch === "function" && !Array.isArray(source)) {
    const keys2 = Object.keys(source);
    for (let i = fromIndex; i >= 0; i--) {
      const key = keys2[i];
      const value = source[key];
      if (doesMatch(value, key, source)) {
        return value;
      }
    }
    return void 0;
  }
  const values2 = Array.isArray(source) ? source.slice(0, fromIndex + 1) : Object.values(source).slice(0, fromIndex + 1);
  return values2.findLast(doesMatch);
}
var init_findLast = __esm({
  "node_modules/es-toolkit/dist/compat/array/findLast.mjs"() {
    init_identity();
    init_iteratee();
    init_toInteger();
  }
});

// node_modules/es-toolkit/dist/compat/array/findLastIndex.mjs
function findLastIndex(arr, doesMatch = identity, fromIndex = arr ? arr.length - 1 : 0) {
  if (!arr) {
    return -1;
  }
  if (fromIndex < 0) {
    fromIndex = Math.max(arr.length + fromIndex, 0);
  } else {
    fromIndex = Math.min(fromIndex, arr.length - 1);
  }
  const subArray = toArray(arr).slice(0, fromIndex + 1);
  switch (typeof doesMatch) {
    case "function": {
      return subArray.findLastIndex(doesMatch);
    }
    case "object": {
      if (Array.isArray(doesMatch) && doesMatch.length === 2) {
        const key = doesMatch[0];
        const value = doesMatch[1];
        return subArray.findLastIndex(matchesProperty(key, value));
      } else {
        return subArray.findLastIndex(matches(doesMatch));
      }
    }
    case "number":
    case "symbol":
    case "string": {
      return subArray.findLastIndex(property(doesMatch));
    }
  }
}
var init_findLastIndex = __esm({
  "node_modules/es-toolkit/dist/compat/array/findLastIndex.mjs"() {
    init_identity();
    init_toArray();
    init_property();
    init_matches();
    init_matchesProperty();
  }
});

// node_modules/es-toolkit/dist/array/head.mjs
function head(arr) {
  return arr[0];
}
var init_head = __esm({
  "node_modules/es-toolkit/dist/array/head.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/array/head.mjs
function head2(arr) {
  if (!isArrayLike(arr)) {
    return void 0;
  }
  return head(toArray(arr));
}
var init_head2 = __esm({
  "node_modules/es-toolkit/dist/compat/array/head.mjs"() {
    init_head();
    init_toArray();
    init_isArrayLike();
  }
});

// node_modules/es-toolkit/dist/compat/array/flatten.mjs
function flatten2(value, depth = 1) {
  const result2 = [];
  const flooredDepth = Math.floor(depth);
  if (!isArrayLike(value)) {
    return result2;
  }
  const recursive = (arr, currentDepth) => {
    for (let i = 0; i < arr.length; i++) {
      const item = arr[i];
      if (currentDepth < flooredDepth && (Array.isArray(item) || Boolean(item == null ? void 0 : item[Symbol.isConcatSpreadable]) || item !== null && typeof item === "object" && Object.prototype.toString.call(item) === "[object Arguments]")) {
        if (Array.isArray(item)) {
          recursive(item, currentDepth + 1);
        } else {
          recursive(Array.from(item), currentDepth + 1);
        }
      } else {
        result2.push(item);
      }
    }
  };
  recursive(Array.from(value), 0);
  return result2;
}
var init_flatten2 = __esm({
  "node_modules/es-toolkit/dist/compat/array/flatten.mjs"() {
    init_isArrayLike();
  }
});

// node_modules/es-toolkit/dist/compat/array/flattenDepth.mjs
function flattenDepth(array, depth = 1) {
  return flatten2(array, depth);
}
var init_flattenDepth = __esm({
  "node_modules/es-toolkit/dist/compat/array/flattenDepth.mjs"() {
    init_flatten2();
  }
});

// node_modules/es-toolkit/dist/compat/array/map.mjs
function map(collection, _iteratee) {
  if (!collection) {
    return [];
  }
  const keys2 = isArrayLike(collection) || Array.isArray(collection) ? range(0, collection.length) : Object.keys(collection);
  const iteratee$1 = iteratee(_iteratee ?? identity);
  const result2 = new Array(keys2.length);
  for (let i = 0; i < keys2.length; i++) {
    const key = keys2[i];
    const value = collection[key];
    result2[i] = iteratee$1(value, key, collection);
  }
  return result2;
}
var init_map = __esm({
  "node_modules/es-toolkit/dist/compat/array/map.mjs"() {
    init_identity();
    init_range();
    init_isArrayLike();
    init_iteratee();
  }
});

// node_modules/es-toolkit/dist/predicate/isNil.mjs
function isNil(x) {
  return x == null;
}
var init_isNil = __esm({
  "node_modules/es-toolkit/dist/predicate/isNil.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/array/flatMap.mjs
function flatMap(collection, iteratee2) {
  if (isNil(collection)) {
    return [];
  }
  const mapped = isNil(iteratee2) ? map(collection) : map(collection, iteratee2);
  return flattenDepth(mapped, 1);
}
var init_flatMap = __esm({
  "node_modules/es-toolkit/dist/compat/array/flatMap.mjs"() {
    init_flattenDepth();
    init_map();
    init_isNil();
  }
});

// node_modules/es-toolkit/dist/compat/array/flatMapDepth.mjs
function flatMapDepth(collection, iteratee$1 = identity, depth = 1) {
  if (collection == null) {
    return [];
  }
  const iterateeFn = iteratee(iteratee$1);
  const mapped = map(collection, iterateeFn);
  return flatten2(mapped, depth);
}
var init_flatMapDepth = __esm({
  "node_modules/es-toolkit/dist/compat/array/flatMapDepth.mjs"() {
    init_flatten2();
    init_map();
    init_identity();
    init_iteratee();
  }
});

// node_modules/es-toolkit/dist/compat/array/flatMapDeep.mjs
function flatMapDeep(collection, iteratee2) {
  return flatMapDepth(collection, iteratee2, Infinity);
}
var init_flatMapDeep = __esm({
  "node_modules/es-toolkit/dist/compat/array/flatMapDeep.mjs"() {
    init_flatMapDepth();
  }
});

// node_modules/es-toolkit/dist/compat/array/flattenDeep.mjs
function flattenDeep(value) {
  return flattenDepth(value, Infinity);
}
var init_flattenDeep = __esm({
  "node_modules/es-toolkit/dist/compat/array/flattenDeep.mjs"() {
    init_flattenDepth();
  }
});

// node_modules/es-toolkit/dist/array/groupBy.mjs
function groupBy(arr, getKeyFromItem) {
  const result2 = {};
  for (let i = 0; i < arr.length; i++) {
    const item = arr[i];
    const key = getKeyFromItem(item);
    if (!Object.hasOwn(result2, key)) {
      result2[key] = [];
    }
    result2[key].push(item);
  }
  return result2;
}
var init_groupBy = __esm({
  "node_modules/es-toolkit/dist/array/groupBy.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/array/groupBy.mjs
function groupBy2(source, _getKeyFromItem) {
  if (source == null) {
    return {};
  }
  const items = isArrayLike(source) ? Array.from(source) : Object.values(source);
  const getKeyFromItem = iteratee(_getKeyFromItem ?? identity);
  return groupBy(items, getKeyFromItem);
}
var init_groupBy2 = __esm({
  "node_modules/es-toolkit/dist/compat/array/groupBy.mjs"() {
    init_groupBy();
    init_identity();
    init_isArrayLike();
    init_iteratee();
  }
});

// node_modules/es-toolkit/dist/compat/array/includes.mjs
function includes(source, target, fromIndex, guard) {
  if (source == null) {
    return false;
  }
  if (guard || !fromIndex) {
    fromIndex = 0;
  } else {
    fromIndex = toInteger(fromIndex);
  }
  if (isString(source)) {
    if (fromIndex > source.length || target instanceof RegExp) {
      return false;
    }
    if (fromIndex < 0) {
      fromIndex = Math.max(0, source.length + fromIndex);
    }
    return source.includes(target, fromIndex);
  }
  if (Array.isArray(source)) {
    return source.includes(target, fromIndex);
  }
  const keys2 = Object.keys(source);
  if (fromIndex < 0) {
    fromIndex = Math.max(0, keys2.length + fromIndex);
  }
  for (let i = fromIndex; i < keys2.length; i++) {
    const value = Reflect.get(source, keys2[i]);
    if (eq(value, target)) {
      return true;
    }
  }
  return false;
}
var init_includes = __esm({
  "node_modules/es-toolkit/dist/compat/array/includes.mjs"() {
    init_isString();
    init_eq();
    init_toInteger();
  }
});

// node_modules/es-toolkit/dist/compat/array/indexOf.mjs
function indexOf(array, searchElement, fromIndex) {
  if (!isArrayLike(array)) {
    return -1;
  }
  if (Number.isNaN(searchElement)) {
    fromIndex = fromIndex ?? 0;
    if (fromIndex < 0) {
      fromIndex = Math.max(0, array.length + fromIndex);
    }
    for (let i = fromIndex; i < array.length; i++) {
      if (Number.isNaN(array[i])) {
        return i;
      }
    }
    return -1;
  }
  return Array.from(array).indexOf(searchElement, fromIndex);
}
var init_indexOf = __esm({
  "node_modules/es-toolkit/dist/compat/array/indexOf.mjs"() {
    init_isArrayLike();
  }
});

// node_modules/es-toolkit/dist/array/initial.mjs
function initial(arr) {
  return arr.slice(0, -1);
}
var init_initial = __esm({
  "node_modules/es-toolkit/dist/array/initial.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/array/initial.mjs
function initial2(arr) {
  if (!isArrayLike(arr)) {
    return [];
  }
  return initial(Array.from(arr));
}
var init_initial2 = __esm({
  "node_modules/es-toolkit/dist/compat/array/initial.mjs"() {
    init_initial();
    init_isArrayLike();
  }
});

// node_modules/es-toolkit/dist/array/intersection.mjs
function intersection(firstArr, secondArr) {
  const secondSet = new Set(secondArr);
  return firstArr.filter((item) => {
    return secondSet.has(item);
  });
}
var init_intersection = __esm({
  "node_modules/es-toolkit/dist/array/intersection.mjs"() {
  }
});

// node_modules/es-toolkit/dist/array/uniq.mjs
function uniq(arr) {
  return Array.from(new Set(arr));
}
var init_uniq = __esm({
  "node_modules/es-toolkit/dist/array/uniq.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/array/intersection.mjs
function intersection2(...arrays) {
  if (arrays.length === 0) {
    return [];
  }
  if (!isArrayLikeObject(arrays[0])) {
    return [];
  }
  let result2 = uniq(Array.from(arrays[0]));
  for (let i = 1; i < arrays.length; i++) {
    const array = arrays[i];
    if (!isArrayLikeObject(array)) {
      return [];
    }
    result2 = intersection(result2, Array.from(array));
  }
  return result2;
}
var init_intersection2 = __esm({
  "node_modules/es-toolkit/dist/compat/array/intersection.mjs"() {
    init_intersection();
    init_uniq();
    init_isArrayLikeObject();
  }
});

// node_modules/es-toolkit/dist/array/intersectionBy.mjs
function intersectionBy(firstArr, secondArr, mapper) {
  const mappedSecondSet = new Set(secondArr.map(mapper));
  return firstArr.filter((item) => mappedSecondSet.has(mapper(item)));
}
var init_intersectionBy = __esm({
  "node_modules/es-toolkit/dist/array/intersectionBy.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/array/intersectionBy.mjs
function intersectionBy2(array, ...values2) {
  if (!isArrayLikeObject(array)) {
    return [];
  }
  const lastValue = last(values2);
  if (lastValue === void 0) {
    return Array.from(array);
  }
  let result2 = uniq(Array.from(array));
  const count = isArrayLikeObject(lastValue) ? values2.length : values2.length - 1;
  for (let i = 0; i < count; ++i) {
    const value = values2[i];
    if (!isArrayLikeObject(value)) {
      return [];
    }
    if (isArrayLikeObject(lastValue)) {
      result2 = intersectionBy(result2, Array.from(value), identity);
    } else if (typeof lastValue === "function") {
      result2 = intersectionBy(result2, Array.from(value), (value2) => lastValue(value2));
    } else if (typeof lastValue === "string") {
      result2 = intersectionBy(result2, Array.from(value), property(lastValue));
    }
  }
  return result2;
}
var init_intersectionBy2 = __esm({
  "node_modules/es-toolkit/dist/compat/array/intersectionBy.mjs"() {
    init_intersectionBy();
    init_last();
    init_uniq();
    init_identity();
    init_property();
    init_isArrayLikeObject();
  }
});

// node_modules/es-toolkit/dist/array/intersectionWith.mjs
function intersectionWith(firstArr, secondArr, areItemsEqual) {
  return firstArr.filter((firstItem) => {
    return secondArr.some((secondItem) => {
      return areItemsEqual(firstItem, secondItem);
    });
  });
}
var init_intersectionWith = __esm({
  "node_modules/es-toolkit/dist/array/intersectionWith.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/array/uniq.mjs
function uniq2(arr) {
  if (!isArrayLike(arr)) {
    return [];
  }
  return uniq(Array.from(arr));
}
var init_uniq2 = __esm({
  "node_modules/es-toolkit/dist/compat/array/uniq.mjs"() {
    init_uniq();
    init_isArrayLike();
  }
});

// node_modules/es-toolkit/dist/compat/array/intersectionWith.mjs
function intersectionWith2(firstArr, ...otherArrs) {
  if (firstArr == null) {
    return [];
  }
  const _comparator = last2(otherArrs);
  let comparator = eq;
  let uniq$1 = uniq2;
  if (typeof _comparator === "function") {
    comparator = _comparator;
    uniq$1 = uniqPreserve0;
    otherArrs.pop();
  }
  let result2 = uniq$1(Array.from(firstArr));
  for (let i = 0; i < otherArrs.length; ++i) {
    const otherArr = otherArrs[i];
    if (otherArr == null) {
      return [];
    }
    result2 = intersectionWith(result2, Array.from(otherArr), comparator);
  }
  return result2;
}
function uniqPreserve0(arr) {
  const result2 = [];
  const added = /* @__PURE__ */ new Set();
  for (let i = 0; i < arr.length; i++) {
    const item = arr[i];
    if (added.has(item)) {
      continue;
    }
    result2.push(item);
    added.add(item);
  }
  return result2;
}
var init_intersectionWith2 = __esm({
  "node_modules/es-toolkit/dist/compat/array/intersectionWith.mjs"() {
    init_last2();
    init_intersectionWith();
    init_uniq2();
    init_eq();
  }
});

// node_modules/es-toolkit/dist/predicate/isFunction.mjs
function isFunction(value) {
  return typeof value === "function";
}
var init_isFunction = __esm({
  "node_modules/es-toolkit/dist/predicate/isFunction.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/array/invokeMap.mjs
function invokeMap(collection, path, ...args) {
  if (isNil(collection)) {
    return [];
  }
  const values2 = isArrayLike(collection) ? Array.from(collection) : Object.values(collection);
  const result2 = [];
  for (let i = 0; i < values2.length; i++) {
    const value = values2[i];
    if (isFunction(path)) {
      result2.push(path.apply(value, args));
      continue;
    }
    const method2 = get(value, path);
    let thisContext = value;
    if (Array.isArray(path)) {
      const pathExceptLast = path.slice(0, -1);
      if (pathExceptLast.length > 0) {
        thisContext = get(value, pathExceptLast);
      }
    } else if (typeof path === "string" && path.includes(".")) {
      const parts = path.split(".");
      const pathExceptLast = parts.slice(0, -1).join(".");
      thisContext = get(value, pathExceptLast);
    }
    result2.push(method2 == null ? void 0 : method2.apply(thisContext, args));
  }
  return result2;
}
var init_invokeMap = __esm({
  "node_modules/es-toolkit/dist/compat/array/invokeMap.mjs"() {
    init_isFunction();
    init_isNil();
    init_get();
    init_isArrayLike();
  }
});

// node_modules/es-toolkit/dist/compat/array/join.mjs
function join(array, separator) {
  if (!isArrayLike(array)) {
    return "";
  }
  return Array.from(array).join(separator);
}
var init_join = __esm({
  "node_modules/es-toolkit/dist/compat/array/join.mjs"() {
    init_isArrayLike();
  }
});

// node_modules/es-toolkit/dist/compat/array/reduce.mjs
function reduce(collection, iteratee2 = identity, accumulator) {
  if (!collection) {
    return accumulator;
  }
  let keys2;
  let startIndex = 0;
  if (isArrayLike(collection)) {
    keys2 = range(0, collection.length);
    if (accumulator == null && collection.length > 0) {
      accumulator = collection[0];
      startIndex += 1;
    }
  } else {
    keys2 = Object.keys(collection);
    if (accumulator == null) {
      accumulator = collection[keys2[0]];
      startIndex += 1;
    }
  }
  for (let i = startIndex; i < keys2.length; i++) {
    const key = keys2[i];
    const value = collection[key];
    accumulator = iteratee2(accumulator, value, key, collection);
  }
  return accumulator;
}
var init_reduce = __esm({
  "node_modules/es-toolkit/dist/compat/array/reduce.mjs"() {
    init_identity();
    init_range();
    init_isArrayLike();
  }
});

// node_modules/es-toolkit/dist/compat/array/keyBy.mjs
function keyBy(collection, iteratee$1) {
  if (!isArrayLike(collection) && !isObjectLike(collection)) {
    return {};
  }
  const keyFn = iteratee(iteratee$1 ?? identity);
  return reduce(collection, (result2, value) => {
    const key = keyFn(value);
    result2[key] = value;
    return result2;
  }, {});
}
var init_keyBy = __esm({
  "node_modules/es-toolkit/dist/compat/array/keyBy.mjs"() {
    init_reduce();
    init_identity();
    init_isArrayLike();
    init_isObjectLike();
    init_iteratee();
  }
});

// node_modules/es-toolkit/dist/compat/array/lastIndexOf.mjs
function lastIndexOf(array, searchElement, fromIndex) {
  if (!isArrayLike(array) || array.length === 0) {
    return -1;
  }
  const length = array.length;
  let index = fromIndex ?? length - 1;
  if (fromIndex != null) {
    index = index < 0 ? Math.max(length + index, 0) : Math.min(index, length - 1);
  }
  if (Number.isNaN(searchElement)) {
    for (let i = index; i >= 0; i--) {
      if (Number.isNaN(array[i])) {
        return i;
      }
    }
  }
  return Array.from(array).lastIndexOf(searchElement, index);
}
var init_lastIndexOf = __esm({
  "node_modules/es-toolkit/dist/compat/array/lastIndexOf.mjs"() {
    init_isArrayLike();
  }
});

// node_modules/es-toolkit/dist/compat/array/nth.mjs
function nth(array, n = 0) {
  if (!isArrayLikeObject(array) || array.length === 0) {
    return void 0;
  }
  n = toInteger(n);
  if (n < 0) {
    n += array.length;
  }
  return array[n];
}
var init_nth = __esm({
  "node_modules/es-toolkit/dist/compat/array/nth.mjs"() {
    init_isArrayLikeObject();
    init_toInteger();
  }
});

// node_modules/es-toolkit/dist/compat/_internal/compareValues.mjs
function getPriority(a) {
  if (typeof a === "symbol") {
    return 1;
  }
  if (a === null) {
    return 2;
  }
  if (a === void 0) {
    return 3;
  }
  if (a !== a) {
    return 4;
  }
  return 0;
}
var compareValues;
var init_compareValues = __esm({
  "node_modules/es-toolkit/dist/compat/_internal/compareValues.mjs"() {
    compareValues = (a, b, order) => {
      if (a !== b) {
        const aPriority = getPriority(a);
        const bPriority = getPriority(b);
        if (aPriority === bPriority && aPriority === 0) {
          if (a < b) {
            return order === "desc" ? 1 : -1;
          }
          if (a > b) {
            return order === "desc" ? -1 : 1;
          }
        }
        return order === "desc" ? bPriority - aPriority : aPriority - bPriority;
      }
      return 0;
    };
  }
});

// node_modules/es-toolkit/dist/compat/_internal/isKey.mjs
function isKey(value, object) {
  if (Array.isArray(value)) {
    return false;
  }
  if (typeof value === "number" || typeof value === "boolean" || value == null || isSymbol(value)) {
    return true;
  }
  return typeof value === "string" && (regexIsPlainProp.test(value) || !regexIsDeepProp.test(value)) || object != null && Object.hasOwn(object, value);
}
var regexIsDeepProp, regexIsPlainProp;
var init_isKey = __esm({
  "node_modules/es-toolkit/dist/compat/_internal/isKey.mjs"() {
    init_isSymbol();
    regexIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    regexIsPlainProp = /^\w*$/;
  }
});

// node_modules/es-toolkit/dist/compat/array/orderBy.mjs
function orderBy(collection, criteria, orders, guard) {
  if (collection == null) {
    return [];
  }
  orders = guard ? void 0 : orders;
  if (!Array.isArray(collection)) {
    collection = Object.values(collection);
  }
  if (!Array.isArray(criteria)) {
    criteria = criteria == null ? [null] : [criteria];
  }
  if (criteria.length === 0) {
    criteria = [null];
  }
  if (!Array.isArray(orders)) {
    orders = orders == null ? [] : [orders];
  }
  orders = orders.map((order) => String(order));
  const getValueByNestedPath = (object, path) => {
    let target = object;
    for (let i = 0; i < path.length && target != null; ++i) {
      target = target[path[i]];
    }
    return target;
  };
  const getValueByCriterion = (criterion, object) => {
    if (object == null || criterion == null) {
      return object;
    }
    if (typeof criterion === "object" && "key" in criterion) {
      if (Object.hasOwn(object, criterion.key)) {
        return object[criterion.key];
      }
      return getValueByNestedPath(object, criterion.path);
    }
    if (typeof criterion === "function") {
      return criterion(object);
    }
    if (Array.isArray(criterion)) {
      return getValueByNestedPath(object, criterion);
    }
    if (typeof object === "object") {
      return object[criterion];
    }
    return object;
  };
  const preparedCriteria = criteria.map((criterion) => {
    if (Array.isArray(criterion) && criterion.length === 1) {
      criterion = criterion[0];
    }
    if (criterion == null || typeof criterion === "function" || Array.isArray(criterion) || isKey(criterion)) {
      return criterion;
    }
    return { key: criterion, path: toPath(criterion) };
  });
  const preparedCollection = collection.map((item) => ({
    original: item,
    criteria: preparedCriteria.map((criterion) => getValueByCriterion(criterion, item))
  }));
  return preparedCollection.slice().sort((a, b) => {
    for (let i = 0; i < preparedCriteria.length; i++) {
      const comparedResult = compareValues(a.criteria[i], b.criteria[i], orders[i]);
      if (comparedResult !== 0) {
        return comparedResult;
      }
    }
    return 0;
  }).map((item) => item.original);
}
var init_orderBy = __esm({
  "node_modules/es-toolkit/dist/compat/array/orderBy.mjs"() {
    init_compareValues();
    init_isKey();
    init_toPath();
  }
});

// node_modules/es-toolkit/dist/compat/array/partition.mjs
function partition(source, predicate = identity) {
  if (!source) {
    return [[], []];
  }
  const collection = isArrayLike(source) ? source : Object.values(source);
  predicate = iteratee(predicate);
  const matched = [];
  const unmatched = [];
  for (let i = 0; i < collection.length; i++) {
    const value = collection[i];
    if (predicate(value)) {
      matched.push(value);
    } else {
      unmatched.push(value);
    }
  }
  return [matched, unmatched];
}
var init_partition = __esm({
  "node_modules/es-toolkit/dist/compat/array/partition.mjs"() {
    init_identity();
    init_isArrayLike();
    init_iteratee();
  }
});

// node_modules/es-toolkit/dist/array/pull.mjs
function pull(arr, valuesToRemove) {
  const valuesSet = new Set(valuesToRemove);
  let resultIndex = 0;
  for (let i = 0; i < arr.length; i++) {
    if (valuesSet.has(arr[i])) {
      continue;
    }
    if (!Object.hasOwn(arr, i)) {
      delete arr[resultIndex++];
      continue;
    }
    arr[resultIndex++] = arr[i];
  }
  arr.length = resultIndex;
  return arr;
}
var init_pull = __esm({
  "node_modules/es-toolkit/dist/array/pull.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/array/pull.mjs
function pull2(arr, ...valuesToRemove) {
  return pull(arr, valuesToRemove);
}
var init_pull2 = __esm({
  "node_modules/es-toolkit/dist/compat/array/pull.mjs"() {
    init_pull();
  }
});

// node_modules/es-toolkit/dist/compat/array/pullAll.mjs
function pullAll(arr, valuesToRemove = []) {
  return pull(arr, Array.from(valuesToRemove));
}
var init_pullAll = __esm({
  "node_modules/es-toolkit/dist/compat/array/pullAll.mjs"() {
    init_pull();
  }
});

// node_modules/es-toolkit/dist/compat/array/pullAllBy.mjs
function pullAllBy(arr, valuesToRemove, _getValue) {
  const getValue = iteratee(_getValue);
  const valuesSet = new Set(Array.from(valuesToRemove).map((x) => getValue(x)));
  let resultIndex = 0;
  for (let i = 0; i < arr.length; i++) {
    const value = getValue(arr[i]);
    if (valuesSet.has(value)) {
      continue;
    }
    if (!Object.hasOwn(arr, i)) {
      delete arr[resultIndex++];
      continue;
    }
    arr[resultIndex++] = arr[i];
  }
  arr.length = resultIndex;
  return arr;
}
var init_pullAllBy = __esm({
  "node_modules/es-toolkit/dist/compat/array/pullAllBy.mjs"() {
    init_iteratee();
  }
});

// node_modules/es-toolkit/dist/compat/_internal/copyArray.mjs
function copyArray(source, array) {
  const length = source.length;
  if (array == null) {
    array = Array(length);
  }
  for (let i = 0; i < length; i++) {
    array[i] = source[i];
  }
  return array;
}
var init_copyArray = __esm({
  "node_modules/es-toolkit/dist/compat/_internal/copyArray.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/array/pullAllWith.mjs
function pullAllWith(array, values2, comparator) {
  if ((array == null ? void 0 : array.length) == null || (values2 == null ? void 0 : values2.length) == null) {
    return array;
  }
  if (array === values2) {
    values2 = copyArray(values2);
  }
  let resultLength = 0;
  if (comparator == null) {
    comparator = (a, b) => eq(a, b);
  }
  const valuesArray = Array.isArray(values2) ? values2 : Array.from(values2);
  const hasUndefined = valuesArray.includes(void 0);
  for (let i = 0; i < array.length; i++) {
    if (i in array) {
      const shouldRemove = valuesArray.some((value) => comparator(array[i], value));
      if (!shouldRemove) {
        array[resultLength++] = array[i];
      }
      continue;
    }
    if (!hasUndefined) {
      delete array[resultLength++];
    }
  }
  array.length = resultLength;
  return array;
}
var init_pullAllWith = __esm({
  "node_modules/es-toolkit/dist/compat/array/pullAllWith.mjs"() {
    init_copyArray();
    init_eq();
  }
});

// node_modules/es-toolkit/dist/compat/object/at.mjs
function at(object, ...paths) {
  if (paths.length === 0) {
    return [];
  }
  const allPaths = [];
  for (let i = 0; i < paths.length; i++) {
    const path = paths[i];
    if (!isArrayLike(path) || isString(path)) {
      allPaths.push(path);
      continue;
    }
    for (let j = 0; j < path.length; j++) {
      allPaths.push(path[j]);
    }
  }
  const result2 = [];
  for (let i = 0; i < allPaths.length; i++) {
    result2.push(get(object, allPaths[i]));
  }
  return result2;
}
var init_at = __esm({
  "node_modules/es-toolkit/dist/compat/object/at.mjs"() {
    init_get();
    init_isArrayLike();
    init_isString();
  }
});

// node_modules/es-toolkit/dist/compat/object/unset.mjs
function unset(obj, path) {
  if (obj == null) {
    return true;
  }
  switch (typeof path) {
    case "symbol":
    case "number":
    case "object": {
      if (Array.isArray(path)) {
        return unsetWithPath(obj, path);
      }
      if (typeof path === "number") {
        path = toKey(path);
      } else if (typeof path === "object") {
        if (Object.is(path == null ? void 0 : path.valueOf(), -0)) {
          path = "-0";
        } else {
          path = String(path);
        }
      }
      if (isUnsafeProperty(path)) {
        return false;
      }
      if ((obj == null ? void 0 : obj[path]) === void 0) {
        return true;
      }
      try {
        delete obj[path];
        return true;
      } catch {
        return false;
      }
    }
    case "string": {
      if ((obj == null ? void 0 : obj[path]) === void 0 && isDeepKey(path)) {
        return unsetWithPath(obj, toPath(path));
      }
      if (isUnsafeProperty(path)) {
        return false;
      }
      try {
        delete obj[path];
        return true;
      } catch {
        return false;
      }
    }
  }
}
function unsetWithPath(obj, path) {
  const parent = get(obj, path.slice(0, -1), obj);
  const lastKey = path[path.length - 1];
  if ((parent == null ? void 0 : parent[lastKey]) === void 0) {
    return true;
  }
  if (isUnsafeProperty(lastKey)) {
    return false;
  }
  try {
    delete parent[lastKey];
    return true;
  } catch {
    return false;
  }
}
var init_unset = __esm({
  "node_modules/es-toolkit/dist/compat/object/unset.mjs"() {
    init_get();
    init_isUnsafeProperty();
    init_isDeepKey();
    init_toKey();
    init_toPath();
  }
});

// node_modules/es-toolkit/dist/compat/predicate/isArray.mjs
function isArray(value) {
  return Array.isArray(value);
}
var init_isArray = __esm({
  "node_modules/es-toolkit/dist/compat/predicate/isArray.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/array/pullAt.mjs
function pullAt(array, ..._indices) {
  const indices = flattenDepth(_indices, 1);
  if (!array) {
    return Array(indices.length);
  }
  const result2 = at(array, indices);
  const indicesToPull = indices.map((index) => isIndex(index, array.length) ? Number(index) : index).sort((a, b) => b - a);
  for (const index of new Set(indicesToPull)) {
    if (isIndex(index, array.length)) {
      Array.prototype.splice.call(array, index, 1);
      continue;
    }
    if (isKey(index, array)) {
      delete array[toKey(index)];
      continue;
    }
    const path = isArray(index) ? index : toPath(index);
    unset(array, path);
  }
  return result2;
}
var init_pullAt = __esm({
  "node_modules/es-toolkit/dist/compat/array/pullAt.mjs"() {
    init_flattenDepth();
    init_isIndex();
    init_isKey();
    init_toKey();
    init_at();
    init_unset();
    init_isArray();
    init_toPath();
  }
});

// node_modules/es-toolkit/dist/compat/array/reduceRight.mjs
function reduceRight(collection, iteratee2 = identity, accumulator) {
  if (!collection) {
    return accumulator;
  }
  let keys2;
  let startIndex;
  if (isArrayLike(collection)) {
    keys2 = range(0, collection.length).reverse();
    if (accumulator == null && collection.length > 0) {
      accumulator = collection[collection.length - 1];
      startIndex = 1;
    } else {
      startIndex = 0;
    }
  } else {
    keys2 = Object.keys(collection).reverse();
    if (accumulator == null) {
      accumulator = collection[keys2[0]];
      startIndex = 1;
    } else {
      startIndex = 0;
    }
  }
  for (let i = startIndex; i < keys2.length; i++) {
    const key = keys2[i];
    const value = collection[key];
    accumulator = iteratee2(accumulator, value, key, collection);
  }
  return accumulator;
}
var init_reduceRight = __esm({
  "node_modules/es-toolkit/dist/compat/array/reduceRight.mjs"() {
    init_identity();
    init_range();
    init_isArrayLike();
  }
});

// node_modules/es-toolkit/dist/compat/function/negate.mjs
function negate(func) {
  if (typeof func !== "function") {
    throw new TypeError("Expected a function");
  }
  return function(...args) {
    return !func.apply(this, args);
  };
}
var init_negate = __esm({
  "node_modules/es-toolkit/dist/compat/function/negate.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/array/reject.mjs
function reject(source, predicate = identity) {
  return filter(source, negate(iteratee(predicate)));
}
var init_reject = __esm({
  "node_modules/es-toolkit/dist/compat/array/reject.mjs"() {
    init_filter();
    init_identity();
    init_negate();
    init_iteratee();
  }
});

// node_modules/es-toolkit/dist/array/remove.mjs
function remove(arr, shouldRemoveElement) {
  const originalArr = arr.slice();
  const removed = [];
  let resultIndex = 0;
  for (let i = 0; i < arr.length; i++) {
    if (shouldRemoveElement(arr[i], i, originalArr)) {
      removed.push(arr[i]);
      continue;
    }
    if (!Object.hasOwn(arr, i)) {
      delete arr[resultIndex++];
      continue;
    }
    arr[resultIndex++] = arr[i];
  }
  arr.length = resultIndex;
  return removed;
}
var init_remove = __esm({
  "node_modules/es-toolkit/dist/array/remove.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/array/remove.mjs
function remove2(arr, shouldRemoveElement = identity) {
  return remove(arr, iteratee(shouldRemoveElement));
}
var init_remove2 = __esm({
  "node_modules/es-toolkit/dist/compat/array/remove.mjs"() {
    init_remove();
    init_identity();
    init_iteratee();
  }
});

// node_modules/es-toolkit/dist/compat/array/reverse.mjs
function reverse(array) {
  if (array == null) {
    return array;
  }
  return array.reverse();
}
var init_reverse = __esm({
  "node_modules/es-toolkit/dist/compat/array/reverse.mjs"() {
  }
});

// node_modules/es-toolkit/dist/array/sample.mjs
function sample(arr) {
  const randomIndex = Math.floor(Math.random() * arr.length);
  return arr[randomIndex];
}
var init_sample = __esm({
  "node_modules/es-toolkit/dist/array/sample.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/array/sample.mjs
function sample2(collection) {
  if (collection == null) {
    return void 0;
  }
  if (isArrayLike(collection)) {
    return sample(toArray(collection));
  }
  return sample(Object.values(collection));
}
var init_sample2 = __esm({
  "node_modules/es-toolkit/dist/compat/array/sample.mjs"() {
    init_sample();
    init_toArray();
    init_isArrayLike();
  }
});

// node_modules/es-toolkit/dist/math/random.mjs
function random(minimum, maximum) {
  if (maximum == null) {
    maximum = minimum;
    minimum = 0;
  }
  if (minimum >= maximum) {
    throw new Error("Invalid input: The maximum value must be greater than the minimum value.");
  }
  return Math.random() * (maximum - minimum) + minimum;
}
var init_random = __esm({
  "node_modules/es-toolkit/dist/math/random.mjs"() {
  }
});

// node_modules/es-toolkit/dist/math/randomInt.mjs
function randomInt(minimum, maximum) {
  return Math.floor(random(minimum, maximum));
}
var init_randomInt = __esm({
  "node_modules/es-toolkit/dist/math/randomInt.mjs"() {
    init_random();
  }
});

// node_modules/es-toolkit/dist/array/sampleSize.mjs
function sampleSize(array, size2) {
  if (size2 > array.length) {
    throw new Error("Size must be less than or equal to the length of array.");
  }
  const result2 = new Array(size2);
  const selected = /* @__PURE__ */ new Set();
  for (let step = array.length - size2, resultIndex = 0; step < array.length; step++, resultIndex++) {
    let index = randomInt(0, step + 1);
    if (selected.has(index)) {
      index = step;
    }
    selected.add(index);
    result2[resultIndex] = array[index];
  }
  return result2;
}
var init_sampleSize = __esm({
  "node_modules/es-toolkit/dist/array/sampleSize.mjs"() {
    init_randomInt();
  }
});

// node_modules/es-toolkit/dist/math/clamp.mjs
function clamp(value, bound1, bound2) {
  if (bound2 == null) {
    return Math.min(value, bound1);
  }
  return Math.min(Math.max(value, bound1), bound2);
}
var init_clamp = __esm({
  "node_modules/es-toolkit/dist/math/clamp.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/math/clamp.mjs
function clamp2(value, bound1, bound2) {
  if (Number.isNaN(bound1)) {
    bound1 = 0;
  }
  if (Number.isNaN(bound2)) {
    bound2 = 0;
  }
  return clamp(value, bound1, bound2);
}
var init_clamp2 = __esm({
  "node_modules/es-toolkit/dist/compat/math/clamp.mjs"() {
    init_clamp();
  }
});

// node_modules/es-toolkit/dist/predicate/isMap.mjs
function isMap(value) {
  return value instanceof Map;
}
var init_isMap = __esm({
  "node_modules/es-toolkit/dist/predicate/isMap.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/predicate/isMap.mjs
function isMap2(value) {
  return isMap(value);
}
var init_isMap2 = __esm({
  "node_modules/es-toolkit/dist/compat/predicate/isMap.mjs"() {
    init_isMap();
  }
});

// node_modules/es-toolkit/dist/compat/util/toArray.mjs
function toArray2(value) {
  if (value == null) {
    return [];
  }
  if (isArrayLike(value) || isMap2(value)) {
    return Array.from(value);
  }
  if (typeof value === "object") {
    return Object.values(value);
  }
  return [];
}
var init_toArray2 = __esm({
  "node_modules/es-toolkit/dist/compat/util/toArray.mjs"() {
    init_isArrayLike();
    init_isMap2();
  }
});

// node_modules/es-toolkit/dist/compat/array/sampleSize.mjs
function sampleSize2(collection, size2, guard) {
  const arrayCollection = toArray2(collection);
  if (guard ? isIterateeCall(collection, size2, guard) : size2 === void 0) {
    size2 = 1;
  } else {
    size2 = clamp2(toInteger(size2), 0, arrayCollection.length);
  }
  return sampleSize(arrayCollection, size2);
}
var init_sampleSize2 = __esm({
  "node_modules/es-toolkit/dist/compat/array/sampleSize.mjs"() {
    init_sampleSize();
    init_isIterateeCall();
    init_clamp2();
    init_toArray2();
    init_toInteger();
  }
});

// node_modules/es-toolkit/dist/array/shuffle.mjs
function shuffle(arr) {
  const result2 = arr.slice();
  for (let i = result2.length - 1; i >= 1; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [result2[i], result2[j]] = [result2[j], result2[i]];
  }
  return result2;
}
var init_shuffle = __esm({
  "node_modules/es-toolkit/dist/array/shuffle.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/object/values.mjs
function values(object) {
  return Object.values(object);
}
var init_values = __esm({
  "node_modules/es-toolkit/dist/compat/object/values.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/predicate/isNil.mjs
function isNil2(x) {
  return x == null;
}
var init_isNil2 = __esm({
  "node_modules/es-toolkit/dist/compat/predicate/isNil.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/array/shuffle.mjs
function shuffle2(collection) {
  if (isNil2(collection)) {
    return [];
  }
  if (isArray(collection)) {
    return shuffle(collection);
  }
  if (isArrayLike(collection)) {
    return shuffle(Array.from(collection));
  }
  if (isObjectLike(collection)) {
    return shuffle(values(collection));
  }
  return [];
}
var init_shuffle2 = __esm({
  "node_modules/es-toolkit/dist/compat/array/shuffle.mjs"() {
    init_shuffle();
    init_values();
    init_isArray();
    init_isArrayLike();
    init_isNil2();
    init_isObjectLike();
  }
});

// node_modules/es-toolkit/dist/compat/array/size.mjs
function size(target) {
  if (isNil(target)) {
    return 0;
  }
  if (target instanceof Map || target instanceof Set) {
    return target.size;
  }
  return Object.keys(target).length;
}
var init_size = __esm({
  "node_modules/es-toolkit/dist/compat/array/size.mjs"() {
    init_isNil();
  }
});

// node_modules/es-toolkit/dist/compat/array/slice.mjs
function slice(array, start, end) {
  if (!isArrayLike(array)) {
    return [];
  }
  const length = array.length;
  if (end === void 0) {
    end = length;
  } else if (typeof end !== "number" && isIterateeCall(array, start, end)) {
    start = 0;
    end = length;
  }
  start = toInteger(start);
  end = toInteger(end);
  if (start < 0) {
    start = Math.max(length + start, 0);
  } else {
    start = Math.min(start, length);
  }
  if (end < 0) {
    end = Math.max(length + end, 0);
  } else {
    end = Math.min(end, length);
  }
  const resultLength = Math.max(end - start, 0);
  const result2 = new Array(resultLength);
  for (let i = 0; i < resultLength; ++i) {
    result2[i] = array[start + i];
  }
  return result2;
}
var init_slice = __esm({
  "node_modules/es-toolkit/dist/compat/array/slice.mjs"() {
    init_isIterateeCall();
    init_isArrayLike();
    init_toInteger();
  }
});

// node_modules/es-toolkit/dist/compat/array/some.mjs
function some(source, predicate, guard) {
  if (!source) {
    return false;
  }
  if (guard != null) {
    predicate = void 0;
  }
  if (!predicate) {
    predicate = identity;
  }
  const values2 = Array.isArray(source) ? source : Object.values(source);
  switch (typeof predicate) {
    case "function": {
      if (!Array.isArray(source)) {
        const keys2 = Object.keys(source);
        for (let i = 0; i < keys2.length; i++) {
          const key = keys2[i];
          const value = source[key];
          if (predicate(value, key, source)) {
            return true;
          }
        }
        return false;
      }
      for (let i = 0; i < source.length; i++) {
        if (predicate(source[i], i, source)) {
          return true;
        }
      }
      return false;
    }
    case "object": {
      if (Array.isArray(predicate) && predicate.length === 2) {
        const key = predicate[0];
        const value = predicate[1];
        const matchFunc = matchesProperty(key, value);
        if (Array.isArray(source)) {
          for (let i = 0; i < source.length; i++) {
            if (matchFunc(source[i])) {
              return true;
            }
          }
          return false;
        }
        return values2.some(matchFunc);
      } else {
        const matchFunc = matches(predicate);
        if (Array.isArray(source)) {
          for (let i = 0; i < source.length; i++) {
            if (matchFunc(source[i])) {
              return true;
            }
          }
          return false;
        }
        return values2.some(matchFunc);
      }
    }
    case "number":
    case "symbol":
    case "string": {
      const propFunc = property(predicate);
      if (Array.isArray(source)) {
        for (let i = 0; i < source.length; i++) {
          if (propFunc(source[i])) {
            return true;
          }
        }
        return false;
      }
      return values2.some(propFunc);
    }
  }
}
var init_some = __esm({
  "node_modules/es-toolkit/dist/compat/array/some.mjs"() {
    init_identity();
    init_property();
    init_matches();
    init_matchesProperty();
  }
});

// node_modules/es-toolkit/dist/compat/array/sortBy.mjs
function sortBy(collection, ...criteria) {
  const length = criteria.length;
  if (length > 1 && isIterateeCall(collection, criteria[0], criteria[1])) {
    criteria = [];
  } else if (length > 2 && isIterateeCall(criteria[0], criteria[1], criteria[2])) {
    criteria = [criteria[0]];
  }
  return orderBy(collection, flatten(criteria), ["asc"]);
}
var init_sortBy = __esm({
  "node_modules/es-toolkit/dist/compat/array/sortBy.mjs"() {
    init_orderBy();
    init_flatten();
    init_isIterateeCall();
  }
});

// node_modules/es-toolkit/dist/predicate/isNull.mjs
function isNull(x) {
  return x === null;
}
var init_isNull = __esm({
  "node_modules/es-toolkit/dist/predicate/isNull.mjs"() {
  }
});

// node_modules/es-toolkit/dist/predicate/isUndefined.mjs
function isUndefined(x) {
  return x === void 0;
}
var init_isUndefined = __esm({
  "node_modules/es-toolkit/dist/predicate/isUndefined.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/predicate/isNaN.mjs
function isNaN(value) {
  return Number.isNaN(value);
}
var init_isNaN = __esm({
  "node_modules/es-toolkit/dist/compat/predicate/isNaN.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/array/sortedIndexBy.mjs
function sortedIndexBy(array, value, iteratee$1 = iteratee, retHighest) {
  let low = 0;
  let high = array == null ? 0 : array.length;
  if (high === 0 || isNil2(array)) {
    return 0;
  }
  const iterateeFunction = iteratee(iteratee$1);
  const transformedValue = iterateeFunction(value);
  const valIsNaN = isNaN(transformedValue);
  const valIsNull = isNull(transformedValue);
  const valIsSymbol = isSymbol(transformedValue);
  const valIsUndefined = isUndefined(transformedValue);
  while (low < high) {
    let setLow;
    const mid = Math.floor((low + high) / 2);
    const computed = iterateeFunction(array[mid]);
    const othIsDefined = !isUndefined(computed);
    const othIsNull = isNull(computed);
    const othIsReflexive = !isNaN(computed);
    const othIsSymbol = isSymbol(computed);
    if (valIsNaN) {
      setLow = retHighest || othIsReflexive;
    } else if (valIsUndefined) {
      setLow = othIsReflexive && (retHighest || othIsDefined);
    } else if (valIsNull) {
      setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
    } else if (valIsSymbol) {
      setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
    } else if (othIsNull || othIsSymbol) {
      setLow = false;
    } else {
      setLow = retHighest ? computed <= transformedValue : computed < transformedValue;
    }
    if (setLow) {
      low = mid + 1;
    } else {
      high = mid;
    }
  }
  return Math.min(high, MAX_ARRAY_INDEX);
}
var MAX_ARRAY_LENGTH, MAX_ARRAY_INDEX;
var init_sortedIndexBy = __esm({
  "node_modules/es-toolkit/dist/compat/array/sortedIndexBy.mjs"() {
    init_isNull();
    init_isUndefined();
    init_isNaN();
    init_isNil2();
    init_isSymbol();
    init_iteratee();
    MAX_ARRAY_LENGTH = 4294967295;
    MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1;
  }
});

// node_modules/es-toolkit/dist/predicate/isSymbol.mjs
function isSymbol2(value) {
  return typeof value === "symbol";
}
var init_isSymbol2 = __esm({
  "node_modules/es-toolkit/dist/predicate/isSymbol.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/predicate/isNumber.mjs
function isNumber(value) {
  return typeof value === "number" || value instanceof Number;
}
var init_isNumber = __esm({
  "node_modules/es-toolkit/dist/compat/predicate/isNumber.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/array/sortedIndex.mjs
function sortedIndex(array, value) {
  if (isNil(array)) {
    return 0;
  }
  let low = 0, high = isNil(array) ? low : array.length;
  if (isNumber(value) && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
    while (low < high) {
      const mid = low + high >>> 1;
      const compute = array[mid];
      if (!isNull(compute) && !isSymbol2(compute) && compute < value) {
        low = mid + 1;
      } else {
        high = mid;
      }
    }
    return high;
  }
  return sortedIndexBy(array, value, (value2) => value2);
}
var MAX_ARRAY_LENGTH2, HALF_MAX_ARRAY_LENGTH;
var init_sortedIndex = __esm({
  "node_modules/es-toolkit/dist/compat/array/sortedIndex.mjs"() {
    init_sortedIndexBy();
    init_isNil();
    init_isNull();
    init_isSymbol2();
    init_isNumber();
    MAX_ARRAY_LENGTH2 = 4294967295;
    HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH2 >>> 1;
  }
});

// node_modules/es-toolkit/dist/compat/array/sortedIndexOf.mjs
function sortedIndexOf(array, value) {
  if (!(array == null ? void 0 : array.length)) {
    return -1;
  }
  const index = sortedIndex(array, value);
  if (index < array.length && eq(array[index], value)) {
    return index;
  }
  return -1;
}
var init_sortedIndexOf = __esm({
  "node_modules/es-toolkit/dist/compat/array/sortedIndexOf.mjs"() {
    init_sortedIndex();
    init_eq();
  }
});

// node_modules/es-toolkit/dist/compat/array/sortedLastIndexBy.mjs
function sortedLastIndexBy(array, value, iteratee2) {
  return sortedIndexBy(array, value, iteratee2, true);
}
var init_sortedLastIndexBy = __esm({
  "node_modules/es-toolkit/dist/compat/array/sortedLastIndexBy.mjs"() {
    init_sortedIndexBy();
  }
});

// node_modules/es-toolkit/dist/compat/array/sortedLastIndex.mjs
function sortedLastIndex(array, value) {
  if (isNil(array)) {
    return 0;
  }
  let high = array.length;
  if (!isNumber(value) || Number.isNaN(value) || high > HALF_MAX_ARRAY_LENGTH2) {
    return sortedLastIndexBy(array, value, (value2) => value2);
  }
  let low = 0;
  while (low < high) {
    const mid = low + high >>> 1;
    const compute = array[mid];
    if (!isNull(compute) && !isSymbol2(compute) && compute <= value) {
      low = mid + 1;
    } else {
      high = mid;
    }
  }
  return high;
}
var MAX_ARRAY_LENGTH3, HALF_MAX_ARRAY_LENGTH2;
var init_sortedLastIndex = __esm({
  "node_modules/es-toolkit/dist/compat/array/sortedLastIndex.mjs"() {
    init_sortedLastIndexBy();
    init_isNil();
    init_isNull();
    init_isSymbol2();
    init_isNumber();
    MAX_ARRAY_LENGTH3 = 4294967295;
    HALF_MAX_ARRAY_LENGTH2 = MAX_ARRAY_LENGTH3 >>> 1;
  }
});

// node_modules/es-toolkit/dist/compat/array/sortedLastIndexOf.mjs
function sortedLastIndexOf(array, value) {
  if (!(array == null ? void 0 : array.length)) {
    return -1;
  }
  const index = sortedLastIndex(array, value) - 1;
  if (index >= 0 && eq(array[index], value)) {
    return index;
  }
  return -1;
}
var init_sortedLastIndexOf = __esm({
  "node_modules/es-toolkit/dist/compat/array/sortedLastIndexOf.mjs"() {
    init_sortedLastIndex();
    init_eq();
  }
});

// node_modules/es-toolkit/dist/array/tail.mjs
function tail(arr) {
  return arr.slice(1);
}
var init_tail = __esm({
  "node_modules/es-toolkit/dist/array/tail.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/array/tail.mjs
function tail2(arr) {
  if (!isArrayLike(arr)) {
    return [];
  }
  return tail(toArray(arr));
}
var init_tail2 = __esm({
  "node_modules/es-toolkit/dist/compat/array/tail.mjs"() {
    init_tail();
    init_toArray();
    init_isArrayLike();
  }
});

// node_modules/es-toolkit/dist/array/take.mjs
function take(arr, count, guard) {
  count = guard || count === void 0 ? 1 : toInteger(count);
  return arr.slice(0, count);
}
var init_take = __esm({
  "node_modules/es-toolkit/dist/array/take.mjs"() {
    init_toInteger();
  }
});

// node_modules/es-toolkit/dist/compat/array/take.mjs
function take2(arr, count = 1, guard) {
  count = guard ? 1 : toInteger(count);
  if (count < 1 || !isArrayLike(arr)) {
    return [];
  }
  return take(toArray(arr), count);
}
var init_take2 = __esm({
  "node_modules/es-toolkit/dist/compat/array/take.mjs"() {
    init_take();
    init_toArray();
    init_isArrayLike();
    init_toInteger();
  }
});

// node_modules/es-toolkit/dist/array/takeRight.mjs
function takeRight(arr, count = 1, guard) {
  count = guard || count === void 0 ? 1 : toInteger(count);
  if (count <= 0 || arr == null || arr.length === 0) {
    return [];
  }
  return arr.slice(-count);
}
var init_takeRight = __esm({
  "node_modules/es-toolkit/dist/array/takeRight.mjs"() {
    init_toInteger();
  }
});

// node_modules/es-toolkit/dist/compat/array/takeRight.mjs
function takeRight2(arr, count = 1, guard) {
  count = guard ? 1 : toInteger(count);
  if (count <= 0 || !isArrayLike(arr)) {
    return [];
  }
  return takeRight(toArray(arr), count);
}
var init_takeRight2 = __esm({
  "node_modules/es-toolkit/dist/compat/array/takeRight.mjs"() {
    init_takeRight();
    init_toArray();
    init_isArrayLike();
    init_toInteger();
  }
});

// node_modules/es-toolkit/dist/function/negate.mjs
function negate2(func) {
  return (...args) => !func(...args);
}
var init_negate2 = __esm({
  "node_modules/es-toolkit/dist/function/negate.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/array/takeRightWhile.mjs
function takeRightWhile(_array, predicate) {
  if (!isArrayLikeObject(_array)) {
    return [];
  }
  const array = toArray(_array);
  const index = array.findLastIndex(negate2(iteratee(predicate ?? identity)));
  return array.slice(index + 1);
}
var init_takeRightWhile = __esm({
  "node_modules/es-toolkit/dist/compat/array/takeRightWhile.mjs"() {
    init_identity();
    init_negate2();
    init_toArray();
    init_isArrayLikeObject();
    init_iteratee();
  }
});

// node_modules/es-toolkit/dist/compat/function/identity.mjs
function identity2(x) {
  return x;
}
var init_identity2 = __esm({
  "node_modules/es-toolkit/dist/compat/function/identity.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/array/takeWhile.mjs
function takeWhile(array, predicate) {
  if (!isArrayLikeObject(array)) {
    return [];
  }
  const _array = toArray(array);
  const index = _array.findIndex(negate(iteratee(predicate ?? identity2)));
  return index === -1 ? _array : _array.slice(0, index);
}
var init_takeWhile = __esm({
  "node_modules/es-toolkit/dist/compat/array/takeWhile.mjs"() {
    init_toArray();
    init_identity2();
    init_negate();
    init_isArrayLikeObject();
    init_iteratee();
  }
});

// node_modules/es-toolkit/dist/compat/array/union.mjs
function union(...arrays) {
  const validArrays = arrays.filter(isArrayLikeObject);
  const flattened = flattenDepth(validArrays, 1);
  return uniq(flattened);
}
var init_union = __esm({
  "node_modules/es-toolkit/dist/compat/array/union.mjs"() {
    init_flattenDepth();
    init_uniq();
    init_isArrayLikeObject();
  }
});

// node_modules/es-toolkit/dist/array/uniqBy.mjs
function uniqBy(arr, mapper) {
  const map2 = /* @__PURE__ */ new Map();
  for (let i = 0; i < arr.length; i++) {
    const item = arr[i];
    const key = mapper(item);
    if (!map2.has(key)) {
      map2.set(key, item);
    }
  }
  return Array.from(map2.values());
}
var init_uniqBy = __esm({
  "node_modules/es-toolkit/dist/array/uniqBy.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/array/unionBy.mjs
function unionBy(...values2) {
  const lastValue = last(values2);
  const flattened = flattenArrayLike(values2);
  if (isArrayLikeObject(lastValue) || lastValue == null) {
    return uniq(flattened);
  }
  return uniqBy(flattened, iteratee(lastValue));
}
var init_unionBy = __esm({
  "node_modules/es-toolkit/dist/compat/array/unionBy.mjs"() {
    init_last();
    init_uniq();
    init_uniqBy();
    init_flattenArrayLike();
    init_isArrayLikeObject();
    init_iteratee();
  }
});

// node_modules/es-toolkit/dist/array/uniqWith.mjs
function uniqWith(arr, areItemsEqual) {
  const result2 = [];
  for (let i = 0; i < arr.length; i++) {
    const item = arr[i];
    const isUniq = result2.every((v) => !areItemsEqual(v, item));
    if (isUniq) {
      result2.push(item);
    }
  }
  return result2;
}
var init_uniqWith = __esm({
  "node_modules/es-toolkit/dist/array/uniqWith.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/array/unionWith.mjs
function unionWith(...values2) {
  const lastValue = last(values2);
  const flattened = flattenArrayLike(values2);
  if (isArrayLikeObject(lastValue) || lastValue == null) {
    return uniq(flattened);
  }
  return uniqWith(flattened, lastValue);
}
var init_unionWith = __esm({
  "node_modules/es-toolkit/dist/compat/array/unionWith.mjs"() {
    init_last();
    init_uniq();
    init_uniqWith();
    init_flattenArrayLike();
    init_isArrayLikeObject();
  }
});

// node_modules/es-toolkit/dist/compat/array/uniqBy.mjs
function uniqBy2(array, iteratee$1 = identity) {
  if (!isArrayLikeObject(array)) {
    return [];
  }
  return uniqBy(Array.from(array), iteratee(iteratee$1));
}
var init_uniqBy2 = __esm({
  "node_modules/es-toolkit/dist/compat/array/uniqBy.mjs"() {
    init_uniqBy();
    init_identity();
    init_isArrayLikeObject();
    init_iteratee();
  }
});

// node_modules/es-toolkit/dist/compat/array/uniqWith.mjs
function uniqWith2(arr, comparator) {
  if (!isArrayLike(arr)) {
    return [];
  }
  return typeof comparator === "function" ? uniqWith(Array.from(arr), comparator) : uniq2(Array.from(arr));
}
var init_uniqWith2 = __esm({
  "node_modules/es-toolkit/dist/compat/array/uniqWith.mjs"() {
    init_uniqWith();
    init_uniq2();
    init_isArrayLike();
  }
});

// node_modules/es-toolkit/dist/array/unzip.mjs
function unzip(zipped) {
  let maxLen = 0;
  for (let i = 0; i < zipped.length; i++) {
    if (zipped[i].length > maxLen) {
      maxLen = zipped[i].length;
    }
  }
  const result2 = new Array(maxLen);
  for (let i = 0; i < maxLen; i++) {
    result2[i] = new Array(zipped.length);
    for (let j = 0; j < zipped.length; j++) {
      result2[i][j] = zipped[j][i];
    }
  }
  return result2;
}
var init_unzip = __esm({
  "node_modules/es-toolkit/dist/array/unzip.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/array/unzip.mjs
function unzip2(array) {
  if (!isArrayLikeObject(array) || !array.length) {
    return [];
  }
  array = isArray(array) ? array : Array.from(array);
  array = array.filter((item) => isArrayLikeObject(item));
  return unzip(array);
}
var init_unzip2 = __esm({
  "node_modules/es-toolkit/dist/compat/array/unzip.mjs"() {
    init_unzip();
    init_isArray();
    init_isArrayLikeObject();
  }
});

// node_modules/es-toolkit/dist/compat/array/unzipWith.mjs
function unzipWith(array, iteratee2) {
  if (!isArrayLikeObject(array) || !array.length) {
    return [];
  }
  const unziped = isArray(array) ? unzip(array) : unzip(Array.from(array, (value) => Array.from(value)));
  if (!iteratee2) {
    return unziped;
  }
  const result2 = new Array(unziped.length);
  for (let i = 0; i < unziped.length; i++) {
    const value = unziped[i];
    result2[i] = iteratee2(...value);
  }
  return result2;
}
var init_unzipWith = __esm({
  "node_modules/es-toolkit/dist/compat/array/unzipWith.mjs"() {
    init_unzip();
    init_isArray();
    init_isArrayLikeObject();
  }
});

// node_modules/es-toolkit/dist/array/without.mjs
function without(array, ...values2) {
  return difference(array, values2);
}
var init_without = __esm({
  "node_modules/es-toolkit/dist/array/without.mjs"() {
    init_difference();
  }
});

// node_modules/es-toolkit/dist/compat/array/without.mjs
function without2(array, ...values2) {
  if (!isArrayLikeObject(array)) {
    return [];
  }
  return without(Array.from(array), ...values2);
}
var init_without2 = __esm({
  "node_modules/es-toolkit/dist/compat/array/without.mjs"() {
    init_without();
    init_isArrayLikeObject();
  }
});

// node_modules/es-toolkit/dist/compat/array/xor.mjs
function xor(...arrays) {
  const itemCounts = /* @__PURE__ */ new Map();
  for (let i = 0; i < arrays.length; i++) {
    const array = arrays[i];
    if (!isArrayLikeObject(array)) {
      continue;
    }
    const itemSet = new Set(toArray2(array));
    for (const item of itemSet) {
      if (!itemCounts.has(item)) {
        itemCounts.set(item, 1);
      } else {
        itemCounts.set(item, itemCounts.get(item) + 1);
      }
    }
  }
  const result2 = [];
  for (const [item, count] of itemCounts) {
    if (count === 1) {
      result2.push(item);
    }
  }
  return result2;
}
var init_xor = __esm({
  "node_modules/es-toolkit/dist/compat/array/xor.mjs"() {
    init_isArrayLikeObject();
    init_toArray2();
  }
});

// node_modules/es-toolkit/dist/array/windowed.mjs
function windowed(arr, size2, step = 1, { partialWindows = false } = {}) {
  if (size2 <= 0 || !Number.isInteger(size2)) {
    throw new Error("Size must be a positive integer.");
  }
  if (step <= 0 || !Number.isInteger(step)) {
    throw new Error("Step must be a positive integer.");
  }
  const result2 = [];
  const end = partialWindows ? arr.length : arr.length - size2 + 1;
  for (let i = 0; i < end; i += step) {
    result2.push(arr.slice(i, i + size2));
  }
  return result2;
}
var init_windowed = __esm({
  "node_modules/es-toolkit/dist/array/windowed.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/array/xorBy.mjs
function xorBy(...values2) {
  const lastValue = last2(values2);
  let mapper = identity;
  if (!isArrayLikeObject(lastValue) && lastValue != null) {
    mapper = iteratee(lastValue);
    values2 = values2.slice(0, -1);
  }
  const arrays = values2.filter(isArrayLikeObject);
  const union2 = unionBy(...arrays, mapper);
  const intersections = windowed(arrays, 2).map(([arr1, arr2]) => intersectionBy2(arr1, arr2, mapper));
  return differenceBy2(union2, unionBy(...intersections, mapper), mapper);
}
var init_xorBy = __esm({
  "node_modules/es-toolkit/dist/compat/array/xorBy.mjs"() {
    init_differenceBy2();
    init_intersectionBy2();
    init_last2();
    init_unionBy();
    init_windowed();
    init_identity();
    init_isArrayLikeObject();
    init_iteratee();
  }
});

// node_modules/es-toolkit/dist/compat/array/xorWith.mjs
function xorWith(...values2) {
  const lastValue = last2(values2);
  let comparator = (a, b) => a === b;
  if (typeof lastValue === "function") {
    comparator = lastValue;
    values2 = values2.slice(0, -1);
  }
  const arrays = values2.filter(isArrayLikeObject);
  const union2 = unionWith(...arrays, comparator);
  const intersections = windowed(arrays, 2).map(([arr1, arr2]) => intersectionWith2(arr1, arr2, comparator));
  return differenceWith2(union2, unionWith(...intersections, comparator), comparator);
}
var init_xorWith = __esm({
  "node_modules/es-toolkit/dist/compat/array/xorWith.mjs"() {
    init_differenceWith2();
    init_intersectionWith2();
    init_last2();
    init_unionWith();
    init_windowed();
    init_isArrayLikeObject();
  }
});

// node_modules/es-toolkit/dist/array/zip.mjs
function zip(...arrs) {
  let rowCount = 0;
  for (let i = 0; i < arrs.length; i++) {
    if (arrs[i].length > rowCount) {
      rowCount = arrs[i].length;
    }
  }
  const columnCount = arrs.length;
  const result2 = Array(rowCount);
  for (let i = 0; i < rowCount; ++i) {
    const row = Array(columnCount);
    for (let j = 0; j < columnCount; ++j) {
      row[j] = arrs[j][i];
    }
    result2[i] = row;
  }
  return result2;
}
var init_zip = __esm({
  "node_modules/es-toolkit/dist/array/zip.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/array/zip.mjs
function zip2(...arrays) {
  if (!arrays.length) {
    return [];
  }
  return zip(...arrays.filter((group) => isArrayLikeObject(group)));
}
var init_zip2 = __esm({
  "node_modules/es-toolkit/dist/compat/array/zip.mjs"() {
    init_zip();
    init_isArrayLikeObject();
  }
});

// node_modules/es-toolkit/dist/compat/_internal/assignValue.mjs
var assignValue;
var init_assignValue = __esm({
  "node_modules/es-toolkit/dist/compat/_internal/assignValue.mjs"() {
    init_eq();
    assignValue = (object, key, value) => {
      const objValue = object[key];
      if (!(Object.hasOwn(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        object[key] = value;
      }
    };
  }
});

// node_modules/es-toolkit/dist/compat/array/zipObject.mjs
function zipObject(keys2 = [], values2 = []) {
  const result2 = {};
  for (let i = 0; i < keys2.length; i++) {
    assignValue(result2, keys2[i], values2[i]);
  }
  return result2;
}
var init_zipObject = __esm({
  "node_modules/es-toolkit/dist/compat/array/zipObject.mjs"() {
    init_assignValue();
  }
});

// node_modules/es-toolkit/dist/compat/object/updateWith.mjs
function updateWith(obj, path, updater, customizer) {
  if (obj == null && !isObject(obj)) {
    return obj;
  }
  const resolvedPath = isKey(path, obj) ? [path] : Array.isArray(path) ? path : typeof path === "string" ? toPath(path) : [path];
  let current = obj;
  for (let i = 0; i < resolvedPath.length && current != null; i++) {
    const key = toKey(resolvedPath[i]);
    if (isUnsafeProperty(key)) {
      continue;
    }
    let newValue;
    if (i === resolvedPath.length - 1) {
      newValue = updater(current[key]);
    } else {
      const objValue = current[key];
      const customizerResult = customizer == null ? void 0 : customizer(objValue, key, obj);
      newValue = customizerResult !== void 0 ? customizerResult : isObject(objValue) ? objValue : isIndex(resolvedPath[i + 1]) ? [] : {};
    }
    assignValue(current, key, newValue);
    current = current[key];
  }
  return obj;
}
var init_updateWith = __esm({
  "node_modules/es-toolkit/dist/compat/object/updateWith.mjs"() {
    init_isUnsafeProperty();
    init_assignValue();
    init_isIndex();
    init_isKey();
    init_toKey();
    init_isObject();
    init_toPath();
  }
});

// node_modules/es-toolkit/dist/compat/object/set.mjs
function set(obj, path, value) {
  return updateWith(obj, path, () => value, () => void 0);
}
var init_set = __esm({
  "node_modules/es-toolkit/dist/compat/object/set.mjs"() {
    init_updateWith();
  }
});

// node_modules/es-toolkit/dist/compat/array/zipObjectDeep.mjs
function zipObjectDeep(keys2, values2) {
  const result2 = {};
  if (!isArrayLike(keys2)) {
    return result2;
  }
  if (!isArrayLike(values2)) {
    values2 = [];
  }
  const zipped = zip(Array.from(keys2), Array.from(values2));
  for (let i = 0; i < zipped.length; i++) {
    const [key, value] = zipped[i];
    if (key != null) {
      set(result2, key, value);
    }
  }
  return result2;
}
var init_zipObjectDeep = __esm({
  "node_modules/es-toolkit/dist/compat/array/zipObjectDeep.mjs"() {
    init_zip();
    init_set();
    init_isArrayLike();
  }
});

// node_modules/es-toolkit/dist/compat/array/zipWith.mjs
function zipWith(...combine) {
  let iteratee2 = combine.pop();
  if (!isFunction(iteratee2)) {
    combine.push(iteratee2);
    iteratee2 = void 0;
  }
  if (!(combine == null ? void 0 : combine.length)) {
    return [];
  }
  const result2 = unzip2(combine);
  if (iteratee2 == null) {
    return result2;
  }
  return result2.map((group) => iteratee2(...group));
}
var init_zipWith = __esm({
  "node_modules/es-toolkit/dist/compat/array/zipWith.mjs"() {
    init_unzip2();
    init_isFunction();
  }
});

// node_modules/es-toolkit/dist/compat/function/after.mjs
function after(n, func) {
  if (typeof func !== "function") {
    throw new TypeError("Expected a function");
  }
  n = toInteger(n);
  return function(...args) {
    if (--n < 1) {
      return func.apply(this, args);
    }
  };
}
var init_after = __esm({
  "node_modules/es-toolkit/dist/compat/function/after.mjs"() {
    init_toInteger();
  }
});

// node_modules/es-toolkit/dist/function/ary.mjs
function ary(func, n) {
  return function(...args) {
    return func.apply(this, args.slice(0, n));
  };
}
var init_ary = __esm({
  "node_modules/es-toolkit/dist/function/ary.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/function/ary.mjs
function ary2(func, n = func.length, guard) {
  if (guard) {
    n = func.length;
  }
  if (Number.isNaN(n) || n < 0) {
    n = 0;
  }
  return ary(func, n);
}
var init_ary2 = __esm({
  "node_modules/es-toolkit/dist/compat/function/ary.mjs"() {
    init_ary();
  }
});

// node_modules/es-toolkit/dist/compat/function/attempt.mjs
function attempt(func, ...args) {
  try {
    return func(...args);
  } catch (e) {
    return e instanceof Error ? e : new Error(e);
  }
}
var init_attempt = __esm({
  "node_modules/es-toolkit/dist/compat/function/attempt.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/function/before.mjs
function before(n, func) {
  if (typeof func !== "function") {
    throw new TypeError("Expected a function");
  }
  let result2;
  n = toInteger(n);
  return function(...args) {
    if (--n > 0) {
      result2 = func.apply(this, args);
    }
    if (n <= 1 && func) {
      func = void 0;
    }
    return result2;
  };
}
var init_before = __esm({
  "node_modules/es-toolkit/dist/compat/function/before.mjs"() {
    init_toInteger();
  }
});

// node_modules/es-toolkit/dist/compat/function/bind.mjs
function bind(func, thisObj, ...partialArgs) {
  const bound = function(...providedArgs) {
    const args = [];
    let startIndex = 0;
    for (let i = 0; i < partialArgs.length; i++) {
      const arg = partialArgs[i];
      if (arg === bind.placeholder) {
        args.push(providedArgs[startIndex++]);
      } else {
        args.push(arg);
      }
    }
    for (let i = startIndex; i < providedArgs.length; i++) {
      args.push(providedArgs[i]);
    }
    if (this instanceof bound) {
      return new func(...args);
    }
    return func.apply(thisObj, args);
  };
  return bound;
}
var bindPlaceholder;
var init_bind = __esm({
  "node_modules/es-toolkit/dist/compat/function/bind.mjs"() {
    bindPlaceholder = Symbol("bind.placeholder");
    bind.placeholder = bindPlaceholder;
  }
});

// node_modules/es-toolkit/dist/compat/function/bindKey.mjs
function bindKey(object, key, ...partialArgs) {
  const bound = function(...providedArgs) {
    const args = [];
    let startIndex = 0;
    for (let i = 0; i < partialArgs.length; i++) {
      const arg = partialArgs[i];
      if (arg === bindKey.placeholder) {
        args.push(providedArgs[startIndex++]);
      } else {
        args.push(arg);
      }
    }
    for (let i = startIndex; i < providedArgs.length; i++) {
      args.push(providedArgs[i]);
    }
    if (this instanceof bound) {
      return new object[key](...args);
    }
    return object[key].apply(object, args);
  };
  return bound;
}
var bindKeyPlaceholder;
var init_bindKey = __esm({
  "node_modules/es-toolkit/dist/compat/function/bindKey.mjs"() {
    bindKeyPlaceholder = Symbol("bindKey.placeholder");
    bindKey.placeholder = bindKeyPlaceholder;
  }
});

// node_modules/es-toolkit/dist/compat/function/curry.mjs
function curry(func, arity = func.length, guard) {
  arity = guard ? func.length : arity;
  arity = Number.parseInt(arity, 10);
  if (Number.isNaN(arity) || arity < 1) {
    arity = 0;
  }
  const wrapper = function(...partialArgs) {
    const holders = partialArgs.filter((item) => item === curry.placeholder);
    const length = partialArgs.length - holders.length;
    if (length < arity) {
      return makeCurry(func, arity - length, partialArgs);
    }
    if (this instanceof wrapper) {
      return new func(...partialArgs);
    }
    return func.apply(this, partialArgs);
  };
  wrapper.placeholder = curryPlaceholder;
  return wrapper;
}
function makeCurry(func, arity, partialArgs) {
  function wrapper(...providedArgs) {
    const holders = providedArgs.filter((item) => item === curry.placeholder);
    const length = providedArgs.length - holders.length;
    providedArgs = composeArgs(providedArgs, partialArgs);
    if (length < arity) {
      return makeCurry(func, arity - length, providedArgs);
    }
    if (this instanceof wrapper) {
      return new func(...providedArgs);
    }
    return func.apply(this, providedArgs);
  }
  wrapper.placeholder = curryPlaceholder;
  return wrapper;
}
function composeArgs(providedArgs, partialArgs) {
  const args = [];
  let startIndex = 0;
  for (let i = 0; i < partialArgs.length; i++) {
    const arg = partialArgs[i];
    if (arg === curry.placeholder && startIndex < providedArgs.length) {
      args.push(providedArgs[startIndex++]);
    } else {
      args.push(arg);
    }
  }
  for (let i = startIndex; i < providedArgs.length; i++) {
    args.push(providedArgs[i]);
  }
  return args;
}
var curryPlaceholder;
var init_curry = __esm({
  "node_modules/es-toolkit/dist/compat/function/curry.mjs"() {
    curryPlaceholder = Symbol("curry.placeholder");
    curry.placeholder = curryPlaceholder;
  }
});

// node_modules/es-toolkit/dist/compat/function/curryRight.mjs
function curryRight(func, arity = func.length, guard) {
  arity = guard ? func.length : arity;
  arity = Number.parseInt(arity, 10);
  if (Number.isNaN(arity) || arity < 1) {
    arity = 0;
  }
  const wrapper = function(...partialArgs) {
    const holders = partialArgs.filter((item) => item === curryRight.placeholder);
    const length = partialArgs.length - holders.length;
    if (length < arity) {
      return makeCurryRight(func, arity - length, partialArgs);
    }
    if (this instanceof wrapper) {
      return new func(...partialArgs);
    }
    return func.apply(this, partialArgs);
  };
  wrapper.placeholder = curryRightPlaceholder;
  return wrapper;
}
function makeCurryRight(func, arity, partialArgs) {
  function wrapper(...providedArgs) {
    const holders = providedArgs.filter((item) => item === curryRight.placeholder);
    const length = providedArgs.length - holders.length;
    providedArgs = composeArgs2(providedArgs, partialArgs);
    if (length < arity) {
      return makeCurryRight(func, arity - length, providedArgs);
    }
    if (this instanceof wrapper) {
      return new func(...providedArgs);
    }
    return func.apply(this, providedArgs);
  }
  wrapper.placeholder = curryRightPlaceholder;
  return wrapper;
}
function composeArgs2(providedArgs, partialArgs) {
  const placeholderLength = partialArgs.filter((arg) => arg === curryRight.placeholder).length;
  const rangeLength = Math.max(providedArgs.length - placeholderLength, 0);
  const args = [];
  let providedIndex = 0;
  for (let i = 0; i < rangeLength; i++) {
    args.push(providedArgs[providedIndex++]);
  }
  for (let i = 0; i < partialArgs.length; i++) {
    const arg = partialArgs[i];
    if (arg === curryRight.placeholder) {
      if (providedIndex < providedArgs.length) {
        args.push(providedArgs[providedIndex++]);
      } else {
        args.push(arg);
      }
    } else {
      args.push(arg);
    }
  }
  return args;
}
var curryRightPlaceholder;
var init_curryRight = __esm({
  "node_modules/es-toolkit/dist/compat/function/curryRight.mjs"() {
    curryRightPlaceholder = Symbol("curryRight.placeholder");
    curryRight.placeholder = curryRightPlaceholder;
  }
});

// node_modules/es-toolkit/dist/function/debounce.mjs
function debounce(func, debounceMs, { signal, edges } = {}) {
  let pendingThis = void 0;
  let pendingArgs = null;
  const leading = edges != null && edges.includes("leading");
  const trailing = edges == null || edges.includes("trailing");
  const invoke2 = () => {
    if (pendingArgs !== null) {
      func.apply(pendingThis, pendingArgs);
      pendingThis = void 0;
      pendingArgs = null;
    }
  };
  const onTimerEnd = () => {
    if (trailing) {
      invoke2();
    }
    cancel();
  };
  let timeoutId = null;
  const schedule = () => {
    if (timeoutId != null) {
      clearTimeout(timeoutId);
    }
    timeoutId = setTimeout(() => {
      timeoutId = null;
      onTimerEnd();
    }, debounceMs);
  };
  const cancelTimer = () => {
    if (timeoutId !== null) {
      clearTimeout(timeoutId);
      timeoutId = null;
    }
  };
  const cancel = () => {
    cancelTimer();
    pendingThis = void 0;
    pendingArgs = null;
  };
  const flush = () => {
    cancelTimer();
    invoke2();
  };
  const debounced = function(...args) {
    if (signal == null ? void 0 : signal.aborted) {
      return;
    }
    pendingThis = this;
    pendingArgs = args;
    const isFirstCall = timeoutId == null;
    schedule();
    if (leading && isFirstCall) {
      invoke2();
    }
  };
  debounced.schedule = schedule;
  debounced.cancel = cancel;
  debounced.flush = flush;
  signal == null ? void 0 : signal.addEventListener("abort", cancel, { once: true });
  return debounced;
}
var init_debounce = __esm({
  "node_modules/es-toolkit/dist/function/debounce.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/function/debounce.mjs
function debounce2(func, debounceMs = 0, options = {}) {
  if (typeof options !== "object") {
    options = {};
  }
  const { leading = false, trailing = true, maxWait } = options;
  const edges = Array(2);
  if (leading) {
    edges[0] = "leading";
  }
  if (trailing) {
    edges[1] = "trailing";
  }
  let result2 = void 0;
  let pendingAt = null;
  const _debounced = debounce(function(...args) {
    result2 = func.apply(this, args);
    pendingAt = null;
  }, debounceMs, { edges });
  const debounced = function(...args) {
    if (maxWait != null) {
      if (pendingAt === null) {
        pendingAt = Date.now();
      }
      if (Date.now() - pendingAt >= maxWait) {
        result2 = func.apply(this, args);
        pendingAt = Date.now();
        _debounced.cancel();
        _debounced.schedule();
        return result2;
      }
    }
    _debounced.apply(this, args);
    return result2;
  };
  const flush = () => {
    _debounced.flush();
    return result2;
  };
  debounced.cancel = _debounced.cancel;
  debounced.flush = flush;
  return debounced;
}
var init_debounce2 = __esm({
  "node_modules/es-toolkit/dist/compat/function/debounce.mjs"() {
    init_debounce();
  }
});

// node_modules/es-toolkit/dist/compat/function/defer.mjs
function defer(func, ...args) {
  if (typeof func !== "function") {
    throw new TypeError("Expected a function");
  }
  return setTimeout(func, 1, ...args);
}
var init_defer = __esm({
  "node_modules/es-toolkit/dist/compat/function/defer.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/function/delay.mjs
function delay(func, wait, ...args) {
  if (typeof func !== "function") {
    throw new TypeError("Expected a function");
  }
  return setTimeout(func, toNumber(wait) || 0, ...args);
}
var init_delay = __esm({
  "node_modules/es-toolkit/dist/compat/function/delay.mjs"() {
    init_toNumber();
  }
});

// node_modules/es-toolkit/dist/compat/function/flip.mjs
function flip(func) {
  return function(...args) {
    return func.apply(this, args.reverse());
  };
}
var init_flip = __esm({
  "node_modules/es-toolkit/dist/compat/function/flip.mjs"() {
  }
});

// node_modules/es-toolkit/dist/function/flow.mjs
function flow(...funcs) {
  return function(...args) {
    let result2 = funcs.length ? funcs[0].apply(this, args) : args[0];
    for (let i = 1; i < funcs.length; i++) {
      result2 = funcs[i].call(this, result2);
    }
    return result2;
  };
}
var init_flow = __esm({
  "node_modules/es-toolkit/dist/function/flow.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/function/flow.mjs
function flow2(...funcs) {
  const flattenFuncs = flatten(funcs, 1);
  if (flattenFuncs.some((func) => typeof func !== "function")) {
    throw new TypeError("Expected a function");
  }
  return flow(...flattenFuncs);
}
var init_flow2 = __esm({
  "node_modules/es-toolkit/dist/compat/function/flow.mjs"() {
    init_flatten();
    init_flow();
  }
});

// node_modules/es-toolkit/dist/function/flowRight.mjs
function flowRight(...funcs) {
  return flow(...funcs.reverse());
}
var init_flowRight = __esm({
  "node_modules/es-toolkit/dist/function/flowRight.mjs"() {
    init_flow();
  }
});

// node_modules/es-toolkit/dist/compat/function/flowRight.mjs
function flowRight2(...funcs) {
  const flattenFuncs = flatten(funcs, 1);
  if (flattenFuncs.some((func) => typeof func !== "function")) {
    throw new TypeError("Expected a function");
  }
  return flowRight(...flattenFuncs);
}
var init_flowRight2 = __esm({
  "node_modules/es-toolkit/dist/compat/function/flowRight.mjs"() {
    init_flatten();
    init_flowRight();
  }
});

// node_modules/es-toolkit/dist/compat/function/memoize.mjs
function memoize(func, resolver) {
  if (typeof func !== "function" || resolver != null && typeof resolver !== "function") {
    throw new TypeError("Expected a function");
  }
  const memoized = function(...args) {
    const key = resolver ? resolver.apply(this, args) : args[0];
    const cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    const result2 = func.apply(this, args);
    memoized.cache = cache.set(key, result2) || cache;
    return result2;
  };
  const CacheConstructor = memoize.Cache || Map;
  memoized.cache = new CacheConstructor();
  return memoized;
}
var init_memoize = __esm({
  "node_modules/es-toolkit/dist/compat/function/memoize.mjs"() {
    memoize.Cache = Map;
  }
});

// node_modules/es-toolkit/dist/compat/function/nthArg.mjs
function nthArg(n = 0) {
  return function(...args) {
    return args.at(toInteger(n));
  };
}
var init_nthArg = __esm({
  "node_modules/es-toolkit/dist/compat/function/nthArg.mjs"() {
    init_toInteger();
  }
});

// node_modules/es-toolkit/dist/function/once.mjs
function once(func) {
  let called = false;
  let cache;
  return function(...args) {
    if (!called) {
      called = true;
      cache = func(...args);
    }
    return cache;
  };
}
var init_once = __esm({
  "node_modules/es-toolkit/dist/function/once.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/function/once.mjs
function once2(func) {
  return once(func);
}
var init_once2 = __esm({
  "node_modules/es-toolkit/dist/compat/function/once.mjs"() {
    init_once();
  }
});

// node_modules/es-toolkit/dist/compat/function/overArgs.mjs
function overArgs(func, ..._transforms) {
  if (typeof func !== "function") {
    throw new TypeError("Expected a function");
  }
  const transforms = _transforms.flat();
  return function(...args) {
    const length = Math.min(args.length, transforms.length);
    const transformedArgs = [...args];
    for (let i = 0; i < length; i++) {
      const transform2 = iteratee(transforms[i] ?? identity);
      transformedArgs[i] = transform2.call(this, args[i]);
    }
    return func.apply(this, transformedArgs);
  };
}
var init_overArgs = __esm({
  "node_modules/es-toolkit/dist/compat/function/overArgs.mjs"() {
    init_identity();
    init_iteratee();
  }
});

// node_modules/es-toolkit/dist/function/partial.mjs
function partial(func, ...partialArgs) {
  return partialImpl(func, placeholderSymbol, ...partialArgs);
}
function partialImpl(func, placeholder, ...partialArgs) {
  const partialed = function(...providedArgs) {
    let providedArgsIndex = 0;
    const substitutedArgs = partialArgs.slice().map((arg) => arg === placeholder ? providedArgs[providedArgsIndex++] : arg);
    const remainingArgs = providedArgs.slice(providedArgsIndex);
    return func.apply(this, substitutedArgs.concat(remainingArgs));
  };
  if (func.prototype) {
    partialed.prototype = Object.create(func.prototype);
  }
  return partialed;
}
var placeholderSymbol;
var init_partial = __esm({
  "node_modules/es-toolkit/dist/function/partial.mjs"() {
    placeholderSymbol = Symbol("partial.placeholder");
    partial.placeholder = placeholderSymbol;
  }
});

// node_modules/es-toolkit/dist/compat/function/partial.mjs
function partial2(func, ...partialArgs) {
  return partialImpl(func, partial2.placeholder, ...partialArgs);
}
var init_partial2 = __esm({
  "node_modules/es-toolkit/dist/compat/function/partial.mjs"() {
    init_partial();
    partial2.placeholder = Symbol("compat.partial.placeholder");
  }
});

// node_modules/es-toolkit/dist/function/partialRight.mjs
function partialRight(func, ...partialArgs) {
  return partialRightImpl(func, placeholderSymbol2, ...partialArgs);
}
function partialRightImpl(func, placeholder, ...partialArgs) {
  const partialedRight = function(...providedArgs) {
    const placeholderLength = partialArgs.filter((arg) => arg === placeholder).length;
    const rangeLength = Math.max(providedArgs.length - placeholderLength, 0);
    const remainingArgs = providedArgs.slice(0, rangeLength);
    let providedArgsIndex = rangeLength;
    const substitutedArgs = partialArgs.slice().map((arg) => arg === placeholder ? providedArgs[providedArgsIndex++] : arg);
    return func.apply(this, remainingArgs.concat(substitutedArgs));
  };
  if (func.prototype) {
    partialedRight.prototype = Object.create(func.prototype);
  }
  return partialedRight;
}
var placeholderSymbol2;
var init_partialRight = __esm({
  "node_modules/es-toolkit/dist/function/partialRight.mjs"() {
    placeholderSymbol2 = Symbol("partialRight.placeholder");
    partialRight.placeholder = placeholderSymbol2;
  }
});

// node_modules/es-toolkit/dist/compat/function/partialRight.mjs
function partialRight2(func, ...partialArgs) {
  return partialRightImpl(func, partialRight2.placeholder, ...partialArgs);
}
var init_partialRight2 = __esm({
  "node_modules/es-toolkit/dist/compat/function/partialRight.mjs"() {
    init_partialRight();
    partialRight2.placeholder = Symbol("compat.partialRight.placeholder");
  }
});

// node_modules/es-toolkit/dist/compat/function/rearg.mjs
function rearg(func, ...indices) {
  const flattenIndices = flatten2(indices);
  return function(...args) {
    const reorderedArgs = flattenIndices.map((i) => args[i]).slice(0, args.length);
    for (let i = reorderedArgs.length; i < args.length; i++) {
      reorderedArgs.push(args[i]);
    }
    return func.apply(this, reorderedArgs);
  };
}
var init_rearg = __esm({
  "node_modules/es-toolkit/dist/compat/function/rearg.mjs"() {
    init_flatten2();
  }
});

// node_modules/es-toolkit/dist/function/rest.mjs
function rest(func, startIndex = func.length - 1) {
  return function(...args) {
    const rest3 = args.slice(startIndex);
    const params = args.slice(0, startIndex);
    while (params.length < startIndex) {
      params.push(void 0);
    }
    return func.apply(this, [...params, rest3]);
  };
}
var init_rest = __esm({
  "node_modules/es-toolkit/dist/function/rest.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/function/rest.mjs
function rest2(func, start = func.length - 1) {
  start = Number.parseInt(start, 10);
  if (Number.isNaN(start) || start < 0) {
    start = func.length - 1;
  }
  return rest(func, start);
}
var init_rest2 = __esm({
  "node_modules/es-toolkit/dist/compat/function/rest.mjs"() {
    init_rest();
  }
});

// node_modules/es-toolkit/dist/compat/function/spread.mjs
function spread(func, argsIndex = 0) {
  argsIndex = Number.parseInt(argsIndex, 10);
  if (Number.isNaN(argsIndex) || argsIndex < 0) {
    argsIndex = 0;
  }
  return function(...args) {
    const array = args[argsIndex];
    const params = args.slice(0, argsIndex);
    if (array) {
      params.push(...array);
    }
    return func.apply(this, params);
  };
}
var init_spread = __esm({
  "node_modules/es-toolkit/dist/compat/function/spread.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/function/throttle.mjs
function throttle(func, throttleMs = 0, options = {}) {
  if (typeof options !== "object") {
    options = {};
  }
  const { leading = true, trailing = true } = options;
  return debounce2(func, throttleMs, {
    leading,
    trailing,
    maxWait: throttleMs
  });
}
var init_throttle = __esm({
  "node_modules/es-toolkit/dist/compat/function/throttle.mjs"() {
    init_debounce2();
  }
});

// node_modules/es-toolkit/dist/compat/function/unary.mjs
function unary(func) {
  return ary2(func, 1);
}
var init_unary = __esm({
  "node_modules/es-toolkit/dist/compat/function/unary.mjs"() {
    init_ary2();
  }
});

// node_modules/es-toolkit/dist/compat/function/wrap.mjs
function wrap(value, wrapper) {
  return function(...args) {
    const wrapFn = isFunction(wrapper) ? wrapper : identity;
    return wrapFn.apply(this, [value, ...args]);
  };
}
var init_wrap = __esm({
  "node_modules/es-toolkit/dist/compat/function/wrap.mjs"() {
    init_identity();
    init_isFunction();
  }
});

// node_modules/es-toolkit/dist/compat/util/toString.mjs
function toString(value) {
  if (value == null) {
    return "";
  }
  if (typeof value === "string") {
    return value;
  }
  if (Array.isArray(value)) {
    return value.map(toString).join(",");
  }
  const result2 = String(value);
  if (result2 === "0" && Object.is(Number(value), -0)) {
    return "-0";
  }
  return result2;
}
var init_toString = __esm({
  "node_modules/es-toolkit/dist/compat/util/toString.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/math/add.mjs
function add(value, other) {
  if (value === void 0 && other === void 0) {
    return 0;
  }
  if (value === void 0 || other === void 0) {
    return value ?? other;
  }
  if (typeof value === "string" || typeof other === "string") {
    value = toString(value);
    other = toString(other);
  } else {
    value = toNumber(value);
    other = toNumber(other);
  }
  return value + other;
}
var init_add = __esm({
  "node_modules/es-toolkit/dist/compat/math/add.mjs"() {
    init_toNumber();
    init_toString();
  }
});

// node_modules/es-toolkit/dist/compat/_internal/decimalAdjust.mjs
function decimalAdjust(type, number, precision = 0) {
  number = Number(number);
  if (Object.is(number, -0)) {
    number = "-0";
  }
  precision = Math.min(Number.parseInt(precision, 10), 292);
  if (precision) {
    const [magnitude, exponent = 0] = number.toString().split("e");
    let adjustedValue = Math[type](Number(`${magnitude}e${Number(exponent) + precision}`));
    if (Object.is(adjustedValue, -0)) {
      adjustedValue = "-0";
    }
    const [newMagnitude, newExponent = 0] = adjustedValue.toString().split("e");
    return Number(`${newMagnitude}e${Number(newExponent) - precision}`);
  }
  return Math[type](Number(number));
}
var init_decimalAdjust = __esm({
  "node_modules/es-toolkit/dist/compat/_internal/decimalAdjust.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/math/ceil.mjs
function ceil(number, precision = 0) {
  return decimalAdjust("ceil", number, precision);
}
var init_ceil = __esm({
  "node_modules/es-toolkit/dist/compat/math/ceil.mjs"() {
    init_decimalAdjust();
  }
});

// node_modules/es-toolkit/dist/compat/math/divide.mjs
function divide(value, other) {
  if (value === void 0 && other === void 0) {
    return 1;
  }
  if (value === void 0 || other === void 0) {
    return value ?? other;
  }
  if (typeof value === "string" || typeof other === "string") {
    value = toString(value);
    other = toString(other);
  } else {
    value = toNumber(value);
    other = toNumber(other);
  }
  return value / other;
}
var init_divide = __esm({
  "node_modules/es-toolkit/dist/compat/math/divide.mjs"() {
    init_toNumber();
    init_toString();
  }
});

// node_modules/es-toolkit/dist/compat/math/floor.mjs
function floor(number, precision = 0) {
  return decimalAdjust("floor", number, precision);
}
var init_floor = __esm({
  "node_modules/es-toolkit/dist/compat/math/floor.mjs"() {
    init_decimalAdjust();
  }
});

// node_modules/es-toolkit/dist/math/inRange.mjs
function inRange(value, minimum, maximum) {
  if (maximum == null) {
    maximum = minimum;
    minimum = 0;
  }
  if (minimum >= maximum) {
    throw new Error("The maximum value must be greater than the minimum value.");
  }
  return minimum <= value && value < maximum;
}
var init_inRange = __esm({
  "node_modules/es-toolkit/dist/math/inRange.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/math/inRange.mjs
function inRange2(value, minimum, maximum) {
  if (!minimum) {
    minimum = 0;
  }
  if (maximum != null && !maximum) {
    maximum = 0;
  }
  if (minimum != null && typeof minimum !== "number") {
    minimum = Number(minimum);
  }
  if (maximum == null && minimum === 0) {
    return false;
  }
  if (maximum != null && typeof maximum !== "number") {
    maximum = Number(maximum);
  }
  if (maximum != null && minimum > maximum) {
    [minimum, maximum] = [maximum, minimum];
  }
  if (minimum === maximum) {
    return false;
  }
  return inRange(value, minimum, maximum);
}
var init_inRange2 = __esm({
  "node_modules/es-toolkit/dist/compat/math/inRange.mjs"() {
    init_inRange();
  }
});

// node_modules/es-toolkit/dist/compat/math/max.mjs
function max(items) {
  if (!items || items.length === 0) {
    return void 0;
  }
  let maxResult = void 0;
  for (let i = 0; i < items.length; i++) {
    const current = items[i];
    if (current == null || Number.isNaN(current) || typeof current === "symbol") {
      continue;
    }
    if (maxResult === void 0 || current > maxResult) {
      maxResult = current;
    }
  }
  return maxResult;
}
var init_max = __esm({
  "node_modules/es-toolkit/dist/compat/math/max.mjs"() {
  }
});

// node_modules/es-toolkit/dist/array/maxBy.mjs
function maxBy(items, getValue) {
  if (items.length === 0) {
    return void 0;
  }
  let maxElement = items[0];
  let max2 = getValue(maxElement);
  for (let i = 1; i < items.length; i++) {
    const element = items[i];
    const value = getValue(element);
    if (value > max2) {
      max2 = value;
      maxElement = element;
    }
  }
  return maxElement;
}
var init_maxBy = __esm({
  "node_modules/es-toolkit/dist/array/maxBy.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/math/maxBy.mjs
function maxBy2(items, iteratee$1) {
  if (items == null) {
    return void 0;
  }
  return maxBy(Array.from(items), iteratee(iteratee$1 ?? identity));
}
var init_maxBy2 = __esm({
  "node_modules/es-toolkit/dist/compat/math/maxBy.mjs"() {
    init_maxBy();
    init_identity();
    init_iteratee();
  }
});

// node_modules/es-toolkit/dist/compat/math/sumBy.mjs
function sumBy(array, iteratee$1) {
  if (!array || !array.length) {
    return 0;
  }
  if (iteratee$1 != null) {
    iteratee$1 = iteratee(iteratee$1);
  }
  let result2 = void 0;
  for (let i = 0; i < array.length; i++) {
    const current = iteratee$1 ? iteratee$1(array[i]) : array[i];
    if (current !== void 0) {
      if (result2 === void 0) {
        result2 = current;
      } else {
        result2 += current;
      }
    }
  }
  return result2;
}
var init_sumBy = __esm({
  "node_modules/es-toolkit/dist/compat/math/sumBy.mjs"() {
    init_iteratee();
  }
});

// node_modules/es-toolkit/dist/compat/math/sum.mjs
function sum(array) {
  return sumBy(array);
}
var init_sum = __esm({
  "node_modules/es-toolkit/dist/compat/math/sum.mjs"() {
    init_sumBy();
  }
});

// node_modules/es-toolkit/dist/compat/math/mean.mjs
function mean(nums) {
  const length = nums ? nums.length : 0;
  return length === 0 ? NaN : sum(nums) / length;
}
var init_mean = __esm({
  "node_modules/es-toolkit/dist/compat/math/mean.mjs"() {
    init_sum();
  }
});

// node_modules/es-toolkit/dist/math/sum.mjs
function sum2(nums) {
  let result2 = 0;
  for (let i = 0; i < nums.length; i++) {
    result2 += nums[i];
  }
  return result2;
}
var init_sum2 = __esm({
  "node_modules/es-toolkit/dist/math/sum.mjs"() {
  }
});

// node_modules/es-toolkit/dist/math/mean.mjs
function mean2(nums) {
  return sum2(nums) / nums.length;
}
var init_mean2 = __esm({
  "node_modules/es-toolkit/dist/math/mean.mjs"() {
    init_sum2();
  }
});

// node_modules/es-toolkit/dist/math/meanBy.mjs
function meanBy(items, getValue) {
  const nums = items.map((x) => getValue(x));
  return mean2(nums);
}
var init_meanBy = __esm({
  "node_modules/es-toolkit/dist/math/meanBy.mjs"() {
    init_mean2();
  }
});

// node_modules/es-toolkit/dist/compat/math/meanBy.mjs
function meanBy2(items, iteratee$1) {
  if (items == null) {
    return NaN;
  }
  return meanBy(Array.from(items), iteratee(iteratee$1 ?? identity));
}
var init_meanBy2 = __esm({
  "node_modules/es-toolkit/dist/compat/math/meanBy.mjs"() {
    init_identity();
    init_meanBy();
    init_iteratee();
  }
});

// node_modules/es-toolkit/dist/compat/math/min.mjs
function min(items) {
  if (!items || items.length === 0) {
    return void 0;
  }
  let minResult = void 0;
  for (let i = 0; i < items.length; i++) {
    const current = items[i];
    if (current == null || Number.isNaN(current) || typeof current === "symbol") {
      continue;
    }
    if (minResult === void 0 || current < minResult) {
      minResult = current;
    }
  }
  return minResult;
}
var init_min = __esm({
  "node_modules/es-toolkit/dist/compat/math/min.mjs"() {
  }
});

// node_modules/es-toolkit/dist/array/minBy.mjs
function minBy(items, getValue) {
  if (items.length === 0) {
    return void 0;
  }
  let minElement = items[0];
  let min2 = getValue(minElement);
  for (let i = 1; i < items.length; i++) {
    const element = items[i];
    const value = getValue(element);
    if (value < min2) {
      min2 = value;
      minElement = element;
    }
  }
  return minElement;
}
var init_minBy = __esm({
  "node_modules/es-toolkit/dist/array/minBy.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/math/minBy.mjs
function minBy2(items, iteratee$1) {
  if (items == null) {
    return void 0;
  }
  return minBy(Array.from(items), iteratee(iteratee$1 ?? identity));
}
var init_minBy2 = __esm({
  "node_modules/es-toolkit/dist/compat/math/minBy.mjs"() {
    init_minBy();
    init_identity();
    init_iteratee();
  }
});

// node_modules/es-toolkit/dist/compat/math/multiply.mjs
function multiply(value, other) {
  if (value === void 0 && other === void 0) {
    return 1;
  }
  if (value === void 0 || other === void 0) {
    return value ?? other;
  }
  if (typeof value === "string" || typeof other === "string") {
    value = toString(value);
    other = toString(other);
  } else {
    value = toNumber(value);
    other = toNumber(other);
  }
  return value * other;
}
var init_multiply = __esm({
  "node_modules/es-toolkit/dist/compat/math/multiply.mjs"() {
    init_toNumber();
    init_toString();
  }
});

// node_modules/es-toolkit/dist/compat/math/parseInt.mjs
function parseInt(string, radix = 0, guard) {
  if (guard) {
    radix = 0;
  }
  return Number.parseInt(string, radix);
}
var init_parseInt = __esm({
  "node_modules/es-toolkit/dist/compat/math/parseInt.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/math/random.mjs
function random2(...args) {
  let minimum = 0;
  let maximum = 1;
  let floating = false;
  switch (args.length) {
    case 1: {
      if (typeof args[0] === "boolean") {
        floating = args[0];
      } else {
        maximum = args[0];
      }
      break;
    }
    case 2: {
      if (typeof args[1] === "boolean") {
        maximum = args[0];
        floating = args[1];
      } else {
        minimum = args[0];
        maximum = args[1];
      }
    }
    case 3: {
      if (typeof args[2] === "object" && args[2] != null && args[2][args[1]] === args[0]) {
        minimum = 0;
        maximum = args[0];
        floating = false;
      } else {
        minimum = args[0];
        maximum = args[1];
        floating = args[2];
      }
    }
  }
  if (typeof minimum !== "number") {
    minimum = Number(minimum);
  }
  if (typeof maximum !== "number") {
    minimum = Number(maximum);
  }
  if (!minimum) {
    minimum = 0;
  }
  if (!maximum) {
    maximum = 0;
  }
  if (minimum > maximum) {
    [minimum, maximum] = [maximum, minimum];
  }
  minimum = clamp2(minimum, -Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);
  maximum = clamp2(maximum, -Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);
  if (minimum === maximum) {
    return minimum;
  }
  if (floating) {
    return random(minimum, maximum + 1);
  } else {
    return randomInt(minimum, maximum + 1);
  }
}
var init_random2 = __esm({
  "node_modules/es-toolkit/dist/compat/math/random.mjs"() {
    init_clamp2();
    init_random();
    init_randomInt();
  }
});

// node_modules/es-toolkit/dist/compat/math/range.mjs
function range2(start, end, step) {
  if (step && typeof step !== "number" && isIterateeCall(start, end, step)) {
    end = step = void 0;
  }
  start = toFinite(start);
  if (end === void 0) {
    end = start;
    start = 0;
  } else {
    end = toFinite(end);
  }
  step = step === void 0 ? start < end ? 1 : -1 : toFinite(step);
  const length = Math.max(Math.ceil((end - start) / (step || 1)), 0);
  const result2 = new Array(length);
  for (let index = 0; index < length; index++) {
    result2[index] = start;
    start += step;
  }
  return result2;
}
var init_range2 = __esm({
  "node_modules/es-toolkit/dist/compat/math/range.mjs"() {
    init_isIterateeCall();
    init_toFinite();
  }
});

// node_modules/es-toolkit/dist/compat/math/rangeRight.mjs
function rangeRight(start, end, step) {
  if (step && typeof step !== "number" && isIterateeCall(start, end, step)) {
    end = step = void 0;
  }
  start = toFinite(start);
  if (end === void 0) {
    end = start;
    start = 0;
  } else {
    end = toFinite(end);
  }
  step = step === void 0 ? start < end ? 1 : -1 : toFinite(step);
  const length = Math.max(Math.ceil((end - start) / (step || 1)), 0);
  const result2 = new Array(length);
  for (let index = length - 1; index >= 0; index--) {
    result2[index] = start;
    start += step;
  }
  return result2;
}
var init_rangeRight = __esm({
  "node_modules/es-toolkit/dist/compat/math/rangeRight.mjs"() {
    init_isIterateeCall();
    init_toFinite();
  }
});

// node_modules/es-toolkit/dist/compat/math/round.mjs
function round(number, precision = 0) {
  return decimalAdjust("round", number, precision);
}
var init_round = __esm({
  "node_modules/es-toolkit/dist/compat/math/round.mjs"() {
    init_decimalAdjust();
  }
});

// node_modules/es-toolkit/dist/compat/math/subtract.mjs
function subtract(value, other) {
  if (value === void 0 && other === void 0) {
    return 0;
  }
  if (value === void 0 || other === void 0) {
    return value ?? other;
  }
  if (typeof value === "string" || typeof other === "string") {
    value = toString(value);
    other = toString(other);
  } else {
    value = toNumber(value);
    other = toNumber(other);
  }
  return value - other;
}
var init_subtract = __esm({
  "node_modules/es-toolkit/dist/compat/math/subtract.mjs"() {
    init_toNumber();
    init_toString();
  }
});

// node_modules/es-toolkit/dist/predicate/isPlainObject.mjs
function isPlainObject(value) {
  if (!value || typeof value !== "object") {
    return false;
  }
  const proto = Object.getPrototypeOf(value);
  const hasObjectPrototype = proto === null || proto === Object.prototype || Object.getPrototypeOf(proto) === null;
  if (!hasObjectPrototype) {
    return false;
  }
  return Object.prototype.toString.call(value) === "[object Object]";
}
var init_isPlainObject = __esm({
  "node_modules/es-toolkit/dist/predicate/isPlainObject.mjs"() {
  }
});

// node_modules/es-toolkit/dist/predicate/isEqualWith.mjs
function isEqualWith(a, b, areValuesEqual) {
  return isEqualWithImpl(a, b, void 0, void 0, void 0, void 0, areValuesEqual);
}
function isEqualWithImpl(a, b, property2, aParent, bParent, stack, areValuesEqual) {
  const result2 = areValuesEqual(a, b, property2, aParent, bParent, stack);
  if (result2 !== void 0) {
    return result2;
  }
  if (typeof a === typeof b) {
    switch (typeof a) {
      case "bigint":
      case "string":
      case "boolean":
      case "symbol":
      case "undefined": {
        return a === b;
      }
      case "number": {
        return a === b || Object.is(a, b);
      }
      case "function": {
        return a === b;
      }
      case "object": {
        return areObjectsEqual(a, b, stack, areValuesEqual);
      }
    }
  }
  return areObjectsEqual(a, b, stack, areValuesEqual);
}
function areObjectsEqual(a, b, stack, areValuesEqual) {
  if (Object.is(a, b)) {
    return true;
  }
  let aTag = getTag(a);
  let bTag = getTag(b);
  if (aTag === argumentsTag) {
    aTag = objectTag;
  }
  if (bTag === argumentsTag) {
    bTag = objectTag;
  }
  if (aTag !== bTag) {
    return false;
  }
  switch (aTag) {
    case stringTag:
      return a.toString() === b.toString();
    case numberTag: {
      const x = a.valueOf();
      const y = b.valueOf();
      return eq(x, y);
    }
    case booleanTag:
    case dateTag:
    case symbolTag:
      return Object.is(a.valueOf(), b.valueOf());
    case regexpTag: {
      return a.source === b.source && a.flags === b.flags;
    }
    case functionTag: {
      return a === b;
    }
  }
  stack = stack ?? /* @__PURE__ */ new Map();
  const aStack = stack.get(a);
  const bStack = stack.get(b);
  if (aStack != null && bStack != null) {
    return aStack === b;
  }
  stack.set(a, b);
  stack.set(b, a);
  try {
    switch (aTag) {
      case mapTag: {
        if (a.size !== b.size) {
          return false;
        }
        for (const [key, value] of a.entries()) {
          if (!b.has(key) || !isEqualWithImpl(value, b.get(key), key, a, b, stack, areValuesEqual)) {
            return false;
          }
        }
        return true;
      }
      case setTag: {
        if (a.size !== b.size) {
          return false;
        }
        const aValues = Array.from(a.values());
        const bValues = Array.from(b.values());
        for (let i = 0; i < aValues.length; i++) {
          const aValue = aValues[i];
          const index = bValues.findIndex((bValue) => {
            return isEqualWithImpl(aValue, bValue, void 0, a, b, stack, areValuesEqual);
          });
          if (index === -1) {
            return false;
          }
          bValues.splice(index, 1);
        }
        return true;
      }
      case arrayTag:
      case uint8ArrayTag:
      case uint8ClampedArrayTag:
      case uint16ArrayTag:
      case uint32ArrayTag:
      case bigUint64ArrayTag:
      case int8ArrayTag:
      case int16ArrayTag:
      case int32ArrayTag:
      case bigInt64ArrayTag:
      case float32ArrayTag:
      case float64ArrayTag: {
        if (typeof Buffer !== "undefined" && Buffer.isBuffer(a) !== Buffer.isBuffer(b)) {
          return false;
        }
        if (a.length !== b.length) {
          return false;
        }
        for (let i = 0; i < a.length; i++) {
          if (!isEqualWithImpl(a[i], b[i], i, a, b, stack, areValuesEqual)) {
            return false;
          }
        }
        return true;
      }
      case arrayBufferTag: {
        if (a.byteLength !== b.byteLength) {
          return false;
        }
        return areObjectsEqual(new Uint8Array(a), new Uint8Array(b), stack, areValuesEqual);
      }
      case dataViewTag: {
        if (a.byteLength !== b.byteLength || a.byteOffset !== b.byteOffset) {
          return false;
        }
        return areObjectsEqual(new Uint8Array(a), new Uint8Array(b), stack, areValuesEqual);
      }
      case errorTag: {
        return a.name === b.name && a.message === b.message;
      }
      case objectTag: {
        const areEqualInstances = areObjectsEqual(a.constructor, b.constructor, stack, areValuesEqual) || isPlainObject(a) && isPlainObject(b);
        if (!areEqualInstances) {
          return false;
        }
        const aKeys = [...Object.keys(a), ...getSymbols(a)];
        const bKeys = [...Object.keys(b), ...getSymbols(b)];
        if (aKeys.length !== bKeys.length) {
          return false;
        }
        for (let i = 0; i < aKeys.length; i++) {
          const propKey = aKeys[i];
          const aProp = a[propKey];
          if (!Object.hasOwn(b, propKey)) {
            return false;
          }
          const bProp = b[propKey];
          if (!isEqualWithImpl(aProp, bProp, propKey, a, b, stack, areValuesEqual)) {
            return false;
          }
        }
        return true;
      }
      default: {
        return false;
      }
    }
  } finally {
    stack.delete(a);
    stack.delete(b);
  }
}
var init_isEqualWith = __esm({
  "node_modules/es-toolkit/dist/predicate/isEqualWith.mjs"() {
    init_isPlainObject();
    init_getSymbols();
    init_getTag();
    init_tags();
    init_eq();
  }
});

// node_modules/es-toolkit/dist/function/noop.mjs
function noop() {
}
var init_noop = __esm({
  "node_modules/es-toolkit/dist/function/noop.mjs"() {
  }
});

// node_modules/es-toolkit/dist/predicate/isEqual.mjs
function isEqual(a, b) {
  return isEqualWith(a, b, noop);
}
var init_isEqual = __esm({
  "node_modules/es-toolkit/dist/predicate/isEqual.mjs"() {
    init_isEqualWith();
    init_noop();
  }
});

// node_modules/es-toolkit/dist/compat/function/noop.mjs
function noop2(..._) {
}
var init_noop2 = __esm({
  "node_modules/es-toolkit/dist/compat/function/noop.mjs"() {
  }
});

// node_modules/es-toolkit/dist/predicate/isBuffer.mjs
function isBuffer(x) {
  return typeof Buffer !== "undefined" && Buffer.isBuffer(x);
}
var init_isBuffer = __esm({
  "node_modules/es-toolkit/dist/predicate/isBuffer.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/_internal/isPrototype.mjs
function isPrototype(value) {
  const constructor = value == null ? void 0 : value.constructor;
  const prototype = typeof constructor === "function" ? constructor.prototype : Object.prototype;
  return value === prototype;
}
var init_isPrototype = __esm({
  "node_modules/es-toolkit/dist/compat/_internal/isPrototype.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/predicate/isTypedArray.mjs
function isTypedArray2(x) {
  return isTypedArray(x);
}
var init_isTypedArray2 = __esm({
  "node_modules/es-toolkit/dist/compat/predicate/isTypedArray.mjs"() {
    init_isTypedArray();
  }
});

// node_modules/es-toolkit/dist/compat/util/times.mjs
function times(n, getValue) {
  n = toInteger(n);
  if (n < 1 || !Number.isSafeInteger(n)) {
    return [];
  }
  const result2 = new Array(n);
  for (let i = 0; i < n; i++) {
    result2[i] = typeof getValue === "function" ? getValue(i) : i;
  }
  return result2;
}
var init_times = __esm({
  "node_modules/es-toolkit/dist/compat/util/times.mjs"() {
    init_toInteger();
  }
});

// node_modules/es-toolkit/dist/compat/object/keys.mjs
function keys(object) {
  if (isArrayLike(object)) {
    return arrayLikeKeys(object);
  }
  const result2 = Object.keys(Object(object));
  if (!isPrototype(object)) {
    return result2;
  }
  return result2.filter((key) => key !== "constructor");
}
function arrayLikeKeys(object) {
  const indices = times(object.length, (index) => `${index}`);
  const filteredKeys = new Set(indices);
  if (isBuffer(object)) {
    filteredKeys.add("offset");
    filteredKeys.add("parent");
  }
  if (isTypedArray2(object)) {
    filteredKeys.add("buffer");
    filteredKeys.add("byteLength");
    filteredKeys.add("byteOffset");
  }
  return [...indices, ...Object.keys(object).filter((key) => !filteredKeys.has(key))];
}
var init_keys = __esm({
  "node_modules/es-toolkit/dist/compat/object/keys.mjs"() {
    init_isBuffer();
    init_isPrototype();
    init_isArrayLike();
    init_isTypedArray2();
    init_times();
  }
});

// node_modules/es-toolkit/dist/compat/object/assign.mjs
function assign(object, ...sources) {
  for (let i = 0; i < sources.length; i++) {
    assignImpl(object, sources[i]);
  }
  return object;
}
function assignImpl(object, source) {
  const keys$1 = keys(source);
  for (let i = 0; i < keys$1.length; i++) {
    const key = keys$1[i];
    if (!(key in object) || !eq(object[key], source[key])) {
      object[key] = source[key];
    }
  }
}
var init_assign = __esm({
  "node_modules/es-toolkit/dist/compat/object/assign.mjs"() {
    init_keys();
    init_eq();
  }
});

// node_modules/es-toolkit/dist/compat/object/keysIn.mjs
function keysIn(object) {
  if (object == null) {
    return [];
  }
  switch (typeof object) {
    case "object":
    case "function": {
      if (isArrayLike(object)) {
        return arrayLikeKeysIn(object);
      }
      if (isPrototype(object)) {
        return prototypeKeysIn(object);
      }
      return keysInImpl(object);
    }
    default: {
      return keysInImpl(Object(object));
    }
  }
}
function keysInImpl(object) {
  const result2 = [];
  for (const key in object) {
    result2.push(key);
  }
  return result2;
}
function prototypeKeysIn(object) {
  const keys2 = keysInImpl(object);
  return keys2.filter((key) => key !== "constructor");
}
function arrayLikeKeysIn(object) {
  const indices = times(object.length, (index) => `${index}`);
  const filteredKeys = new Set(indices);
  if (isBuffer(object)) {
    filteredKeys.add("offset");
    filteredKeys.add("parent");
  }
  if (isTypedArray2(object)) {
    filteredKeys.add("buffer");
    filteredKeys.add("byteLength");
    filteredKeys.add("byteOffset");
  }
  return [...indices, ...keysInImpl(object).filter((key) => !filteredKeys.has(key))];
}
var init_keysIn = __esm({
  "node_modules/es-toolkit/dist/compat/object/keysIn.mjs"() {
    init_isBuffer();
    init_isPrototype();
    init_isArrayLike();
    init_isTypedArray2();
    init_times();
  }
});

// node_modules/es-toolkit/dist/compat/object/assignIn.mjs
function assignIn(object, ...sources) {
  for (let i = 0; i < sources.length; i++) {
    assignInImpl(object, sources[i]);
  }
  return object;
}
function assignInImpl(object, source) {
  const keys2 = keysIn(source);
  for (let i = 0; i < keys2.length; i++) {
    const key = keys2[i];
    if (!(key in object) || !eq(object[key], source[key])) {
      object[key] = source[key];
    }
  }
}
var init_assignIn = __esm({
  "node_modules/es-toolkit/dist/compat/object/assignIn.mjs"() {
    init_keysIn();
    init_eq();
  }
});

// node_modules/es-toolkit/dist/compat/object/assignInWith.mjs
function assignInWith(object, ...sources) {
  let getValueToAssign = sources[sources.length - 1];
  if (typeof getValueToAssign === "function") {
    sources.pop();
  } else {
    getValueToAssign = void 0;
  }
  for (let i = 0; i < sources.length; i++) {
    assignInWithImpl(object, sources[i], getValueToAssign);
  }
  return object;
}
function assignInWithImpl(object, source, getValueToAssign) {
  const keys2 = keysIn(source);
  for (let i = 0; i < keys2.length; i++) {
    const key = keys2[i];
    const objValue = object[key];
    const srcValue = source[key];
    const newValue = (getValueToAssign == null ? void 0 : getValueToAssign(objValue, srcValue, key, object, source)) ?? srcValue;
    if (!(key in object) || !eq(objValue, newValue)) {
      object[key] = newValue;
    }
  }
}
var init_assignInWith = __esm({
  "node_modules/es-toolkit/dist/compat/object/assignInWith.mjs"() {
    init_keysIn();
    init_eq();
  }
});

// node_modules/es-toolkit/dist/compat/object/assignWith.mjs
function assignWith(object, ...sources) {
  let getValueToAssign = sources[sources.length - 1];
  if (typeof getValueToAssign === "function") {
    sources.pop();
  } else {
    getValueToAssign = void 0;
  }
  for (let i = 0; i < sources.length; i++) {
    assignWithImpl(object, sources[i], getValueToAssign);
  }
  return object;
}
function assignWithImpl(object, source, getValueToAssign) {
  const keys$1 = keys(source);
  for (let i = 0; i < keys$1.length; i++) {
    const key = keys$1[i];
    const objValue = object[key];
    const srcValue = source[key];
    const newValue = (getValueToAssign == null ? void 0 : getValueToAssign(objValue, srcValue, key, object, source)) ?? srcValue;
    if (!(key in object) || !eq(objValue, newValue)) {
      object[key] = newValue;
    }
  }
}
var init_assignWith = __esm({
  "node_modules/es-toolkit/dist/compat/object/assignWith.mjs"() {
    init_keys();
    init_eq();
  }
});

// node_modules/es-toolkit/dist/compat/object/clone.mjs
function clone(obj) {
  if (isPrimitive(obj)) {
    return obj;
  }
  const tag = getTag(obj);
  if (!isCloneableObject2(obj)) {
    return {};
  }
  if (isArray(obj)) {
    const result3 = Array.from(obj);
    if (obj.length > 0 && typeof obj[0] === "string" && Object.hasOwn(obj, "index")) {
      result3.index = obj.index;
      result3.input = obj.input;
    }
    return result3;
  }
  if (isTypedArray2(obj)) {
    const typedArray = obj;
    const Ctor = typedArray.constructor;
    return new Ctor(typedArray.buffer, typedArray.byteOffset, typedArray.length);
  }
  if (tag === arrayBufferTag) {
    return new ArrayBuffer(obj.byteLength);
  }
  if (tag === dataViewTag) {
    const dataView = obj;
    const buffer = dataView.buffer;
    const byteOffset = dataView.byteOffset;
    const byteLength = dataView.byteLength;
    const clonedBuffer = new ArrayBuffer(byteLength);
    const srcView = new Uint8Array(buffer, byteOffset, byteLength);
    const destView = new Uint8Array(clonedBuffer);
    destView.set(srcView);
    return new DataView(clonedBuffer);
  }
  if (tag === booleanTag || tag === numberTag || tag === stringTag) {
    const Ctor = obj.constructor;
    const clone3 = new Ctor(obj.valueOf());
    if (tag === stringTag) {
      cloneStringObjectProperties(clone3, obj);
    } else {
      copyOwnProperties(clone3, obj);
    }
    return clone3;
  }
  if (tag === dateTag) {
    return new Date(Number(obj));
  }
  if (tag === regexpTag) {
    const regExp = obj;
    const clone3 = new RegExp(regExp.source, regExp.flags);
    clone3.lastIndex = regExp.lastIndex;
    return clone3;
  }
  if (tag === symbolTag) {
    return Object(Symbol.prototype.valueOf.call(obj));
  }
  if (tag === mapTag) {
    const map2 = obj;
    const result3 = /* @__PURE__ */ new Map();
    map2.forEach((obj2, key) => {
      result3.set(key, obj2);
    });
    return result3;
  }
  if (tag === setTag) {
    const set2 = obj;
    const result3 = /* @__PURE__ */ new Set();
    set2.forEach((obj2) => {
      result3.add(obj2);
    });
    return result3;
  }
  if (tag === argumentsTag) {
    const args = obj;
    const result3 = {};
    copyOwnProperties(result3, args);
    result3.length = args.length;
    result3[Symbol.iterator] = args[Symbol.iterator];
    return result3;
  }
  const result2 = {};
  copyPrototype(result2, obj);
  copyOwnProperties(result2, obj);
  copySymbolProperties(result2, obj);
  return result2;
}
function isCloneableObject2(object) {
  switch (getTag(object)) {
    case argumentsTag:
    case arrayTag:
    case arrayBufferTag:
    case dataViewTag:
    case booleanTag:
    case dateTag:
    case float32ArrayTag:
    case float64ArrayTag:
    case int8ArrayTag:
    case int16ArrayTag:
    case int32ArrayTag:
    case mapTag:
    case numberTag:
    case objectTag:
    case regexpTag:
    case setTag:
    case stringTag:
    case symbolTag:
    case uint8ArrayTag:
    case uint8ClampedArrayTag:
    case uint16ArrayTag:
    case uint32ArrayTag: {
      return true;
    }
    default: {
      return false;
    }
  }
}
function copyOwnProperties(target, source) {
  for (const key in source) {
    if (Object.hasOwn(source, key)) {
      target[key] = source[key];
    }
  }
}
function copySymbolProperties(target, source) {
  const symbols = Object.getOwnPropertySymbols(source);
  for (let i = 0; i < symbols.length; i++) {
    const symbol = symbols[i];
    if (Object.prototype.propertyIsEnumerable.call(source, symbol)) {
      target[symbol] = source[symbol];
    }
  }
}
function cloneStringObjectProperties(target, source) {
  const stringLength = source.valueOf().length;
  for (const key in source) {
    if (Object.hasOwn(source, key) && (Number.isNaN(Number(key)) || Number(key) >= stringLength)) {
      target[key] = source[key];
    }
  }
}
function copyPrototype(target, source) {
  const proto = Object.getPrototypeOf(source);
  if (proto !== null) {
    const Ctor = source.constructor;
    if (typeof Ctor === "function") {
      Object.setPrototypeOf(target, proto);
    }
  }
}
var init_clone = __esm({
  "node_modules/es-toolkit/dist/compat/object/clone.mjs"() {
    init_isPrimitive();
    init_getTag();
    init_tags();
    init_isArray();
    init_isTypedArray2();
  }
});

// node_modules/es-toolkit/dist/compat/object/cloneWith.mjs
function cloneWith(value, customizer) {
  if (!customizer) {
    return clone(value);
  }
  const result2 = customizer(value);
  if (result2 !== void 0) {
    return result2;
  }
  return clone(value);
}
var init_cloneWith = __esm({
  "node_modules/es-toolkit/dist/compat/object/cloneWith.mjs"() {
    init_clone();
  }
});

// node_modules/es-toolkit/dist/compat/object/create.mjs
function create(prototype, properties) {
  const proto = isObject(prototype) ? Object.create(prototype) : {};
  if (properties != null) {
    const propsKeys = keys(properties);
    for (let i = 0; i < propsKeys.length; i++) {
      const key = propsKeys[i];
      const propsValue = properties[key];
      assignValue(proto, key, propsValue);
    }
  }
  return proto;
}
var init_create = __esm({
  "node_modules/es-toolkit/dist/compat/object/create.mjs"() {
    init_keys();
    init_assignValue();
    init_isObject();
  }
});

// node_modules/es-toolkit/dist/compat/object/defaults.mjs
function defaults(object, ...sources) {
  object = Object(object);
  const objectProto = Object.prototype;
  let length = sources.length;
  const guard = length > 2 ? sources[2] : void 0;
  if (guard && isIterateeCall(sources[0], sources[1], guard)) {
    length = 1;
  }
  for (let i = 0; i < length; i++) {
    const source = sources[i];
    const keys2 = Object.keys(source);
    for (let j = 0; j < keys2.length; j++) {
      const key = keys2[j];
      const value = object[key];
      if (value === void 0 || !Object.hasOwn(object, key) && eq(value, objectProto[key])) {
        object[key] = source[key];
      }
    }
  }
  return object;
}
var init_defaults = __esm({
  "node_modules/es-toolkit/dist/compat/object/defaults.mjs"() {
    init_isIterateeCall();
    init_eq();
  }
});

// node_modules/es-toolkit/dist/compat/predicate/isPlainObject.mjs
function isPlainObject2(object) {
  var _a;
  if (typeof object !== "object") {
    return false;
  }
  if (object == null) {
    return false;
  }
  if (Object.getPrototypeOf(object) === null) {
    return true;
  }
  if (Object.prototype.toString.call(object) !== "[object Object]") {
    const tag = object[Symbol.toStringTag];
    if (tag == null) {
      return false;
    }
    const isTagReadonly = !((_a = Object.getOwnPropertyDescriptor(object, Symbol.toStringTag)) == null ? void 0 : _a.writable);
    if (isTagReadonly) {
      return false;
    }
    return object.toString() === `[object ${tag}]`;
  }
  let proto = object;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(object) === proto;
}
var init_isPlainObject2 = __esm({
  "node_modules/es-toolkit/dist/compat/predicate/isPlainObject.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/object/defaultsDeep.mjs
function defaultsDeep(target, ...sources) {
  target = Object(target);
  for (let i = 0; i < sources.length; i++) {
    const source = sources[i];
    if (source != null) {
      const stack = /* @__PURE__ */ new WeakMap();
      defaultsDeepRecursive(target, source, stack);
    }
  }
  return target;
}
function defaultsDeepRecursive(target, source, stack) {
  for (const key in source) {
    const sourceValue = source[key];
    const targetValue = target[key];
    const targetHasKey = Object.hasOwn(target, key);
    if (!targetHasKey || targetValue === void 0) {
      if (stack.has(sourceValue)) {
        target[key] = stack.get(sourceValue);
      } else if (isPlainObject2(sourceValue)) {
        const newObj = {};
        stack.set(sourceValue, newObj);
        target[key] = newObj;
        defaultsDeepRecursive(newObj, sourceValue, stack);
      } else {
        target[key] = sourceValue;
      }
    } else if (isPlainObject2(targetValue) && isPlainObject2(sourceValue)) {
      const inStack = stack.has(sourceValue);
      if (!inStack || inStack && stack.get(sourceValue) !== targetValue) {
        stack.set(sourceValue, targetValue);
        defaultsDeepRecursive(targetValue, sourceValue, stack);
      }
    }
  }
}
var init_defaultsDeep = __esm({
  "node_modules/es-toolkit/dist/compat/object/defaultsDeep.mjs"() {
    init_isPlainObject2();
  }
});

// node_modules/es-toolkit/dist/object/findKey.mjs
function findKey(obj, predicate) {
  const keys2 = Object.keys(obj);
  return keys2.find((key) => predicate(obj[key], key, obj));
}
var init_findKey = __esm({
  "node_modules/es-toolkit/dist/object/findKey.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/object/findKey.mjs
function findKey2(obj, predicate) {
  if (!isObject(obj)) {
    return void 0;
  }
  const iteratee$1 = iteratee(predicate ?? identity2);
  return findKey(obj, iteratee$1);
}
var init_findKey2 = __esm({
  "node_modules/es-toolkit/dist/compat/object/findKey.mjs"() {
    init_findKey();
    init_identity2();
    init_isObject();
    init_iteratee();
  }
});

// node_modules/es-toolkit/dist/compat/object/findLastKey.mjs
function findLastKey(obj, predicate) {
  if (!isObject(obj)) {
    return void 0;
  }
  const iteratee$1 = iteratee(predicate ?? identity2);
  const keys2 = Object.keys(obj);
  return keys2.findLast((key) => iteratee$1(obj[key], key, obj));
}
var init_findLastKey = __esm({
  "node_modules/es-toolkit/dist/compat/object/findLastKey.mjs"() {
    init_identity2();
    init_isObject();
    init_iteratee();
  }
});

// node_modules/es-toolkit/dist/compat/object/forIn.mjs
function forIn(object, iteratee2 = identity) {
  if (object == null) {
    return object;
  }
  for (const key in object) {
    const result2 = iteratee2(object[key], key, object);
    if (result2 === false) {
      break;
    }
  }
  return object;
}
var init_forIn = __esm({
  "node_modules/es-toolkit/dist/compat/object/forIn.mjs"() {
    init_identity();
  }
});

// node_modules/es-toolkit/dist/compat/object/forInRight.mjs
function forInRight(object, iteratee2 = identity) {
  if (object == null) {
    return object;
  }
  const keys2 = [];
  for (const key in object) {
    keys2.push(key);
  }
  for (let i = keys2.length - 1; i >= 0; i--) {
    const key = keys2[i];
    const result2 = iteratee2(object[key], key, object);
    if (result2 === false) {
      break;
    }
  }
  return object;
}
var init_forInRight = __esm({
  "node_modules/es-toolkit/dist/compat/object/forInRight.mjs"() {
    init_identity();
  }
});

// node_modules/es-toolkit/dist/compat/object/forOwn.mjs
function forOwn(object, iteratee2 = identity) {
  if (object == null) {
    return object;
  }
  const iterable = Object(object);
  const keys$1 = keys(object);
  for (let i = 0; i < keys$1.length; ++i) {
    const key = keys$1[i];
    if (iteratee2(iterable[key], key, iterable) === false) {
      break;
    }
  }
  return object;
}
var init_forOwn = __esm({
  "node_modules/es-toolkit/dist/compat/object/forOwn.mjs"() {
    init_keys();
    init_identity();
  }
});

// node_modules/es-toolkit/dist/compat/object/forOwnRight.mjs
function forOwnRight(object, iteratee2 = identity) {
  if (object == null) {
    return object;
  }
  const iterable = Object(object);
  const keys$1 = keys(object);
  for (let i = keys$1.length - 1; i >= 0; --i) {
    const key = keys$1[i];
    if (iteratee2(iterable[key], key, iterable) === false) {
      break;
    }
  }
  return object;
}
var init_forOwnRight = __esm({
  "node_modules/es-toolkit/dist/compat/object/forOwnRight.mjs"() {
    init_keys();
    init_identity();
  }
});

// node_modules/es-toolkit/dist/compat/object/fromPairs.mjs
function fromPairs(pairs) {
  if (!isArrayLike(pairs)) {
    return {};
  }
  const result2 = {};
  for (let i = 0; i < pairs.length; i++) {
    const [key, value] = pairs[i];
    result2[key] = value;
  }
  return result2;
}
var init_fromPairs = __esm({
  "node_modules/es-toolkit/dist/compat/object/fromPairs.mjs"() {
    init_isArrayLike();
  }
});

// node_modules/es-toolkit/dist/compat/object/functions.mjs
function functions(object) {
  if (object == null) {
    return [];
  }
  return keys(object).filter((key) => typeof object[key] === "function");
}
var init_functions = __esm({
  "node_modules/es-toolkit/dist/compat/object/functions.mjs"() {
    init_keys();
  }
});

// node_modules/es-toolkit/dist/compat/object/functionsIn.mjs
function functionsIn(object) {
  if (object == null) {
    return [];
  }
  const result2 = [];
  for (const key in object) {
    if (isFunction(object[key])) {
      result2.push(key);
    }
  }
  return result2;
}
var init_functionsIn = __esm({
  "node_modules/es-toolkit/dist/compat/object/functionsIn.mjs"() {
    init_isFunction();
  }
});

// node_modules/es-toolkit/dist/compat/object/hasIn.mjs
function hasIn(object, path) {
  if (object == null) {
    return false;
  }
  let resolvedPath;
  if (Array.isArray(path)) {
    resolvedPath = path;
  } else if (typeof path === "string" && isDeepKey(path) && object[path] == null) {
    resolvedPath = toPath(path);
  } else {
    resolvedPath = [path];
  }
  if (resolvedPath.length === 0) {
    return false;
  }
  let current = object;
  for (let i = 0; i < resolvedPath.length; i++) {
    const key = resolvedPath[i];
    if (current == null || !(key in Object(current))) {
      const isSparseIndex = (Array.isArray(current) || isArguments(current)) && isIndex(key) && key < current.length;
      if (!isSparseIndex) {
        return false;
      }
    }
    current = current[key];
  }
  return true;
}
var init_hasIn = __esm({
  "node_modules/es-toolkit/dist/compat/object/hasIn.mjs"() {
    init_isDeepKey();
    init_isIndex();
    init_isArguments();
    init_toPath();
  }
});

// node_modules/es-toolkit/dist/object/invert.mjs
function invert(obj) {
  const result2 = {};
  const keys2 = Object.keys(obj);
  for (let i = 0; i < keys2.length; i++) {
    const key = keys2[i];
    const value = obj[key];
    result2[value] = key;
  }
  return result2;
}
var init_invert = __esm({
  "node_modules/es-toolkit/dist/object/invert.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/object/invert.mjs
function invert2(obj) {
  return invert(obj);
}
var init_invert2 = __esm({
  "node_modules/es-toolkit/dist/compat/object/invert.mjs"() {
    init_invert();
  }
});

// node_modules/es-toolkit/dist/compat/object/invertBy.mjs
function invertBy(object, iteratee$1) {
  const result2 = {};
  if (isNil(object)) {
    return result2;
  }
  if (iteratee$1 == null) {
    iteratee$1 = identity;
  }
  const keys2 = Object.keys(object);
  const getString = iteratee(iteratee$1);
  for (let i = 0; i < keys2.length; i++) {
    const key = keys2[i];
    const value = object[key];
    const valueStr = getString(value);
    if (Array.isArray(result2[valueStr])) {
      result2[valueStr].push(key);
    } else {
      result2[valueStr] = [key];
    }
  }
  return result2;
}
var init_invertBy = __esm({
  "node_modules/es-toolkit/dist/compat/object/invertBy.mjs"() {
    init_identity();
    init_isNil();
    init_iteratee();
  }
});

// node_modules/es-toolkit/dist/object/mapKeys.mjs
function mapKeys(object, getNewKey) {
  const result2 = {};
  const keys2 = Object.keys(object);
  for (let i = 0; i < keys2.length; i++) {
    const key = keys2[i];
    const value = object[key];
    result2[getNewKey(value, key, object)] = value;
  }
  return result2;
}
var init_mapKeys = __esm({
  "node_modules/es-toolkit/dist/object/mapKeys.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/object/mapKeys.mjs
function mapKeys2(object, getNewKey = identity) {
  if (object == null) {
    return {};
  }
  return mapKeys(object, iteratee(getNewKey));
}
var init_mapKeys2 = __esm({
  "node_modules/es-toolkit/dist/compat/object/mapKeys.mjs"() {
    init_identity();
    init_mapKeys();
    init_iteratee();
  }
});

// node_modules/es-toolkit/dist/object/mapValues.mjs
function mapValues(object, getNewValue) {
  const result2 = {};
  const keys2 = Object.keys(object);
  for (let i = 0; i < keys2.length; i++) {
    const key = keys2[i];
    const value = object[key];
    result2[key] = getNewValue(value, key, object);
  }
  return result2;
}
var init_mapValues = __esm({
  "node_modules/es-toolkit/dist/object/mapValues.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/object/mapValues.mjs
function mapValues2(object, getNewValue = identity) {
  if (object == null) {
    return {};
  }
  return mapValues(object, iteratee(getNewValue));
}
var init_mapValues2 = __esm({
  "node_modules/es-toolkit/dist/compat/object/mapValues.mjs"() {
    init_identity();
    init_mapValues();
    init_iteratee();
  }
});

// node_modules/es-toolkit/dist/object/clone.mjs
function clone2(obj) {
  if (isPrimitive(obj)) {
    return obj;
  }
  if (Array.isArray(obj) || isTypedArray(obj) || obj instanceof ArrayBuffer || typeof SharedArrayBuffer !== "undefined" && obj instanceof SharedArrayBuffer) {
    return obj.slice(0);
  }
  const prototype = Object.getPrototypeOf(obj);
  const Constructor = prototype.constructor;
  if (obj instanceof Date || obj instanceof Map || obj instanceof Set) {
    return new Constructor(obj);
  }
  if (obj instanceof RegExp) {
    const newRegExp = new Constructor(obj);
    newRegExp.lastIndex = obj.lastIndex;
    return newRegExp;
  }
  if (obj instanceof DataView) {
    return new Constructor(obj.buffer.slice(0));
  }
  if (obj instanceof Error) {
    const newError = new Constructor(obj.message);
    newError.stack = obj.stack;
    newError.name = obj.name;
    newError.cause = obj.cause;
    return newError;
  }
  if (typeof File !== "undefined" && obj instanceof File) {
    const newFile = new Constructor([obj], obj.name, { type: obj.type, lastModified: obj.lastModified });
    return newFile;
  }
  if (typeof obj === "object") {
    const newObject = Object.create(prototype);
    return Object.assign(newObject, obj);
  }
  return obj;
}
var init_clone2 = __esm({
  "node_modules/es-toolkit/dist/object/clone.mjs"() {
    init_isPrimitive();
    init_isTypedArray();
  }
});

// node_modules/es-toolkit/dist/compat/object/mergeWith.mjs
function mergeWith(object, ...otherArgs) {
  const sources = otherArgs.slice(0, -1);
  const merge2 = otherArgs[otherArgs.length - 1];
  let result2 = object;
  for (let i = 0; i < sources.length; i++) {
    const source = sources[i];
    result2 = mergeWithDeep(result2, source, merge2, /* @__PURE__ */ new Map());
  }
  return result2;
}
function mergeWithDeep(target, source, merge2, stack) {
  if (isPrimitive(target)) {
    target = Object(target);
  }
  if (source == null || typeof source !== "object") {
    return target;
  }
  if (stack.has(source)) {
    return clone2(stack.get(source));
  }
  stack.set(source, target);
  if (Array.isArray(source)) {
    source = source.slice();
    for (let i = 0; i < source.length; i++) {
      source[i] = source[i] ?? void 0;
    }
  }
  const sourceKeys = [...Object.keys(source), ...getSymbols(source)];
  for (let i = 0; i < sourceKeys.length; i++) {
    const key = sourceKeys[i];
    if (isUnsafeProperty(key)) {
      continue;
    }
    let sourceValue = source[key];
    let targetValue = target[key];
    if (isArguments(sourceValue)) {
      sourceValue = { ...sourceValue };
    }
    if (isArguments(targetValue)) {
      targetValue = { ...targetValue };
    }
    if (typeof Buffer !== "undefined" && Buffer.isBuffer(sourceValue)) {
      sourceValue = cloneDeep2(sourceValue);
    }
    if (Array.isArray(sourceValue)) {
      if (typeof targetValue === "object" && targetValue != null) {
        const cloned = [];
        const targetKeys = Reflect.ownKeys(targetValue);
        for (let i2 = 0; i2 < targetKeys.length; i2++) {
          const targetKey = targetKeys[i2];
          cloned[targetKey] = targetValue[targetKey];
        }
        targetValue = cloned;
      } else {
        targetValue = [];
      }
    }
    const merged = merge2(targetValue, sourceValue, key, target, source, stack);
    if (merged != null) {
      target[key] = merged;
    } else if (Array.isArray(sourceValue)) {
      target[key] = mergeWithDeep(targetValue, sourceValue, merge2, stack);
    } else if (isObjectLike(targetValue) && isObjectLike(sourceValue)) {
      target[key] = mergeWithDeep(targetValue, sourceValue, merge2, stack);
    } else if (targetValue == null && isPlainObject2(sourceValue)) {
      target[key] = mergeWithDeep({}, sourceValue, merge2, stack);
    } else if (targetValue == null && isTypedArray2(sourceValue)) {
      target[key] = cloneDeep2(sourceValue);
    } else if (targetValue === void 0 || sourceValue !== void 0) {
      target[key] = sourceValue;
    }
  }
  return target;
}
var init_mergeWith = __esm({
  "node_modules/es-toolkit/dist/compat/object/mergeWith.mjs"() {
    init_cloneDeep2();
    init_isUnsafeProperty();
    init_clone2();
    init_isPrimitive();
    init_getSymbols();
    init_isArguments();
    init_isObjectLike();
    init_isPlainObject2();
    init_isTypedArray2();
  }
});

// node_modules/es-toolkit/dist/compat/object/merge.mjs
function merge(object, ...sources) {
  return mergeWith(object, ...sources, noop);
}
var init_merge = __esm({
  "node_modules/es-toolkit/dist/compat/object/merge.mjs"() {
    init_mergeWith();
    init_noop();
  }
});

// node_modules/es-toolkit/dist/compat/object/omit.mjs
function omit(obj, ...keysArr) {
  if (obj == null) {
    return {};
  }
  const result2 = cloneDeep(obj);
  for (let i = 0; i < keysArr.length; i++) {
    let keys2 = keysArr[i];
    switch (typeof keys2) {
      case "object": {
        if (!Array.isArray(keys2)) {
          keys2 = Array.from(keys2);
        }
        for (let j = 0; j < keys2.length; j++) {
          const key = keys2[j];
          unset(result2, key);
        }
        break;
      }
      case "string":
      case "symbol":
      case "number": {
        unset(result2, keys2);
        break;
      }
    }
  }
  return result2;
}
var init_omit = __esm({
  "node_modules/es-toolkit/dist/compat/object/omit.mjs"() {
    init_unset();
    init_cloneDeep();
  }
});

// node_modules/es-toolkit/dist/compat/_internal/getSymbolsIn.mjs
function getSymbolsIn(object) {
  const result2 = [];
  while (object) {
    result2.push(...getSymbols(object));
    object = Object.getPrototypeOf(object);
  }
  return result2;
}
var init_getSymbolsIn = __esm({
  "node_modules/es-toolkit/dist/compat/_internal/getSymbolsIn.mjs"() {
    init_getSymbols();
  }
});

// node_modules/es-toolkit/dist/compat/object/omitBy.mjs
function omitBy(object, shouldOmit) {
  if (object == null) {
    return {};
  }
  const result2 = {};
  const predicate = iteratee(shouldOmit ?? identity2);
  const keys2 = isArrayLike(object) ? range(0, object.length) : [...keysIn(object), ...getSymbolsIn(object)];
  for (let i = 0; i < keys2.length; i++) {
    const key = isSymbol(keys2[i]) ? keys2[i] : keys2[i].toString();
    const value = object[key];
    if (!predicate(value, key, object)) {
      result2[key] = value;
    }
  }
  return result2;
}
var init_omitBy = __esm({
  "node_modules/es-toolkit/dist/compat/object/omitBy.mjs"() {
    init_keysIn();
    init_range();
    init_getSymbolsIn();
    init_identity2();
    init_isArrayLike();
    init_isSymbol();
    init_iteratee();
  }
});

// node_modules/es-toolkit/dist/compat/object/pick.mjs
function pick(obj, ...keysArr) {
  if (isNil2(obj)) {
    return {};
  }
  const result2 = {};
  for (let i = 0; i < keysArr.length; i++) {
    let keys2 = keysArr[i];
    switch (typeof keys2) {
      case "object": {
        if (!Array.isArray(keys2)) {
          if (isArrayLike(keys2)) {
            keys2 = Array.from(keys2);
          } else {
            keys2 = [keys2];
          }
        }
        break;
      }
      case "string":
      case "symbol":
      case "number": {
        keys2 = [keys2];
        break;
      }
    }
    for (const key of keys2) {
      const value = get(obj, key);
      if (value === void 0 && !has(obj, key)) {
        continue;
      }
      if (typeof key === "string" && Object.hasOwn(obj, key)) {
        result2[key] = value;
      } else {
        set(result2, key, value);
      }
    }
  }
  return result2;
}
var init_pick = __esm({
  "node_modules/es-toolkit/dist/compat/object/pick.mjs"() {
    init_get();
    init_has();
    init_set();
    init_isArrayLike();
    init_isNil2();
  }
});

// node_modules/es-toolkit/dist/compat/object/pickBy.mjs
function pickBy(obj, shouldPick) {
  if (obj == null) {
    return {};
  }
  const predicate = iteratee(shouldPick ?? identity2);
  const result2 = {};
  const keys2 = isArrayLike(obj) ? range(0, obj.length) : [...keysIn(obj), ...getSymbolsIn(obj)];
  for (let i = 0; i < keys2.length; i++) {
    const key = isSymbol(keys2[i]) ? keys2[i] : keys2[i].toString();
    const value = obj[key];
    if (predicate(value, key, obj)) {
      result2[key] = value;
    }
  }
  return result2;
}
var init_pickBy = __esm({
  "node_modules/es-toolkit/dist/compat/object/pickBy.mjs"() {
    init_keysIn();
    init_range();
    init_getSymbolsIn();
    init_identity2();
    init_isArrayLike();
    init_isSymbol();
    init_iteratee();
  }
});

// node_modules/es-toolkit/dist/compat/object/propertyOf.mjs
function propertyOf(object) {
  return function(path) {
    return get(object, path);
  };
}
var init_propertyOf = __esm({
  "node_modules/es-toolkit/dist/compat/object/propertyOf.mjs"() {
    init_get();
  }
});

// node_modules/es-toolkit/dist/compat/object/result.mjs
function result(object, path, defaultValue) {
  if (isKey(path, object)) {
    path = [path];
  } else if (!Array.isArray(path)) {
    path = toPath(toString(path));
  }
  const pathLength = Math.max(path.length, 1);
  for (let index = 0; index < pathLength; index++) {
    const value = object == null ? void 0 : object[toKey(path[index])];
    if (value === void 0) {
      return typeof defaultValue === "function" ? defaultValue.call(object) : defaultValue;
    }
    object = typeof value === "function" ? value.call(object) : value;
  }
  return object;
}
var init_result = __esm({
  "node_modules/es-toolkit/dist/compat/object/result.mjs"() {
    init_isKey();
    init_toKey();
    init_toPath();
    init_toString();
  }
});

// node_modules/es-toolkit/dist/compat/object/setWith.mjs
function setWith(obj, path, value, customizer) {
  let customizerFn;
  if (typeof customizer === "function") {
    customizerFn = customizer;
  } else {
    customizerFn = () => void 0;
  }
  return updateWith(obj, path, () => value, customizerFn);
}
var init_setWith = __esm({
  "node_modules/es-toolkit/dist/compat/object/setWith.mjs"() {
    init_updateWith();
  }
});

// node_modules/es-toolkit/dist/compat/object/toDefaulted.mjs
function toDefaulted(object, ...sources) {
  const cloned = cloneDeep2(object);
  return defaults(cloned, ...sources);
}
var init_toDefaulted = __esm({
  "node_modules/es-toolkit/dist/compat/object/toDefaulted.mjs"() {
    init_cloneDeep2();
    init_defaults();
  }
});

// node_modules/es-toolkit/dist/compat/_internal/mapToEntries.mjs
function mapToEntries(map2) {
  const arr = new Array(map2.size);
  const keys2 = map2.keys();
  const values2 = map2.values();
  for (let i = 0; i < arr.length; i++) {
    arr[i] = [keys2.next().value, values2.next().value];
  }
  return arr;
}
var init_mapToEntries = __esm({
  "node_modules/es-toolkit/dist/compat/_internal/mapToEntries.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/_internal/setToEntries.mjs
function setToEntries(set2) {
  const arr = new Array(set2.size);
  const values2 = set2.values();
  for (let i = 0; i < arr.length; i++) {
    const value = values2.next().value;
    arr[i] = [value, value];
  }
  return arr;
}
var init_setToEntries = __esm({
  "node_modules/es-toolkit/dist/compat/_internal/setToEntries.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/object/toPairs.mjs
function toPairs(object) {
  if (object == null) {
    return [];
  }
  if (object instanceof Set) {
    return setToEntries(object);
  }
  if (object instanceof Map) {
    return mapToEntries(object);
  }
  const keys$1 = keys(object);
  const result2 = new Array(keys$1.length);
  for (let i = 0; i < keys$1.length; i++) {
    const key = keys$1[i];
    const value = object[key];
    result2[i] = [key, value];
  }
  return result2;
}
var init_toPairs = __esm({
  "node_modules/es-toolkit/dist/compat/object/toPairs.mjs"() {
    init_keys();
    init_mapToEntries();
    init_setToEntries();
  }
});

// node_modules/es-toolkit/dist/compat/object/toPairsIn.mjs
function toPairsIn(object) {
  if (object == null) {
    return [];
  }
  if (object instanceof Set) {
    return setToEntries(object);
  }
  if (object instanceof Map) {
    return mapToEntries(object);
  }
  const keys2 = keysIn(object);
  const result2 = new Array(keys2.length);
  for (let i = 0; i < keys2.length; i++) {
    const key = keys2[i];
    const value = object[key];
    result2[i] = [key, value];
  }
  return result2;
}
var init_toPairsIn = __esm({
  "node_modules/es-toolkit/dist/compat/object/toPairsIn.mjs"() {
    init_keysIn();
    init_mapToEntries();
    init_setToEntries();
  }
});

// node_modules/es-toolkit/dist/compat/predicate/isBuffer.mjs
function isBuffer2(x) {
  return isBuffer(x);
}
var init_isBuffer2 = __esm({
  "node_modules/es-toolkit/dist/compat/predicate/isBuffer.mjs"() {
    init_isBuffer();
  }
});

// node_modules/es-toolkit/dist/compat/object/transform.mjs
function transform(object, iteratee$1 = identity, accumulator) {
  const isArrayOrBufferOrTypedArray = Array.isArray(object) || isBuffer2(object) || isTypedArray2(object);
  iteratee$1 = iteratee(iteratee$1);
  if (accumulator == null) {
    if (isArrayOrBufferOrTypedArray) {
      accumulator = [];
    } else if (isObject(object) && isFunction(object.constructor)) {
      accumulator = Object.create(Object.getPrototypeOf(object));
    } else {
      accumulator = {};
    }
  }
  if (object == null) {
    return accumulator;
  }
  forEach(object, (value, key, object2) => iteratee$1(accumulator, value, key, object2));
  return accumulator;
}
var init_transform = __esm({
  "node_modules/es-toolkit/dist/compat/object/transform.mjs"() {
    init_identity();
    init_isFunction();
    init_forEach();
    init_isBuffer2();
    init_isObject();
    init_isTypedArray2();
    init_iteratee();
  }
});

// node_modules/es-toolkit/dist/compat/object/update.mjs
function update(obj, path, updater) {
  return updateWith(obj, path, updater, () => void 0);
}
var init_update = __esm({
  "node_modules/es-toolkit/dist/compat/object/update.mjs"() {
    init_updateWith();
  }
});

// node_modules/es-toolkit/dist/compat/object/valuesIn.mjs
function valuesIn(object) {
  const keys2 = keysIn(object);
  const result2 = new Array(keys2.length);
  for (let i = 0; i < keys2.length; i++) {
    const key = keys2[i];
    result2[i] = object[key];
  }
  return result2;
}
var init_valuesIn = __esm({
  "node_modules/es-toolkit/dist/compat/object/valuesIn.mjs"() {
    init_keysIn();
  }
});

// node_modules/es-toolkit/dist/compat/predicate/isFunction.mjs
function isFunction2(value) {
  return typeof value === "function";
}
var init_isFunction2 = __esm({
  "node_modules/es-toolkit/dist/compat/predicate/isFunction.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/predicate/isLength.mjs
function isLength2(value) {
  return Number.isSafeInteger(value) && value >= 0;
}
var init_isLength2 = __esm({
  "node_modules/es-toolkit/dist/compat/predicate/isLength.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/predicate/isNative.mjs
function isNative(value) {
  if (typeof value !== "function") {
    return false;
  }
  if ((globalThis == null ? void 0 : globalThis["__core-js_shared__"]) != null) {
    throw new Error("Unsupported core-js use. Try https://npms.io/search?q=ponyfill.");
  }
  return IS_NATIVE_FUNCTION_REGEXP.test(functionToString.call(value));
}
var functionToString, REGEXP_SYNTAX_CHARS, IS_NATIVE_FUNCTION_REGEXP;
var init_isNative = __esm({
  "node_modules/es-toolkit/dist/compat/predicate/isNative.mjs"() {
    functionToString = Function.prototype.toString;
    REGEXP_SYNTAX_CHARS = /[\\^$.*+?()[\]{}|]/g;
    IS_NATIVE_FUNCTION_REGEXP = RegExp(`^${functionToString.call(Object.prototype.hasOwnProperty).replace(REGEXP_SYNTAX_CHARS, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?")}$`);
  }
});

// node_modules/es-toolkit/dist/compat/predicate/isNull.mjs
function isNull2(value) {
  return value === null;
}
var init_isNull2 = __esm({
  "node_modules/es-toolkit/dist/compat/predicate/isNull.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/predicate/isUndefined.mjs
function isUndefined2(x) {
  return isUndefined(x);
}
var init_isUndefined2 = __esm({
  "node_modules/es-toolkit/dist/compat/predicate/isUndefined.mjs"() {
    init_isUndefined();
  }
});

// node_modules/es-toolkit/dist/compat/predicate/conformsTo.mjs
function conformsTo(target, source) {
  if (source == null) {
    return true;
  }
  if (target == null) {
    return Object.keys(source).length === 0;
  }
  const keys2 = Object.keys(source);
  for (let i = 0; i < keys2.length; i++) {
    const key = keys2[i];
    const predicate = source[key];
    const value = target[key];
    if (value === void 0 && !(key in target)) {
      return false;
    }
    if (typeof predicate === "function" && !predicate(value)) {
      return false;
    }
  }
  return true;
}
var init_conformsTo = __esm({
  "node_modules/es-toolkit/dist/compat/predicate/conformsTo.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/predicate/conforms.mjs
function conforms(source) {
  source = cloneDeep(source);
  return function(object) {
    return conformsTo(object, source);
  };
}
var init_conforms = __esm({
  "node_modules/es-toolkit/dist/compat/predicate/conforms.mjs"() {
    init_conformsTo();
    init_cloneDeep();
  }
});

// node_modules/es-toolkit/dist/predicate/isArrayBuffer.mjs
function isArrayBuffer(value) {
  return value instanceof ArrayBuffer;
}
var init_isArrayBuffer = __esm({
  "node_modules/es-toolkit/dist/predicate/isArrayBuffer.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/predicate/isArrayBuffer.mjs
function isArrayBuffer2(value) {
  return isArrayBuffer(value);
}
var init_isArrayBuffer2 = __esm({
  "node_modules/es-toolkit/dist/compat/predicate/isArrayBuffer.mjs"() {
    init_isArrayBuffer();
  }
});

// node_modules/es-toolkit/dist/compat/predicate/isBoolean.mjs
function isBoolean(value) {
  return typeof value === "boolean" || value instanceof Boolean;
}
var init_isBoolean = __esm({
  "node_modules/es-toolkit/dist/compat/predicate/isBoolean.mjs"() {
  }
});

// node_modules/es-toolkit/dist/predicate/isDate.mjs
function isDate(value) {
  return value instanceof Date;
}
var init_isDate = __esm({
  "node_modules/es-toolkit/dist/predicate/isDate.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/predicate/isDate.mjs
function isDate2(value) {
  return isDate(value);
}
var init_isDate2 = __esm({
  "node_modules/es-toolkit/dist/compat/predicate/isDate.mjs"() {
    init_isDate();
  }
});

// node_modules/es-toolkit/dist/compat/predicate/isElement.mjs
function isElement(value) {
  return isObjectLike(value) && value.nodeType === 1 && !isPlainObject2(value);
}
var init_isElement = __esm({
  "node_modules/es-toolkit/dist/compat/predicate/isElement.mjs"() {
    init_isObjectLike();
    init_isPlainObject2();
  }
});

// node_modules/es-toolkit/dist/compat/predicate/isEmpty.mjs
function isEmpty(value) {
  if (value == null) {
    return true;
  }
  if (isArrayLike(value)) {
    if (typeof value.splice !== "function" && typeof value !== "string" && (typeof Buffer === "undefined" || !Buffer.isBuffer(value)) && !isTypedArray2(value) && !isArguments(value)) {
      return false;
    }
    return value.length === 0;
  }
  if (typeof value === "object") {
    if (value instanceof Map || value instanceof Set) {
      return value.size === 0;
    }
    const keys2 = Object.keys(value);
    if (isPrototype(value)) {
      return keys2.filter((x) => x !== "constructor").length === 0;
    }
    return keys2.length === 0;
  }
  return true;
}
var init_isEmpty = __esm({
  "node_modules/es-toolkit/dist/compat/predicate/isEmpty.mjs"() {
    init_isArguments();
    init_isArrayLike();
    init_isTypedArray2();
    init_isPrototype();
  }
});

// node_modules/es-toolkit/dist/function/after.mjs
function after2(n, func) {
  if (!Number.isInteger(n) || n < 0) {
    throw new Error(`n must be a non-negative integer.`);
  }
  let counter = 0;
  return (...args) => {
    if (++counter >= n) {
      return func(...args);
    }
    return void 0;
  };
}
var init_after2 = __esm({
  "node_modules/es-toolkit/dist/function/after.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/predicate/isEqualWith.mjs
function isEqualWith2(a, b, areValuesEqual) {
  if (typeof areValuesEqual !== "function") {
    areValuesEqual = () => void 0;
  }
  return isEqualWith(a, b, (...args) => {
    const result2 = areValuesEqual(...args);
    if (result2 !== void 0) {
      return Boolean(result2);
    }
    if (a instanceof Map && b instanceof Map) {
      return isEqualWith2(Array.from(a), Array.from(b), after2(2, areValuesEqual));
    }
    if (a instanceof Set && b instanceof Set) {
      return isEqualWith2(Array.from(a), Array.from(b), after2(2, areValuesEqual));
    }
  });
}
var init_isEqualWith2 = __esm({
  "node_modules/es-toolkit/dist/compat/predicate/isEqualWith.mjs"() {
    init_after2();
    init_isEqualWith();
  }
});

// node_modules/es-toolkit/dist/compat/predicate/isError.mjs
function isError(value) {
  return getTag(value) === "[object Error]";
}
var init_isError = __esm({
  "node_modules/es-toolkit/dist/compat/predicate/isError.mjs"() {
    init_getTag();
  }
});

// node_modules/es-toolkit/dist/compat/predicate/isFinite.mjs
function isFinite(value) {
  return Number.isFinite(value);
}
var init_isFinite = __esm({
  "node_modules/es-toolkit/dist/compat/predicate/isFinite.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/predicate/isInteger.mjs
function isInteger(value) {
  return Number.isInteger(value);
}
var init_isInteger = __esm({
  "node_modules/es-toolkit/dist/compat/predicate/isInteger.mjs"() {
  }
});

// node_modules/es-toolkit/dist/predicate/isRegExp.mjs
function isRegExp(value) {
  return value instanceof RegExp;
}
var init_isRegExp = __esm({
  "node_modules/es-toolkit/dist/predicate/isRegExp.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/predicate/isRegExp.mjs
function isRegExp2(value) {
  return isRegExp(value);
}
var init_isRegExp2 = __esm({
  "node_modules/es-toolkit/dist/compat/predicate/isRegExp.mjs"() {
    init_isRegExp();
  }
});

// node_modules/es-toolkit/dist/compat/predicate/isSafeInteger.mjs
function isSafeInteger(value) {
  return Number.isSafeInteger(value);
}
var init_isSafeInteger = __esm({
  "node_modules/es-toolkit/dist/compat/predicate/isSafeInteger.mjs"() {
  }
});

// node_modules/es-toolkit/dist/predicate/isSet.mjs
function isSet(value) {
  return value instanceof Set;
}
var init_isSet = __esm({
  "node_modules/es-toolkit/dist/predicate/isSet.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/predicate/isSet.mjs
function isSet2(value) {
  return isSet(value);
}
var init_isSet2 = __esm({
  "node_modules/es-toolkit/dist/compat/predicate/isSet.mjs"() {
    init_isSet();
  }
});

// node_modules/es-toolkit/dist/predicate/isWeakMap.mjs
function isWeakMap(value) {
  return value instanceof WeakMap;
}
var init_isWeakMap = __esm({
  "node_modules/es-toolkit/dist/predicate/isWeakMap.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/predicate/isWeakMap.mjs
function isWeakMap2(value) {
  return isWeakMap(value);
}
var init_isWeakMap2 = __esm({
  "node_modules/es-toolkit/dist/compat/predicate/isWeakMap.mjs"() {
    init_isWeakMap();
  }
});

// node_modules/es-toolkit/dist/predicate/isWeakSet.mjs
function isWeakSet(value) {
  return value instanceof WeakSet;
}
var init_isWeakSet = __esm({
  "node_modules/es-toolkit/dist/predicate/isWeakSet.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/predicate/isWeakSet.mjs
function isWeakSet2(value) {
  return isWeakSet(value);
}
var init_isWeakSet2 = __esm({
  "node_modules/es-toolkit/dist/compat/predicate/isWeakSet.mjs"() {
    init_isWeakSet();
  }
});

// node_modules/es-toolkit/dist/string/capitalize.mjs
function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
}
var init_capitalize = __esm({
  "node_modules/es-toolkit/dist/string/capitalize.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/string/capitalize.mjs
function capitalize2(str) {
  return capitalize(toString(str));
}
var init_capitalize2 = __esm({
  "node_modules/es-toolkit/dist/compat/string/capitalize.mjs"() {
    init_capitalize();
    init_toString();
  }
});

// node_modules/es-toolkit/dist/compat/util/bindAll.mjs
function bindAll(object, ...methodNames) {
  if (object == null) {
    return object;
  }
  if (!isObject(object)) {
    return object;
  }
  if (isArray(object) && methodNames.length === 0) {
    return object;
  }
  const methods = [];
  for (let i = 0; i < methodNames.length; i++) {
    const name = methodNames[i];
    if (isArray(name)) {
      methods.push(...name);
    } else if (name && typeof name === "object" && "length" in name) {
      methods.push(...Array.from(name));
    } else {
      methods.push(name);
    }
  }
  if (methods.length === 0) {
    return object;
  }
  for (let i = 0; i < methods.length; i++) {
    const key = methods[i];
    const stringKey = toString(key);
    const func = object[stringKey];
    if (isFunction(func)) {
      object[stringKey] = func.bind(object);
    }
  }
  return object;
}
var init_bindAll = __esm({
  "node_modules/es-toolkit/dist/compat/util/bindAll.mjs"() {
    init_isFunction();
    init_isArray();
    init_isObject();
    init_toString();
  }
});

// node_modules/es-toolkit/dist/string/words.mjs
function words(str) {
  return Array.from(str.match(CASE_SPLIT_PATTERN) ?? []);
}
var CASE_SPLIT_PATTERN;
var init_words = __esm({
  "node_modules/es-toolkit/dist/string/words.mjs"() {
    CASE_SPLIT_PATTERN = new RegExp("\\p{Lu}?\\p{Ll}+|[0-9]+|\\p{Lu}+(?!\\p{Ll})|\\p{Emoji_Presentation}|\\p{Extended_Pictographic}|\\p{L}+", "gu");
  }
});

// node_modules/es-toolkit/dist/string/camelCase.mjs
function camelCase(str) {
  const words$1 = words(str);
  if (words$1.length === 0) {
    return "";
  }
  const [first, ...rest3] = words$1;
  return `${first.toLowerCase()}${rest3.map((word) => capitalize(word)).join("")}`;
}
var init_camelCase = __esm({
  "node_modules/es-toolkit/dist/string/camelCase.mjs"() {
    init_capitalize();
    init_words();
  }
});

// node_modules/es-toolkit/dist/compat/_internal/normalizeForCase.mjs
function normalizeForCase(str) {
  if (typeof str !== "string") {
    str = toString(str);
  }
  return str.replace(/['\u2019]/g, "");
}
var init_normalizeForCase = __esm({
  "node_modules/es-toolkit/dist/compat/_internal/normalizeForCase.mjs"() {
    init_toString();
  }
});

// node_modules/es-toolkit/dist/compat/string/camelCase.mjs
function camelCase2(str) {
  return camelCase(normalizeForCase(str));
}
var init_camelCase2 = __esm({
  "node_modules/es-toolkit/dist/compat/string/camelCase.mjs"() {
    init_camelCase();
    init_normalizeForCase();
  }
});

// node_modules/es-toolkit/dist/string/deburr.mjs
function deburr(str) {
  str = str.normalize("NFD");
  let result2 = "";
  for (let i = 0; i < str.length; i++) {
    const char = str[i];
    if (char >= "" && char <= "" || char >= "" && char <= "") {
      continue;
    }
    result2 += deburrMap.get(char) ?? char;
  }
  return result2;
}
var deburrMap;
var init_deburr = __esm({
  "node_modules/es-toolkit/dist/string/deburr.mjs"() {
    deburrMap = new Map(Object.entries({
      : "Ae",
      : "D",
      : "O",
      : "Th",
      : "ss",
      : "ae",
      : "d",
      : "o",
      : "th",
      : "D",
      : "d",
      : "H",
      : "h",
      : "i",
      : "IJ",
      : "ij",
      : "k",
      : "L",
      : "l",
      : "L",
      : "l",
      : "'n",
      : "N",
      : "n",
      : "Oe",
      : "oe",
      : "T",
      : "t",
      : "s"
    }));
  }
});

// node_modules/es-toolkit/dist/compat/string/deburr.mjs
function deburr2(str) {
  return deburr(toString(str));
}
var init_deburr2 = __esm({
  "node_modules/es-toolkit/dist/compat/string/deburr.mjs"() {
    init_deburr();
    init_toString();
  }
});

// node_modules/es-toolkit/dist/compat/string/endsWith.mjs
function endsWith(str, target, position) {
  if (str == null || target == null) {
    return false;
  }
  if (position == null) {
    position = str.length;
  }
  return str.endsWith(target, position);
}
var init_endsWith = __esm({
  "node_modules/es-toolkit/dist/compat/string/endsWith.mjs"() {
  }
});

// node_modules/es-toolkit/dist/string/escape.mjs
function escape(str) {
  return str.replace(/[&<>"']/g, (match) => htmlEscapes[match]);
}
var htmlEscapes;
var init_escape = __esm({
  "node_modules/es-toolkit/dist/string/escape.mjs"() {
    htmlEscapes = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
  }
});

// node_modules/es-toolkit/dist/compat/string/escape.mjs
function escape2(string) {
  return escape(toString(string));
}
var init_escape2 = __esm({
  "node_modules/es-toolkit/dist/compat/string/escape.mjs"() {
    init_escape();
    init_toString();
  }
});

// node_modules/es-toolkit/dist/string/escapeRegExp.mjs
function escapeRegExp(str) {
  return str.replace(/[\\^$.*+?()[\]{}|]/g, "\\$&");
}
var init_escapeRegExp = __esm({
  "node_modules/es-toolkit/dist/string/escapeRegExp.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/string/escapeRegExp.mjs
function escapeRegExp2(str) {
  return escapeRegExp(toString(str));
}
var init_escapeRegExp2 = __esm({
  "node_modules/es-toolkit/dist/compat/string/escapeRegExp.mjs"() {
    init_escapeRegExp();
    init_toString();
  }
});

// node_modules/es-toolkit/dist/string/kebabCase.mjs
function kebabCase(str) {
  const words$1 = words(str);
  return words$1.map((word) => word.toLowerCase()).join("-");
}
var init_kebabCase = __esm({
  "node_modules/es-toolkit/dist/string/kebabCase.mjs"() {
    init_words();
  }
});

// node_modules/es-toolkit/dist/compat/string/kebabCase.mjs
function kebabCase2(str) {
  return kebabCase(normalizeForCase(str));
}
var init_kebabCase2 = __esm({
  "node_modules/es-toolkit/dist/compat/string/kebabCase.mjs"() {
    init_kebabCase();
    init_normalizeForCase();
  }
});

// node_modules/es-toolkit/dist/string/lowerCase.mjs
function lowerCase(str) {
  const words$1 = words(str);
  return words$1.map((word) => word.toLowerCase()).join(" ");
}
var init_lowerCase = __esm({
  "node_modules/es-toolkit/dist/string/lowerCase.mjs"() {
    init_words();
  }
});

// node_modules/es-toolkit/dist/compat/string/lowerCase.mjs
function lowerCase2(str) {
  return lowerCase(normalizeForCase(str));
}
var init_lowerCase2 = __esm({
  "node_modules/es-toolkit/dist/compat/string/lowerCase.mjs"() {
    init_lowerCase();
    init_normalizeForCase();
  }
});

// node_modules/es-toolkit/dist/string/lowerFirst.mjs
function lowerFirst(str) {
  return str.substring(0, 1).toLowerCase() + str.substring(1);
}
var init_lowerFirst = __esm({
  "node_modules/es-toolkit/dist/string/lowerFirst.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/string/lowerFirst.mjs
function lowerFirst2(str) {
  return lowerFirst(toString(str));
}
var init_lowerFirst2 = __esm({
  "node_modules/es-toolkit/dist/compat/string/lowerFirst.mjs"() {
    init_lowerFirst();
    init_toString();
  }
});

// node_modules/es-toolkit/dist/string/pad.mjs
function pad(str, length, chars = " ") {
  return str.padStart(Math.floor((length - str.length) / 2) + str.length, chars).padEnd(length, chars);
}
var init_pad = __esm({
  "node_modules/es-toolkit/dist/string/pad.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/string/pad.mjs
function pad2(str, length, chars) {
  return pad(toString(str), length, chars);
}
var init_pad2 = __esm({
  "node_modules/es-toolkit/dist/compat/string/pad.mjs"() {
    init_pad();
    init_toString();
  }
});

// node_modules/es-toolkit/dist/compat/string/padEnd.mjs
function padEnd(str, length = 0, chars = " ") {
  return toString(str).padEnd(length, chars);
}
var init_padEnd = __esm({
  "node_modules/es-toolkit/dist/compat/string/padEnd.mjs"() {
    init_toString();
  }
});

// node_modules/es-toolkit/dist/compat/string/padStart.mjs
function padStart(str, length = 0, chars = " ") {
  return toString(str).padStart(length, chars);
}
var init_padStart = __esm({
  "node_modules/es-toolkit/dist/compat/string/padStart.mjs"() {
    init_toString();
  }
});

// node_modules/es-toolkit/dist/compat/string/repeat.mjs
function repeat(str, n, guard) {
  if (guard ? isIterateeCall(str, n, guard) : n === void 0) {
    n = 1;
  } else {
    n = toInteger(n);
  }
  return toString(str).repeat(n);
}
var init_repeat = __esm({
  "node_modules/es-toolkit/dist/compat/string/repeat.mjs"() {
    init_isIterateeCall();
    init_toInteger();
    init_toString();
  }
});

// node_modules/es-toolkit/dist/compat/string/replace.mjs
function replace(target, pattern, replacement) {
  if (arguments.length < 3) {
    return toString(target);
  }
  return toString(target).replace(pattern, replacement);
}
var init_replace = __esm({
  "node_modules/es-toolkit/dist/compat/string/replace.mjs"() {
    init_toString();
  }
});

// node_modules/es-toolkit/dist/string/snakeCase.mjs
function snakeCase(str) {
  const words$1 = words(str);
  return words$1.map((word) => word.toLowerCase()).join("_");
}
var init_snakeCase = __esm({
  "node_modules/es-toolkit/dist/string/snakeCase.mjs"() {
    init_words();
  }
});

// node_modules/es-toolkit/dist/compat/string/snakeCase.mjs
function snakeCase2(str) {
  return snakeCase(normalizeForCase(str));
}
var init_snakeCase2 = __esm({
  "node_modules/es-toolkit/dist/compat/string/snakeCase.mjs"() {
    init_snakeCase();
    init_normalizeForCase();
  }
});

// node_modules/es-toolkit/dist/compat/string/split.mjs
function split(string, separator, limit) {
  return toString(string).split(separator, limit);
}
var init_split = __esm({
  "node_modules/es-toolkit/dist/compat/string/split.mjs"() {
    init_toString();
  }
});

// node_modules/es-toolkit/dist/compat/string/startCase.mjs
function startCase(str) {
  const words$1 = words(normalizeForCase(str).trim());
  let result2 = "";
  for (let i = 0; i < words$1.length; i++) {
    const word = words$1[i];
    if (result2) {
      result2 += " ";
    }
    if (word === word.toUpperCase()) {
      result2 += word;
    } else {
      result2 += word[0].toUpperCase() + word.slice(1).toLowerCase();
    }
  }
  return result2;
}
var init_startCase = __esm({
  "node_modules/es-toolkit/dist/compat/string/startCase.mjs"() {
    init_words();
    init_normalizeForCase();
  }
});

// node_modules/es-toolkit/dist/compat/string/startsWith.mjs
function startsWith(str, target, position) {
  if (str == null || target == null) {
    return false;
  }
  if (position == null) {
    position = 0;
  }
  return str.startsWith(target, position);
}
var init_startsWith = __esm({
  "node_modules/es-toolkit/dist/compat/string/startsWith.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/string/template.mjs
function escapeString(match) {
  return `\\${escapeMap.get(match)}`;
}
function template(string, options, guard) {
  var _a, _b, _c;
  string = toString(string);
  if (guard) {
    options = templateSettings;
  }
  options = defaults({ ...options }, templateSettings);
  const delimitersRegExp = new RegExp([
    ((_a = options.escape) == null ? void 0 : _a.source) ?? noMatchExp.source,
    ((_b = options.interpolate) == null ? void 0 : _b.source) ?? noMatchExp.source,
    options.interpolate ? esTemplateRegExp.source : noMatchExp.source,
    ((_c = options.evaluate) == null ? void 0 : _c.source) ?? noMatchExp.source,
    "$"
  ].join("|"), "g");
  let lastIndex = 0;
  let isEvaluated = false;
  let source = `__p += ''`;
  for (const match of string.matchAll(delimitersRegExp)) {
    const [fullMatch, escapeValue, interpolateValue, esTemplateValue, evaluateValue] = match;
    const { index } = match;
    source += ` + '${string.slice(lastIndex, index).replace(unEscapedRegExp, escapeString)}'`;
    if (escapeValue) {
      source += ` + _.escape(${escapeValue})`;
    }
    if (interpolateValue) {
      source += ` + ((${interpolateValue}) == null ? '' : ${interpolateValue})`;
    } else if (esTemplateValue) {
      source += ` + ((${esTemplateValue}) == null ? '' : ${esTemplateValue})`;
    }
    if (evaluateValue) {
      source += `;
${evaluateValue};
 __p += ''`;
      isEvaluated = true;
    }
    lastIndex = index + fullMatch.length;
  }
  const imports = defaults({ ...options.imports }, templateSettings.imports);
  const importsKeys = Object.keys(imports);
  const importValues = Object.values(imports);
  const sourceURL = `//# sourceURL=${options.sourceURL ? String(options.sourceURL).replace(/[\r\n]/g, " ") : `es-toolkit.templateSource[${Date.now()}]`}
`;
  const compiledFunction = `function(${options.variable || "obj"}) {
    let __p = '';
    ${options.variable ? "" : "if (obj == null) { obj = {}; }"}
    ${isEvaluated ? `function print() { __p += Array.prototype.join.call(arguments, ''); }` : ""}
    ${options.variable ? source : `with(obj) {
${source}
}`}
    return __p;
  }`;
  const result2 = attempt(() => new Function(...importsKeys, `${sourceURL}return ${compiledFunction}`)(...importValues));
  result2.source = compiledFunction;
  if (result2 instanceof Error) {
    throw result2;
  }
  return result2;
}
var esTemplateRegExp, unEscapedRegExp, noMatchExp, escapeMap, templateSettings;
var init_template = __esm({
  "node_modules/es-toolkit/dist/compat/string/template.mjs"() {
    init_escape2();
    init_attempt();
    init_defaults();
    init_toString();
    esTemplateRegExp = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    unEscapedRegExp = /['\n\r\u2028\u2029\\]/g;
    noMatchExp = /($^)/;
    escapeMap = /* @__PURE__ */ new Map([
      ["\\", "\\"],
      ["'", "'"],
      ["\n", "n"],
      ["\r", "r"],
      ["\u2028", "u2028"],
      ["\u2029", "u2029"]
    ]);
    templateSettings = {
      escape: /<%-([\s\S]+?)%>/g,
      evaluate: /<%([\s\S]+?)%>/g,
      interpolate: /<%=([\s\S]+?)%>/g,
      variable: "",
      imports: {
        _: {
          escape: escape2,
          template
        }
      }
    };
  }
});

// node_modules/es-toolkit/dist/compat/string/toLower.mjs
function toLower(value) {
  return toString(value).toLowerCase();
}
var init_toLower = __esm({
  "node_modules/es-toolkit/dist/compat/string/toLower.mjs"() {
    init_toString();
  }
});

// node_modules/es-toolkit/dist/compat/string/toUpper.mjs
function toUpper(value) {
  return toString(value).toUpperCase();
}
var init_toUpper = __esm({
  "node_modules/es-toolkit/dist/compat/string/toUpper.mjs"() {
    init_toString();
  }
});

// node_modules/es-toolkit/dist/string/trimEnd.mjs
function trimEnd(str, chars) {
  if (chars === void 0) {
    return str.trimEnd();
  }
  let endIndex = str.length;
  switch (typeof chars) {
    case "string": {
      if (chars.length !== 1) {
        throw new Error(`The 'chars' parameter should be a single character string.`);
      }
      while (endIndex > 0 && str[endIndex - 1] === chars) {
        endIndex--;
      }
      break;
    }
    case "object": {
      while (endIndex > 0 && chars.includes(str[endIndex - 1])) {
        endIndex--;
      }
    }
  }
  return str.substring(0, endIndex);
}
var init_trimEnd = __esm({
  "node_modules/es-toolkit/dist/string/trimEnd.mjs"() {
  }
});

// node_modules/es-toolkit/dist/string/trimStart.mjs
function trimStart(str, chars) {
  if (chars === void 0) {
    return str.trimStart();
  }
  let startIndex = 0;
  switch (typeof chars) {
    case "string": {
      while (startIndex < str.length && str[startIndex] === chars) {
        startIndex++;
      }
      break;
    }
    case "object": {
      while (startIndex < str.length && chars.includes(str[startIndex])) {
        startIndex++;
      }
    }
  }
  return str.substring(startIndex);
}
var init_trimStart = __esm({
  "node_modules/es-toolkit/dist/string/trimStart.mjs"() {
  }
});

// node_modules/es-toolkit/dist/string/trim.mjs
function trim(str, chars) {
  if (chars === void 0) {
    return str.trim();
  }
  return trimStart(trimEnd(str, chars), chars);
}
var init_trim = __esm({
  "node_modules/es-toolkit/dist/string/trim.mjs"() {
    init_trimEnd();
    init_trimStart();
  }
});

// node_modules/es-toolkit/dist/compat/string/trim.mjs
function trim2(str, chars, guard) {
  if (str == null) {
    return "";
  }
  if (guard != null || chars == null) {
    return str.toString().trim();
  }
  switch (typeof chars) {
    case "object": {
      if (Array.isArray(chars)) {
        return trim(str, chars.flatMap((x) => x.toString().split("")));
      } else {
        return trim(str, chars.toString().split(""));
      }
    }
    default: {
      return trim(str, chars.toString().split(""));
    }
  }
}
var init_trim2 = __esm({
  "node_modules/es-toolkit/dist/compat/string/trim.mjs"() {
    init_trim();
  }
});

// node_modules/es-toolkit/dist/compat/string/trimEnd.mjs
function trimEnd2(str, chars, guard) {
  if (str == null) {
    return "";
  }
  if (guard != null || chars == null) {
    return str.toString().trimEnd();
  }
  return trimEnd(str, chars.toString().split(""));
}
var init_trimEnd2 = __esm({
  "node_modules/es-toolkit/dist/compat/string/trimEnd.mjs"() {
    init_trimEnd();
  }
});

// node_modules/es-toolkit/dist/compat/string/trimStart.mjs
function trimStart2(str, chars, guard) {
  if (str == null) {
    return "";
  }
  if (guard != null || chars == null) {
    return str.toString().trimStart();
  }
  return trimStart(str, chars.toString().split(""));
}
var init_trimStart2 = __esm({
  "node_modules/es-toolkit/dist/compat/string/trimStart.mjs"() {
    init_trimStart();
  }
});

// node_modules/es-toolkit/dist/compat/string/truncate.mjs
function truncate(string, options) {
  string = string != null ? `${string}` : "";
  let length = 30;
  let omission = "...";
  if (isObject(options)) {
    length = parseLength(options.length);
    omission = "omission" in options ? `${options.omission}` : "...";
  }
  let i = string.length;
  const lengthOmission = Array.from(omission).length;
  const lengthBase = Math.max(length - lengthOmission, 0);
  let strArray = void 0;
  const unicode = regexMultiByte.test(string);
  if (unicode) {
    strArray = Array.from(string);
    i = strArray.length;
  }
  if (length >= i) {
    return string;
  }
  if (i <= lengthOmission) {
    return omission;
  }
  let base = strArray === void 0 ? string.slice(0, lengthBase) : strArray == null ? void 0 : strArray.slice(0, lengthBase).join("");
  const separator = options == null ? void 0 : options.separator;
  if (!separator) {
    base += omission;
    return base;
  }
  const search = separator instanceof RegExp ? separator.source : separator;
  const flags = "u" + (separator instanceof RegExp ? separator.flags.replace("u", "") : "");
  const withoutSeparator = new RegExp(`(?<result>.*(?:(?!${search}).))(?:${search})`, flags).exec(base);
  return (!(withoutSeparator == null ? void 0 : withoutSeparator.groups) ? base : withoutSeparator.groups.result) + omission;
}
function parseLength(length) {
  if (length == null) {
    return 30;
  }
  if (length <= 0) {
    return 0;
  }
  return length;
}
var regexMultiByte;
var init_truncate = __esm({
  "node_modules/es-toolkit/dist/compat/string/truncate.mjs"() {
    init_isObject();
    regexMultiByte = /[\u200d\ud800-\udfff\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff\ufe0e\ufe0f]/;
  }
});

// node_modules/es-toolkit/dist/string/unescape.mjs
function unescape(str) {
  return str.replace(/&(?:amp|lt|gt|quot|#(0+)?39);/g, (match) => htmlUnescapes[match] || "'");
}
var htmlUnescapes;
var init_unescape = __esm({
  "node_modules/es-toolkit/dist/string/unescape.mjs"() {
    htmlUnescapes = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    };
  }
});

// node_modules/es-toolkit/dist/compat/string/unescape.mjs
function unescape2(str) {
  return unescape(toString(str));
}
var init_unescape2 = __esm({
  "node_modules/es-toolkit/dist/compat/string/unescape.mjs"() {
    init_unescape();
    init_toString();
  }
});

// node_modules/es-toolkit/dist/string/upperCase.mjs
function upperCase(str) {
  const words$1 = words(str);
  let result2 = "";
  for (let i = 0; i < words$1.length; i++) {
    result2 += words$1[i].toUpperCase();
    if (i < words$1.length - 1) {
      result2 += " ";
    }
  }
  return result2;
}
var init_upperCase = __esm({
  "node_modules/es-toolkit/dist/string/upperCase.mjs"() {
    init_words();
  }
});

// node_modules/es-toolkit/dist/compat/string/upperCase.mjs
function upperCase2(str) {
  return upperCase(normalizeForCase(str));
}
var init_upperCase2 = __esm({
  "node_modules/es-toolkit/dist/compat/string/upperCase.mjs"() {
    init_upperCase();
    init_normalizeForCase();
  }
});

// node_modules/es-toolkit/dist/string/upperFirst.mjs
function upperFirst(str) {
  return str.substring(0, 1).toUpperCase() + str.substring(1);
}
var init_upperFirst = __esm({
  "node_modules/es-toolkit/dist/string/upperFirst.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/string/upperFirst.mjs
function upperFirst2(str) {
  return upperFirst(toString(str));
}
var init_upperFirst2 = __esm({
  "node_modules/es-toolkit/dist/compat/string/upperFirst.mjs"() {
    init_upperFirst();
    init_toString();
  }
});

// node_modules/es-toolkit/dist/compat/string/words.mjs
function words2(str, pattern = rUnicodeWord, guard) {
  const input = toString(str);
  if (guard) {
    pattern = rUnicodeWord;
  }
  if (typeof pattern === "number") {
    pattern = pattern.toString();
  }
  const words3 = Array.from(input.match(pattern) ?? []);
  return words3.filter((x) => x !== "");
}
var rNonCharLatin, rUnicodeUpper, rUnicodeLower, rMisc, rNumber, rUnicodeOptContrLower, rUnicodeOptContrUpper, rUnicodeBreak, rUnicodeMiscUpper, rUnicodeMiscLower, rUnicodeWord;
var init_words2 = __esm({
  "node_modules/es-toolkit/dist/compat/string/words.mjs"() {
    init_toString();
    rNonCharLatin = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\xd7\\xf7";
    rUnicodeUpper = "\\p{Lu}";
    rUnicodeLower = "\\p{Ll}";
    rMisc = "(?:[\\p{Lm}\\p{Lo}]\\p{M}*)";
    rNumber = "\\d";
    rUnicodeOptContrLower = "(?:['](?:d|ll|m|re|s|t|ve))?";
    rUnicodeOptContrUpper = "(?:['](?:D|LL|M|RE|S|T|VE))?";
    rUnicodeBreak = `[\\p{Z}\\p{P}${rNonCharLatin}]`;
    rUnicodeMiscUpper = `(?:${rUnicodeUpper}|${rMisc})`;
    rUnicodeMiscLower = `(?:${rUnicodeLower}|${rMisc})`;
    rUnicodeWord = RegExp([
      `${rUnicodeUpper}?${rUnicodeLower}+${rUnicodeOptContrLower}(?=${rUnicodeBreak}|${rUnicodeUpper}|$)`,
      `${rUnicodeMiscUpper}+${rUnicodeOptContrUpper}(?=${rUnicodeBreak}|${rUnicodeUpper}${rUnicodeMiscLower}|$)`,
      `${rUnicodeUpper}?${rUnicodeMiscLower}+${rUnicodeOptContrLower}`,
      `${rUnicodeUpper}+${rUnicodeOptContrUpper}`,
      `${rNumber}*(?:1ST|2ND|3RD|(?![123])${rNumber}TH)(?=\\b|[a-z_])`,
      `${rNumber}*(?:1st|2nd|3rd|(?![123])${rNumber}th)(?=\\b|[A-Z_])`,
      `${rNumber}+`,
      "\\p{Emoji_Presentation}",
      "\\p{Extended_Pictographic}"
    ].join("|"), "gu");
  }
});

// node_modules/es-toolkit/dist/compat/util/cond.mjs
function cond(pairs) {
  const length = pairs.length;
  const processedPairs = pairs.map((pair) => {
    const predicate = pair[0];
    const func = pair[1];
    if (!isFunction(func)) {
      throw new TypeError("Expected a function");
    }
    return [iteratee(predicate), func];
  });
  return function(...args) {
    for (let i = 0; i < length; i++) {
      const pair = processedPairs[i];
      const predicate = pair[0];
      const func = pair[1];
      if (predicate.apply(this, args)) {
        return func.apply(this, args);
      }
    }
  };
}
var init_cond = __esm({
  "node_modules/es-toolkit/dist/compat/util/cond.mjs"() {
    init_iteratee();
    init_isFunction();
  }
});

// node_modules/es-toolkit/dist/compat/util/constant.mjs
function constant(value) {
  return () => value;
}
var init_constant = __esm({
  "node_modules/es-toolkit/dist/compat/util/constant.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/util/defaultTo.mjs
function defaultTo(value, defaultValue) {
  if (value == null || Number.isNaN(value)) {
    return defaultValue;
  }
  return value;
}
var init_defaultTo = __esm({
  "node_modules/es-toolkit/dist/compat/util/defaultTo.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/util/gt.mjs
function gt(value, other) {
  if (typeof value === "string" && typeof other === "string") {
    return value > other;
  }
  return toNumber(value) > toNumber(other);
}
var init_gt = __esm({
  "node_modules/es-toolkit/dist/compat/util/gt.mjs"() {
    init_toNumber();
  }
});

// node_modules/es-toolkit/dist/compat/util/gte.mjs
function gte(value, other) {
  if (typeof value === "string" && typeof other === "string") {
    return value >= other;
  }
  return toNumber(value) >= toNumber(other);
}
var init_gte = __esm({
  "node_modules/es-toolkit/dist/compat/util/gte.mjs"() {
    init_toNumber();
  }
});

// node_modules/es-toolkit/dist/compat/util/invoke.mjs
function invoke(object, path, ...args) {
  args = args.flat(1);
  if (object == null) {
    return;
  }
  switch (typeof path) {
    case "string": {
      if (typeof object === "object" && Object.hasOwn(object, path)) {
        return invokeImpl(object, [path], args);
      }
      return invokeImpl(object, toPath(path), args);
    }
    case "number":
    case "symbol": {
      return invokeImpl(object, [path], args);
    }
    default: {
      if (Array.isArray(path)) {
        return invokeImpl(object, path, args);
      } else {
        return invokeImpl(object, [path], args);
      }
    }
  }
}
function invokeImpl(object, path, args) {
  const parent = get(object, path.slice(0, -1), object);
  if (parent == null) {
    return void 0;
  }
  let lastKey = last2(path);
  const lastValue = lastKey == null ? void 0 : lastKey.valueOf();
  if (typeof lastValue === "number") {
    lastKey = toKey(lastValue);
  } else {
    lastKey = String(lastKey);
  }
  const func = get(parent, lastKey);
  return func == null ? void 0 : func.apply(parent, args);
}
var init_invoke = __esm({
  "node_modules/es-toolkit/dist/compat/util/invoke.mjs"() {
    init_toPath();
    init_toKey();
    init_last2();
    init_get();
  }
});

// node_modules/es-toolkit/dist/compat/util/lt.mjs
function lt(value, other) {
  if (typeof value === "string" && typeof other === "string") {
    return value < other;
  }
  return toNumber(value) < toNumber(other);
}
var init_lt = __esm({
  "node_modules/es-toolkit/dist/compat/util/lt.mjs"() {
    init_toNumber();
  }
});

// node_modules/es-toolkit/dist/compat/util/lte.mjs
function lte(value, other) {
  if (typeof value === "string" && typeof other === "string") {
    return value <= other;
  }
  return toNumber(value) <= toNumber(other);
}
var init_lte = __esm({
  "node_modules/es-toolkit/dist/compat/util/lte.mjs"() {
    init_toNumber();
  }
});

// node_modules/es-toolkit/dist/compat/util/method.mjs
function method(path, ...args) {
  return function(object) {
    return invoke(object, path, args);
  };
}
var init_method = __esm({
  "node_modules/es-toolkit/dist/compat/util/method.mjs"() {
    init_invoke();
  }
});

// node_modules/es-toolkit/dist/compat/util/methodOf.mjs
function methodOf(object, ...args) {
  return function(path) {
    return invoke(object, path, args);
  };
}
var init_methodOf = __esm({
  "node_modules/es-toolkit/dist/compat/util/methodOf.mjs"() {
    init_invoke();
  }
});

// node_modules/es-toolkit/dist/compat/util/now.mjs
function now() {
  return Date.now();
}
var init_now = __esm({
  "node_modules/es-toolkit/dist/compat/util/now.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/util/over.mjs
function over(...iteratees) {
  if (iteratees.length === 1 && Array.isArray(iteratees[0])) {
    iteratees = iteratees[0];
  }
  const funcs = iteratees.map((item) => iteratee(item));
  return function(...args) {
    return funcs.map((func) => func.apply(this, args));
  };
}
var init_over = __esm({
  "node_modules/es-toolkit/dist/compat/util/over.mjs"() {
    init_iteratee();
  }
});

// node_modules/es-toolkit/dist/compat/util/overEvery.mjs
function overEvery(...predicates) {
  return function(...values2) {
    for (let i = 0; i < predicates.length; ++i) {
      const predicate = predicates[i];
      if (!Array.isArray(predicate)) {
        if (!iteratee(predicate).apply(this, values2)) {
          return false;
        }
        continue;
      }
      for (let j = 0; j < predicate.length; ++j) {
        if (!iteratee(predicate[j]).apply(this, values2)) {
          return false;
        }
      }
    }
    return true;
  };
}
var init_overEvery = __esm({
  "node_modules/es-toolkit/dist/compat/util/overEvery.mjs"() {
    init_iteratee();
  }
});

// node_modules/es-toolkit/dist/compat/util/overSome.mjs
function overSome(...predicates) {
  return function(...values2) {
    for (let i = 0; i < predicates.length; ++i) {
      const predicate = predicates[i];
      if (!Array.isArray(predicate)) {
        if (iteratee(predicate).apply(this, values2)) {
          return true;
        }
        continue;
      }
      for (let j = 0; j < predicate.length; ++j) {
        if (iteratee(predicate[j]).apply(this, values2)) {
          return true;
        }
      }
    }
    return false;
  };
}
var init_overSome = __esm({
  "node_modules/es-toolkit/dist/compat/util/overSome.mjs"() {
    init_iteratee();
  }
});

// node_modules/es-toolkit/dist/compat/util/stubArray.mjs
function stubArray() {
  return [];
}
var init_stubArray = __esm({
  "node_modules/es-toolkit/dist/compat/util/stubArray.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/util/stubFalse.mjs
function stubFalse() {
  return false;
}
var init_stubFalse = __esm({
  "node_modules/es-toolkit/dist/compat/util/stubFalse.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/util/stubObject.mjs
function stubObject() {
  return {};
}
var init_stubObject = __esm({
  "node_modules/es-toolkit/dist/compat/util/stubObject.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/util/stubString.mjs
function stubString() {
  return "";
}
var init_stubString = __esm({
  "node_modules/es-toolkit/dist/compat/util/stubString.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/util/stubTrue.mjs
function stubTrue() {
  return true;
}
var init_stubTrue = __esm({
  "node_modules/es-toolkit/dist/compat/util/stubTrue.mjs"() {
  }
});

// node_modules/es-toolkit/dist/compat/_internal/MAX_ARRAY_LENGTH.mjs
var MAX_ARRAY_LENGTH4;
var init_MAX_ARRAY_LENGTH = __esm({
  "node_modules/es-toolkit/dist/compat/_internal/MAX_ARRAY_LENGTH.mjs"() {
    MAX_ARRAY_LENGTH4 = 4294967295;
  }
});

// node_modules/es-toolkit/dist/compat/util/toLength.mjs
function toLength(value) {
  if (value == null) {
    return 0;
  }
  const length = Math.floor(Number(value));
  return clamp2(length, 0, MAX_ARRAY_LENGTH4);
}
var init_toLength = __esm({
  "node_modules/es-toolkit/dist/compat/util/toLength.mjs"() {
    init_MAX_ARRAY_LENGTH();
    init_clamp2();
  }
});

// node_modules/es-toolkit/dist/compat/util/toPlainObject.mjs
function toPlainObject(value) {
  const plainObject = {};
  const valueKeys = keysIn(value);
  for (let i = 0; i < valueKeys.length; i++) {
    const key = valueKeys[i];
    const objValue = value[key];
    if (key === "__proto__") {
      Object.defineProperty(plainObject, key, {
        configurable: true,
        enumerable: true,
        value: objValue,
        writable: true
      });
    } else {
      plainObject[key] = objValue;
    }
  }
  return plainObject;
}
var init_toPlainObject = __esm({
  "node_modules/es-toolkit/dist/compat/util/toPlainObject.mjs"() {
    init_keysIn();
  }
});

// node_modules/es-toolkit/dist/compat/_internal/MAX_SAFE_INTEGER.mjs
var MAX_SAFE_INTEGER;
var init_MAX_SAFE_INTEGER = __esm({
  "node_modules/es-toolkit/dist/compat/_internal/MAX_SAFE_INTEGER.mjs"() {
    MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;
  }
});

// node_modules/es-toolkit/dist/compat/util/toSafeInteger.mjs
function toSafeInteger(value) {
  if (value == null) {
    return 0;
  }
  return clamp2(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
}
var init_toSafeInteger = __esm({
  "node_modules/es-toolkit/dist/compat/util/toSafeInteger.mjs"() {
    init_toInteger();
    init_MAX_SAFE_INTEGER();
    init_clamp2();
  }
});

// node_modules/es-toolkit/dist/compat/util/uniqueId.mjs
function uniqueId(prefix = "") {
  const id = ++idCounter;
  return `${prefix}${id}`;
}
var idCounter;
var init_uniqueId = __esm({
  "node_modules/es-toolkit/dist/compat/util/uniqueId.mjs"() {
    idCounter = 0;
  }
});

// node_modules/es-toolkit/dist/compat/compat.mjs
var compat_exports = {};
__export(compat_exports, {
  add: () => add,
  after: () => after,
  ary: () => ary2,
  assign: () => assign,
  assignIn: () => assignIn,
  assignInWith: () => assignInWith,
  assignWith: () => assignWith,
  at: () => at,
  attempt: () => attempt,
  before: () => before,
  bind: () => bind,
  bindAll: () => bindAll,
  bindKey: () => bindKey,
  camelCase: () => camelCase2,
  capitalize: () => capitalize2,
  castArray: () => castArray,
  ceil: () => ceil,
  chunk: () => chunk2,
  clamp: () => clamp2,
  clone: () => clone,
  cloneDeep: () => cloneDeep2,
  cloneDeepWith: () => cloneDeepWith2,
  cloneWith: () => cloneWith,
  compact: () => compact2,
  concat: () => concat,
  cond: () => cond,
  conforms: () => conforms,
  conformsTo: () => conformsTo,
  constant: () => constant,
  countBy: () => countBy,
  create: () => create,
  curry: () => curry,
  curryRight: () => curryRight,
  debounce: () => debounce2,
  deburr: () => deburr2,
  defaultTo: () => defaultTo,
  defaults: () => defaults,
  defaultsDeep: () => defaultsDeep,
  defer: () => defer,
  delay: () => delay,
  difference: () => difference2,
  differenceBy: () => differenceBy2,
  differenceWith: () => differenceWith2,
  divide: () => divide,
  drop: () => drop2,
  dropRight: () => dropRight2,
  dropRightWhile: () => dropRightWhile2,
  dropWhile: () => dropWhile2,
  each: () => forEach,
  eachRight: () => forEachRight,
  endsWith: () => endsWith,
  eq: () => eq,
  escape: () => escape2,
  escapeRegExp: () => escapeRegExp2,
  every: () => every,
  extend: () => assignIn,
  extendWith: () => assignInWith,
  fill: () => fill2,
  filter: () => filter,
  find: () => find,
  findIndex: () => findIndex,
  findKey: () => findKey2,
  findLast: () => findLast,
  findLastIndex: () => findLastIndex,
  findLastKey: () => findLastKey,
  first: () => head2,
  flatMap: () => flatMap,
  flatMapDeep: () => flatMapDeep,
  flatMapDepth: () => flatMapDepth,
  flatten: () => flatten2,
  flattenDeep: () => flattenDeep,
  flattenDepth: () => flattenDepth,
  flip: () => flip,
  floor: () => floor,
  flow: () => flow2,
  flowRight: () => flowRight2,
  forEach: () => forEach,
  forEachRight: () => forEachRight,
  forIn: () => forIn,
  forInRight: () => forInRight,
  forOwn: () => forOwn,
  forOwnRight: () => forOwnRight,
  fromPairs: () => fromPairs,
  functions: () => functions,
  functionsIn: () => functionsIn,
  get: () => get,
  groupBy: () => groupBy2,
  gt: () => gt,
  gte: () => gte,
  has: () => has,
  hasIn: () => hasIn,
  head: () => head2,
  identity: () => identity2,
  inRange: () => inRange2,
  includes: () => includes,
  indexOf: () => indexOf,
  initial: () => initial2,
  intersection: () => intersection2,
  intersectionBy: () => intersectionBy2,
  intersectionWith: () => intersectionWith2,
  invert: () => invert2,
  invertBy: () => invertBy,
  invoke: () => invoke,
  invokeMap: () => invokeMap,
  isArguments: () => isArguments,
  isArray: () => isArray,
  isArrayBuffer: () => isArrayBuffer2,
  isArrayLike: () => isArrayLike,
  isArrayLikeObject: () => isArrayLikeObject,
  isBoolean: () => isBoolean,
  isBuffer: () => isBuffer2,
  isDate: () => isDate2,
  isElement: () => isElement,
  isEmpty: () => isEmpty,
  isEqual: () => isEqual,
  isEqualWith: () => isEqualWith2,
  isError: () => isError,
  isFinite: () => isFinite,
  isFunction: () => isFunction2,
  isInteger: () => isInteger,
  isLength: () => isLength2,
  isMap: () => isMap2,
  isMatch: () => isMatch,
  isMatchWith: () => isMatchWith,
  isNaN: () => isNaN,
  isNative: () => isNative,
  isNil: () => isNil2,
  isNull: () => isNull2,
  isNumber: () => isNumber,
  isObject: () => isObject,
  isObjectLike: () => isObjectLike,
  isPlainObject: () => isPlainObject2,
  isRegExp: () => isRegExp2,
  isSafeInteger: () => isSafeInteger,
  isSet: () => isSet2,
  isString: () => isString,
  isSymbol: () => isSymbol,
  isTypedArray: () => isTypedArray2,
  isUndefined: () => isUndefined2,
  isWeakMap: () => isWeakMap2,
  isWeakSet: () => isWeakSet2,
  iteratee: () => iteratee,
  join: () => join,
  kebabCase: () => kebabCase2,
  keyBy: () => keyBy,
  keys: () => keys,
  keysIn: () => keysIn,
  last: () => last2,
  lastIndexOf: () => lastIndexOf,
  lowerCase: () => lowerCase2,
  lowerFirst: () => lowerFirst2,
  lt: () => lt,
  lte: () => lte,
  map: () => map,
  mapKeys: () => mapKeys2,
  mapValues: () => mapValues2,
  matches: () => matches,
  matchesProperty: () => matchesProperty,
  max: () => max,
  maxBy: () => maxBy2,
  mean: () => mean,
  meanBy: () => meanBy2,
  memoize: () => memoize,
  merge: () => merge,
  mergeWith: () => mergeWith,
  method: () => method,
  methodOf: () => methodOf,
  min: () => min,
  minBy: () => minBy2,
  multiply: () => multiply,
  negate: () => negate,
  noop: () => noop2,
  now: () => now,
  nth: () => nth,
  nthArg: () => nthArg,
  omit: () => omit,
  omitBy: () => omitBy,
  once: () => once2,
  orderBy: () => orderBy,
  over: () => over,
  overArgs: () => overArgs,
  overEvery: () => overEvery,
  overSome: () => overSome,
  pad: () => pad2,
  padEnd: () => padEnd,
  padStart: () => padStart,
  parseInt: () => parseInt,
  partial: () => partial2,
  partialRight: () => partialRight2,
  partition: () => partition,
  pick: () => pick,
  pickBy: () => pickBy,
  property: () => property,
  propertyOf: () => propertyOf,
  pull: () => pull2,
  pullAll: () => pullAll,
  pullAllBy: () => pullAllBy,
  pullAllWith: () => pullAllWith,
  pullAt: () => pullAt,
  random: () => random2,
  range: () => range2,
  rangeRight: () => rangeRight,
  rearg: () => rearg,
  reduce: () => reduce,
  reduceRight: () => reduceRight,
  reject: () => reject,
  remove: () => remove2,
  repeat: () => repeat,
  replace: () => replace,
  rest: () => rest2,
  result: () => result,
  reverse: () => reverse,
  round: () => round,
  sample: () => sample2,
  sampleSize: () => sampleSize2,
  set: () => set,
  setWith: () => setWith,
  shuffle: () => shuffle2,
  size: () => size,
  slice: () => slice,
  snakeCase: () => snakeCase2,
  some: () => some,
  sortBy: () => sortBy,
  sortedIndex: () => sortedIndex,
  sortedIndexBy: () => sortedIndexBy,
  sortedIndexOf: () => sortedIndexOf,
  sortedLastIndex: () => sortedLastIndex,
  sortedLastIndexBy: () => sortedLastIndexBy,
  sortedLastIndexOf: () => sortedLastIndexOf,
  split: () => split,
  spread: () => spread,
  startCase: () => startCase,
  startsWith: () => startsWith,
  stubArray: () => stubArray,
  stubFalse: () => stubFalse,
  stubObject: () => stubObject,
  stubString: () => stubString,
  stubTrue: () => stubTrue,
  subtract: () => subtract,
  sum: () => sum,
  sumBy: () => sumBy,
  tail: () => tail2,
  take: () => take2,
  takeRight: () => takeRight2,
  takeRightWhile: () => takeRightWhile,
  takeWhile: () => takeWhile,
  template: () => template,
  templateSettings: () => templateSettings,
  throttle: () => throttle,
  times: () => times,
  toArray: () => toArray2,
  toDefaulted: () => toDefaulted,
  toFinite: () => toFinite,
  toInteger: () => toInteger,
  toLength: () => toLength,
  toLower: () => toLower,
  toNumber: () => toNumber,
  toPairs: () => toPairs,
  toPairsIn: () => toPairsIn,
  toPath: () => toPath,
  toPlainObject: () => toPlainObject,
  toSafeInteger: () => toSafeInteger,
  toString: () => toString,
  toUpper: () => toUpper,
  transform: () => transform,
  trim: () => trim2,
  trimEnd: () => trimEnd2,
  trimStart: () => trimStart2,
  truncate: () => truncate,
  unary: () => unary,
  unescape: () => unescape2,
  union: () => union,
  unionBy: () => unionBy,
  unionWith: () => unionWith,
  uniq: () => uniq2,
  uniqBy: () => uniqBy2,
  uniqWith: () => uniqWith2,
  uniqueId: () => uniqueId,
  unset: () => unset,
  unzip: () => unzip2,
  unzipWith: () => unzipWith,
  update: () => update,
  updateWith: () => updateWith,
  upperCase: () => upperCase2,
  upperFirst: () => upperFirst2,
  values: () => values,
  valuesIn: () => valuesIn,
  without: () => without2,
  words: () => words2,
  wrap: () => wrap,
  xor: () => xor,
  xorBy: () => xorBy,
  xorWith: () => xorWith,
  zip: () => zip2,
  zipObject: () => zipObject,
  zipObjectDeep: () => zipObjectDeep,
  zipWith: () => zipWith
});
var init_compat = __esm({
  "node_modules/es-toolkit/dist/compat/compat.mjs"() {
    init_castArray();
    init_chunk2();
    init_compact2();
    init_concat();
    init_countBy();
    init_difference2();
    init_differenceBy2();
    init_differenceWith2();
    init_drop2();
    init_dropRight2();
    init_dropRightWhile2();
    init_dropWhile2();
    init_forEach();
    init_forEachRight();
    init_every();
    init_fill2();
    init_filter();
    init_find();
    init_findIndex();
    init_findLast();
    init_findLastIndex();
    init_head2();
    init_flatMap();
    init_flatMapDeep();
    init_flatMapDepth();
    init_flatten2();
    init_flattenDeep();
    init_flattenDepth();
    init_groupBy2();
    init_includes();
    init_indexOf();
    init_initial2();
    init_intersection2();
    init_intersectionBy2();
    init_intersectionWith2();
    init_invokeMap();
    init_join();
    init_keyBy();
    init_last2();
    init_lastIndexOf();
    init_map();
    init_nth();
    init_orderBy();
    init_partition();
    init_pull2();
    init_pullAll();
    init_pullAllBy();
    init_pullAllWith();
    init_pullAt();
    init_reduce();
    init_reduceRight();
    init_reject();
    init_remove2();
    init_reverse();
    init_sample2();
    init_sampleSize2();
    init_shuffle2();
    init_size();
    init_slice();
    init_some();
    init_sortBy();
    init_sortedIndex();
    init_sortedIndexBy();
    init_sortedIndexOf();
    init_sortedLastIndex();
    init_sortedLastIndexBy();
    init_sortedLastIndexOf();
    init_tail2();
    init_take2();
    init_takeRight2();
    init_takeRightWhile();
    init_takeWhile();
    init_union();
    init_unionBy();
    init_unionWith();
    init_uniq2();
    init_uniqBy2();
    init_uniqWith2();
    init_unzip2();
    init_unzipWith();
    init_without2();
    init_xor();
    init_xorBy();
    init_xorWith();
    init_zip2();
    init_zipObject();
    init_zipObjectDeep();
    init_zipWith();
    init_after();
    init_ary2();
    init_attempt();
    init_before();
    init_bind();
    init_bindKey();
    init_curry();
    init_curryRight();
    init_debounce2();
    init_defer();
    init_delay();
    init_flip();
    init_flow2();
    init_flowRight2();
    init_memoize();
    init_negate();
    init_nthArg();
    init_once2();
    init_overArgs();
    init_partial2();
    init_partialRight2();
    init_rearg();
    init_rest2();
    init_spread();
    init_throttle();
    init_unary();
    init_wrap();
    init_add();
    init_ceil();
    init_clamp2();
    init_divide();
    init_floor();
    init_inRange2();
    init_max();
    init_maxBy2();
    init_mean();
    init_meanBy2();
    init_min();
    init_minBy2();
    init_multiply();
    init_parseInt();
    init_random2();
    init_range2();
    init_rangeRight();
    init_round();
    init_subtract();
    init_sum();
    init_sumBy();
    init_isEqual();
    init_identity2();
    init_noop2();
    init_assign();
    init_assignIn();
    init_assignInWith();
    init_assignWith();
    init_at();
    init_clone();
    init_cloneDeep2();
    init_cloneDeepWith2();
    init_cloneWith();
    init_create();
    init_defaults();
    init_defaultsDeep();
    init_findKey2();
    init_findLastKey();
    init_forIn();
    init_forInRight();
    init_forOwn();
    init_forOwnRight();
    init_fromPairs();
    init_functions();
    init_functionsIn();
    init_get();
    init_has();
    init_hasIn();
    init_invert2();
    init_invertBy();
    init_keys();
    init_keysIn();
    init_mapKeys2();
    init_mapValues2();
    init_merge();
    init_mergeWith();
    init_omit();
    init_omitBy();
    init_pick();
    init_pickBy();
    init_property();
    init_propertyOf();
    init_result();
    init_set();
    init_setWith();
    init_toDefaulted();
    init_toPairs();
    init_toPairsIn();
    init_transform();
    init_unset();
    init_update();
    init_updateWith();
    init_values();
    init_valuesIn();
    init_isFunction2();
    init_isLength2();
    init_isMatchWith();
    init_isNative();
    init_isNull2();
    init_isUndefined2();
    init_conforms();
    init_conformsTo();
    init_isArguments();
    init_isArray();
    init_isArrayBuffer2();
    init_isArrayLike();
    init_isArrayLikeObject();
    init_isBoolean();
    init_isBuffer2();
    init_isDate2();
    init_isElement();
    init_isEmpty();
    init_isEqualWith2();
    init_isError();
    init_isFinite();
    init_isInteger();
    init_isMap2();
    init_isMatch();
    init_isNaN();
    init_isNil2();
    init_isNumber();
    init_isObject();
    init_isObjectLike();
    init_isPlainObject2();
    init_isRegExp2();
    init_isSafeInteger();
    init_isSet2();
    init_isString();
    init_isSymbol();
    init_isTypedArray2();
    init_isWeakMap2();
    init_isWeakSet2();
    init_matches();
    init_matchesProperty();
    init_capitalize2();
    init_bindAll();
    init_camelCase2();
    init_deburr2();
    init_endsWith();
    init_escape2();
    init_escapeRegExp2();
    init_kebabCase2();
    init_lowerCase2();
    init_lowerFirst2();
    init_pad2();
    init_padEnd();
    init_padStart();
    init_repeat();
    init_replace();
    init_snakeCase2();
    init_split();
    init_startCase();
    init_startsWith();
    init_template();
    init_toLower();
    init_toUpper();
    init_trim2();
    init_trimEnd2();
    init_trimStart2();
    init_truncate();
    init_unescape2();
    init_upperCase2();
    init_upperFirst2();
    init_words2();
    init_cond();
    init_constant();
    init_defaultTo();
    init_eq();
    init_gt();
    init_gte();
    init_invoke();
    init_iteratee();
    init_lt();
    init_lte();
    init_method();
    init_methodOf();
    init_now();
    init_over();
    init_overEvery();
    init_overSome();
    init_stubArray();
    init_stubFalse();
    init_stubObject();
    init_stubString();
    init_stubTrue();
    init_times();
    init_toArray2();
    init_toFinite();
    init_toInteger();
    init_toLength();
    init_toNumber();
    init_toPath();
    init_toPlainObject();
    init_toSafeInteger();
    init_toString();
    init_uniqueId();
  }
});

// node_modules/es-toolkit/dist/compat/toolkit.mjs
var toolkit;
var init_toolkit = __esm({
  "node_modules/es-toolkit/dist/compat/toolkit.mjs"() {
    init_compat();
    toolkit = (value) => {
      return value;
    };
    Object.assign(toolkit, compat_exports);
    toolkit.partial.placeholder = toolkit;
    toolkit.partialRight.placeholder = toolkit;
  }
});

// node_modules/es-toolkit/dist/compat/index.mjs
var init_compat2 = __esm({
  "node_modules/es-toolkit/dist/compat/index.mjs"() {
    init_castArray();
    init_chunk2();
    init_compact2();
    init_concat();
    init_countBy();
    init_difference2();
    init_differenceBy2();
    init_differenceWith2();
    init_drop2();
    init_dropRight2();
    init_dropRightWhile2();
    init_dropWhile2();
    init_forEach();
    init_forEachRight();
    init_every();
    init_fill2();
    init_filter();
    init_find();
    init_findIndex();
    init_findLast();
    init_findLastIndex();
    init_head2();
    init_flatMap();
    init_flatMapDeep();
    init_flatMapDepth();
    init_flatten2();
    init_flattenDeep();
    init_flattenDepth();
    init_groupBy2();
    init_includes();
    init_indexOf();
    init_initial2();
    init_intersection2();
    init_intersectionBy2();
    init_intersectionWith2();
    init_invokeMap();
    init_join();
    init_keyBy();
    init_last2();
    init_lastIndexOf();
    init_map();
    init_nth();
    init_orderBy();
    init_partition();
    init_pull2();
    init_pullAll();
    init_pullAllBy();
    init_pullAllWith();
    init_pullAt();
    init_reduce();
    init_reduceRight();
    init_reject();
    init_remove2();
    init_reverse();
    init_sample2();
    init_sampleSize2();
    init_shuffle2();
    init_size();
    init_slice();
    init_some();
    init_sortBy();
    init_sortedIndex();
    init_sortedIndexBy();
    init_sortedIndexOf();
    init_sortedLastIndex();
    init_sortedLastIndexBy();
    init_sortedLastIndexOf();
    init_tail2();
    init_take2();
    init_takeRight2();
    init_takeRightWhile();
    init_takeWhile();
    init_union();
    init_unionBy();
    init_unionWith();
    init_uniq2();
    init_uniqBy2();
    init_uniqWith2();
    init_unzip2();
    init_unzipWith();
    init_without2();
    init_xor();
    init_xorBy();
    init_xorWith();
    init_zip2();
    init_zipObject();
    init_zipObjectDeep();
    init_zipWith();
    init_after();
    init_ary2();
    init_attempt();
    init_before();
    init_bind();
    init_bindKey();
    init_curry();
    init_curryRight();
    init_debounce2();
    init_defer();
    init_delay();
    init_flip();
    init_flow2();
    init_flowRight2();
    init_memoize();
    init_negate();
    init_nthArg();
    init_once2();
    init_overArgs();
    init_partial2();
    init_partialRight2();
    init_rearg();
    init_rest2();
    init_spread();
    init_throttle();
    init_unary();
    init_wrap();
    init_add();
    init_ceil();
    init_clamp2();
    init_divide();
    init_floor();
    init_inRange2();
    init_max();
    init_maxBy2();
    init_mean();
    init_meanBy2();
    init_min();
    init_minBy2();
    init_multiply();
    init_parseInt();
    init_random2();
    init_range2();
    init_rangeRight();
    init_round();
    init_subtract();
    init_sum();
    init_sumBy();
    init_isEqual();
    init_identity2();
    init_noop2();
    init_assign();
    init_assignIn();
    init_assignInWith();
    init_assignWith();
    init_at();
    init_clone();
    init_cloneDeep2();
    init_cloneDeepWith2();
    init_cloneWith();
    init_create();
    init_defaults();
    init_defaultsDeep();
    init_findKey2();
    init_findLastKey();
    init_forIn();
    init_forInRight();
    init_forOwn();
    init_forOwnRight();
    init_fromPairs();
    init_functions();
    init_functionsIn();
    init_get();
    init_has();
    init_hasIn();
    init_invert2();
    init_invertBy();
    init_keys();
    init_keysIn();
    init_mapKeys2();
    init_mapValues2();
    init_merge();
    init_mergeWith();
    init_omit();
    init_omitBy();
    init_pick();
    init_pickBy();
    init_property();
    init_propertyOf();
    init_result();
    init_set();
    init_setWith();
    init_toDefaulted();
    init_toPairs();
    init_toPairsIn();
    init_transform();
    init_unset();
    init_update();
    init_updateWith();
    init_values();
    init_valuesIn();
    init_isFunction2();
    init_isLength2();
    init_isMatchWith();
    init_isNative();
    init_isNull2();
    init_isUndefined2();
    init_conforms();
    init_conformsTo();
    init_isArguments();
    init_isArray();
    init_isArrayBuffer2();
    init_isArrayLike();
    init_isArrayLikeObject();
    init_isBoolean();
    init_isBuffer2();
    init_isDate2();
    init_isElement();
    init_isEmpty();
    init_isEqualWith2();
    init_isError();
    init_isFinite();
    init_isInteger();
    init_isMap2();
    init_isMatch();
    init_isNaN();
    init_isNil2();
    init_isNumber();
    init_isObject();
    init_isObjectLike();
    init_isPlainObject2();
    init_isRegExp2();
    init_isSafeInteger();
    init_isSet2();
    init_isString();
    init_isSymbol();
    init_isTypedArray2();
    init_isWeakMap2();
    init_isWeakSet2();
    init_matches();
    init_matchesProperty();
    init_capitalize2();
    init_bindAll();
    init_camelCase2();
    init_deburr2();
    init_endsWith();
    init_escape2();
    init_escapeRegExp2();
    init_kebabCase2();
    init_lowerCase2();
    init_lowerFirst2();
    init_pad2();
    init_padEnd();
    init_padStart();
    init_repeat();
    init_replace();
    init_snakeCase2();
    init_split();
    init_startCase();
    init_startsWith();
    init_template();
    init_toLower();
    init_toUpper();
    init_trim2();
    init_trimEnd2();
    init_trimStart2();
    init_truncate();
    init_unescape2();
    init_upperCase2();
    init_upperFirst2();
    init_words2();
    init_cond();
    init_constant();
    init_defaultTo();
    init_eq();
    init_gt();
    init_gte();
    init_invoke();
    init_iteratee();
    init_lt();
    init_lte();
    init_method();
    init_methodOf();
    init_now();
    init_over();
    init_overEvery();
    init_overSome();
    init_stubArray();
    init_stubFalse();
    init_stubObject();
    init_stubString();
    init_stubTrue();
    init_times();
    init_toArray2();
    init_toFinite();
    init_toInteger();
    init_toLength();
    init_toNumber();
    init_toPath();
    init_toPlainObject();
    init_toSafeInteger();
    init_toString();
    init_uniqueId();
    init_toolkit();
  }
});

// node_modules/@ckeditor/ckeditor5-watchdog/src/utils/getsubnodes.js
function getSubNodes(head3, excludedProperties = /* @__PURE__ */ new Set()) {
  const nodes = [head3];
  const subNodes = /* @__PURE__ */ new Set();
  let nodeIndex = 0;
  while (nodes.length > nodeIndex) {
    const node = nodes[nodeIndex++];
    if (subNodes.has(node) || !shouldNodeBeIncluded(node) || excludedProperties.has(node)) {
      continue;
    }
    subNodes.add(node);
    if (Symbol.iterator in node) {
      try {
        for (const n of node) {
          nodes.push(n);
        }
      } catch {
      }
    } else {
      for (const key in node) {
        if (key === "defaultValue") {
          continue;
        }
        nodes.push(node[key]);
      }
    }
  }
  return subNodes;
}
function shouldNodeBeIncluded(node) {
  const type = Object.prototype.toString.call(node);
  const typeOfNode = typeof node;
  return !(typeOfNode === "number" || typeOfNode === "boolean" || typeOfNode === "string" || typeOfNode === "symbol" || typeOfNode === "function" || type === "[object Date]" || type === "[object RegExp]" || type === "[object Module]" || node === void 0 || node === null || // This flag is meant to exclude singletons shared across editor instances. So when an error is thrown in one editor,
  // the other editors connected through the reference to the same singleton are not restarted. This is a temporary workaround
  // until a better solution is found.
  // More in https://github.com/ckeditor/ckeditor5/issues/12292.
  node._watchdogExcluded || // Skip native DOM objects, e.g. Window, nodes, events, etc.
  node instanceof EventTarget || node instanceof Event);
}
var init_getsubnodes = __esm({
  "node_modules/@ckeditor/ckeditor5-watchdog/src/utils/getsubnodes.js"() {
  }
});

// node_modules/@ckeditor/ckeditor5-watchdog/src/utils/areconnectedthroughproperties.js
function areConnectedThroughProperties(target1, target2, excludedNodes = /* @__PURE__ */ new Set()) {
  if (target1 === target2 && isObject2(target1)) {
    return true;
  }
  const subNodes1 = getSubNodes(target1, excludedNodes);
  const subNodes2 = getSubNodes(target2, excludedNodes);
  for (const node of subNodes1) {
    if (subNodes2.has(node)) {
      return true;
    }
  }
  return false;
}
function isObject2(structure) {
  return typeof structure === "object" && structure !== null;
}
var init_areconnectedthroughproperties = __esm({
  "node_modules/@ckeditor/ckeditor5-watchdog/src/utils/areconnectedthroughproperties.js"() {
    init_getsubnodes();
  }
});

// node_modules/@ckeditor/ckeditor5-watchdog/src/editorwatchdog.js
var EditorWatchdog, EditorWatchdogInitPlugin;
var init_editorwatchdog = __esm({
  "node_modules/@ckeditor/ckeditor5-watchdog/src/editorwatchdog.js"() {
    init_compat2();
    init_areconnectedthroughproperties();
    init_watchdog();
    EditorWatchdog = class extends Watchdog {
      /**
       * @param Editor The editor class.
       * @param watchdogConfig The watchdog plugin configuration.
       */
      constructor(Editor, watchdogConfig = {}) {
        super(watchdogConfig);
        /**
         * The current editor instance.
         */
        __publicField(this, "_editor", null);
        /**
         * A promise associated with the life cycle of the editor (creation or destruction processes).
         *
         * It is used to prevent the initialization of the editor if the previous instance has not been destroyed yet,
         * and conversely, to prevent the destruction of the editor if it has not been initialized.
         */
        __publicField(this, "_lifecyclePromise", null);
        /**
         * Throttled save method. The `save()` method is called the specified `saveInterval` after `throttledSave()` is called,
         * unless a new action happens in the meantime.
         */
        __publicField(this, "_throttledSave");
        /**
         * The latest saved editor data represented as a root name -> root data object.
         */
        __publicField(this, "_data");
        /**
         * The last document version.
         */
        __publicField(this, "_lastDocumentVersion");
        /**
         * The editor source element or data.
         */
        __publicField(this, "_elementOrData");
        /**
         * Specifies whether the editor was initialized using document data (`true`) or HTML elements (`false`).
         */
        __publicField(this, "_initUsingData", true);
        /**
         * The latest record of the editor editable elements. Used to restart the editor.
         */
        __publicField(this, "_editables", {});
        /**
         * The editor configuration.
         */
        __publicField(this, "_config");
        __publicField(this, "_excludedProps");
        this._throttledSave = throttle(this._save.bind(this), typeof watchdogConfig.saveInterval === "number" ? watchdogConfig.saveInterval : 5e3);
        if (Editor) {
          this._creator = (elementOrData, config) => Editor.create(elementOrData, config);
        }
        this._destructor = (editor) => editor.destroy();
      }
      /**
       * The current editor instance.
       */
      get editor() {
        return this._editor;
      }
      /**
       * @internal
       */
      get _item() {
        return this._editor;
      }
      /**
       * Sets the function that is responsible for the editor creation.
       * It expects a function that should return a promise.
       *
       * ```ts
       * watchdog.setCreator( ( element, config ) => ClassicEditor.create( element, config ) );
       * ```
       */
      setCreator(creator) {
        this._creator = creator;
      }
      /**
       * Sets the function that is responsible for the editor destruction.
       * Overrides the default destruction function, which destroys only the editor instance.
       * It expects a function that should return a promise or `undefined`.
       *
       * ```ts
       * watchdog.setDestructor( editor => {
       * 	// Do something before the editor is destroyed.
       *
       * 	return editor
       * 		.destroy()
       * 		.then( () => {
       * 			// Do something after the editor is destroyed.
       * 		} );
       * } );
       * ```
       */
      setDestructor(destructor) {
        this._destructor = destructor;
      }
      /**
       * Restarts the editor instance. This method is called whenever an editor error occurs. It fires the `restart` event and changes
       * the state to `initializing`.
       *
       * @fires restart
       */
      _restart() {
        return Promise.resolve().then(() => {
          this.state = "initializing";
          this._fire("stateChange");
          return this._destroy();
        }).catch((err) => {
          console.error("An error happened during the editor destroying.", err);
        }).then(() => {
          const existingRoots = {};
          const lazyRoots = [];
          const oldRootsAttributes = this._config.rootsAttributes || {};
          const rootsAttributes = {};
          for (const [rootName, rootData] of Object.entries(this._data.roots)) {
            if (rootData.isLoaded) {
              existingRoots[rootName] = "";
              rootsAttributes[rootName] = oldRootsAttributes[rootName] || {};
            } else {
              lazyRoots.push(rootName);
            }
          }
          const updatedConfig = {
            ...this._config,
            extraPlugins: this._config.extraPlugins || [],
            lazyRoots,
            rootsAttributes,
            _watchdogInitialData: this._data
          };
          delete updatedConfig.initialData;
          updatedConfig.extraPlugins.push(EditorWatchdogInitPlugin);
          if (this._initUsingData) {
            return this.create(existingRoots, updatedConfig, updatedConfig.context);
          } else {
            if (isElement(this._elementOrData)) {
              return this.create(this._elementOrData, updatedConfig, updatedConfig.context);
            } else {
              return this.create(this._editables, updatedConfig, updatedConfig.context);
            }
          }
        }).then(() => {
          this._fire("restart");
        });
      }
      /**
       * Creates the editor instance and keeps it running, using the defined creator and destructor.
       *
       * @param elementOrData The editor source element or the editor data.
       * @param config The editor configuration.
       * @param context A context for the editor.
       */
      create(elementOrData = this._elementOrData, config = this._config, context) {
        this._lifecyclePromise = Promise.resolve(this._lifecyclePromise).then(() => {
          super._startErrorHandling();
          this._elementOrData = elementOrData;
          this._initUsingData = typeof elementOrData == "string" || Object.keys(elementOrData).length > 0 && typeof Object.values(elementOrData)[0] == "string";
          this._config = this._cloneEditorConfiguration(config) || {};
          this._config.context = context;
          return this._creator(elementOrData, this._config);
        }).then((editor) => {
          this._editor = editor;
          editor.model.document.on("change:data", this._throttledSave);
          this._lastDocumentVersion = editor.model.document.version;
          this._data = this._getData();
          if (!this._initUsingData) {
            this._editables = this._getEditables();
          }
          this.state = "ready";
          this._fire("stateChange");
        }).finally(() => {
          this._lifecyclePromise = null;
        });
        return this._lifecyclePromise;
      }
      /**
       * Destroys the watchdog and the current editor instance. It fires the callback
       * registered in {@link #setDestructor `setDestructor()`} and uses it to destroy the editor instance.
       * It also sets the state to `destroyed`.
       */
      destroy() {
        this._lifecyclePromise = Promise.resolve(this._lifecyclePromise).then(() => {
          this.state = "destroyed";
          this._fire("stateChange");
          super.destroy();
          return this._destroy();
        }).finally(() => {
          this._lifecyclePromise = null;
        });
        return this._lifecyclePromise;
      }
      _destroy() {
        return Promise.resolve().then(() => {
          this._stopErrorHandling();
          this._throttledSave.cancel();
          const editor = this._editor;
          this._editor = null;
          editor.model.document.off("change:data", this._throttledSave);
          return this._destructor(editor);
        });
      }
      /**
       * Saves the editor data, so it can be restored after the crash even if the data cannot be fetched at
       * the moment of the crash.
       */
      _save() {
        const version = this._editor.model.document.version;
        try {
          this._data = this._getData();
          if (!this._initUsingData) {
            this._editables = this._getEditables();
          }
          this._lastDocumentVersion = version;
        } catch (err) {
          console.error(err, "An error happened during restoring editor data. Editor will be restored from the previously saved data.");
        }
      }
      /**
       * @internal
       */
      _setExcludedProperties(props) {
        this._excludedProps = props;
      }
      /**
       * Gets all data that is required to reinitialize editor instance.
       */
      _getData() {
        const editor = this._editor;
        const roots = editor.model.document.roots.filter((root) => root.isAttached() && root.rootName != "$graveyard");
        const { plugins } = editor;
        const commentsRepository = plugins.has("CommentsRepository") && plugins.get("CommentsRepository");
        const trackChanges = plugins.has("TrackChanges") && plugins.get("TrackChanges");
        const data = {
          roots: {},
          markers: {},
          commentThreads: JSON.stringify([]),
          suggestions: JSON.stringify([])
        };
        roots.forEach((root) => {
          data.roots[root.rootName] = {
            content: JSON.stringify(Array.from(root.getChildren())),
            attributes: JSON.stringify(Array.from(root.getAttributes())),
            isLoaded: root._isLoaded
          };
        });
        for (const marker of editor.model.markers) {
          if (!marker._affectsData) {
            continue;
          }
          data.markers[marker.name] = {
            rangeJSON: marker.getRange().toJSON(),
            usingOperation: marker._managedUsingOperations,
            affectsData: marker._affectsData
          };
        }
        if (commentsRepository) {
          data.commentThreads = JSON.stringify(commentsRepository.getCommentThreads({ toJSON: true, skipNotAttached: true }));
        }
        if (trackChanges) {
          data.suggestions = JSON.stringify(trackChanges.getSuggestions({ toJSON: true, skipNotAttached: true }));
        }
        return data;
      }
      /**
       * For each attached model root, returns its HTML editable element (if available).
       */
      _getEditables() {
        const editables = {};
        for (const rootName of this.editor.model.document.getRootNames()) {
          const editable = this.editor.ui.getEditableElement(rootName);
          if (editable) {
            editables[rootName] = editable;
          }
        }
        return editables;
      }
      /**
       * Traverses the error context and the current editor to find out whether these structures are connected
       * to each other via properties.
       *
       * @internal
       */
      _isErrorComingFromThisItem(error) {
        return areConnectedThroughProperties(this._editor, error.context, this._excludedProps);
      }
      /**
       * Clones the editor configuration.
       */
      _cloneEditorConfiguration(config) {
        return cloneDeepWith2(config, (value, key) => {
          if (isElement(value)) {
            return value;
          }
          if (key === "context") {
            return value;
          }
        });
      }
    };
    EditorWatchdogInitPlugin = class {
      constructor(editor) {
        __publicField(this, "editor");
        __publicField(this, "_data");
        this.editor = editor;
        this._data = editor.config.get("_watchdogInitialData");
      }
      /**
       * @inheritDoc
       */
      init() {
        this.editor.data.on("init", (evt) => {
          evt.stop();
          this.editor.model.enqueueChange({ isUndoable: false }, (writer) => {
            this._restoreCollaborationData();
            this._restoreEditorData(writer);
          });
          this.editor.data.fire("ready");
        }, { priority: 1e3 - 1 });
      }
      /**
       * Creates a model node (element or text) based on provided JSON.
       */
      _createNode(writer, jsonNode) {
        if ("name" in jsonNode) {
          const element = writer.createElement(jsonNode.name, jsonNode.attributes);
          if (jsonNode.children) {
            for (const child of jsonNode.children) {
              element._appendChild(this._createNode(writer, child));
            }
          }
          return element;
        } else {
          return writer.createText(jsonNode.data, jsonNode.attributes);
        }
      }
      /**
       * Restores the editor by setting the document data, roots attributes and markers.
       */
      _restoreEditorData(writer) {
        const editor = this.editor;
        Object.entries(this._data.roots).forEach(([rootName, { content, attributes }]) => {
          const parsedNodes = JSON.parse(content);
          const parsedAttributes = JSON.parse(attributes);
          const rootElement = editor.model.document.getRoot(rootName);
          for (const [key, value] of parsedAttributes) {
            writer.setAttribute(key, value, rootElement);
          }
          for (const child of parsedNodes) {
            const node = this._createNode(writer, child);
            writer.insert(node, rootElement, "end");
          }
        });
        Object.entries(this._data.markers).forEach(([markerName, markerOptions]) => {
          const { document } = editor.model;
          const { rangeJSON: { start, end }, ...options } = markerOptions;
          const root = document.getRoot(start.root);
          const startPosition = writer.createPositionFromPath(root, start.path, start.stickiness);
          const endPosition = writer.createPositionFromPath(root, end.path, end.stickiness);
          const range3 = writer.createRange(startPosition, endPosition);
          writer.addMarker(markerName, {
            range: range3,
            ...options
          });
        });
      }
      /**
       * Restores the editor collaboration data - comment threads and suggestions.
       */
      _restoreCollaborationData() {
        const parsedCommentThreads = JSON.parse(this._data.commentThreads);
        const parsedSuggestions = JSON.parse(this._data.suggestions);
        parsedCommentThreads.forEach((commentThreadData) => {
          const channelId = this.editor.config.get("collaboration.channelId");
          const commentsRepository = this.editor.plugins.get("CommentsRepository");
          if (commentsRepository.hasCommentThread(commentThreadData.threadId)) {
            const commentThread = commentsRepository.getCommentThread(commentThreadData.threadId);
            commentThread.remove();
          }
          commentsRepository.addCommentThread({ channelId, ...commentThreadData });
        });
        parsedSuggestions.forEach((suggestionData) => {
          const trackChangesEditing = this.editor.plugins.get("TrackChangesEditing");
          if (trackChangesEditing.hasSuggestion(suggestionData.id)) {
            const suggestion = trackChangesEditing.getSuggestion(suggestionData.id);
            suggestion.attributes = suggestionData.attributes;
          } else {
            trackChangesEditing.addSuggestionData(suggestionData);
          }
        });
      }
    };
  }
});

// node_modules/@ckeditor/ckeditor5-watchdog/src/contextwatchdog.js
function toArray3(elementOrArray) {
  return Array.isArray(elementOrArray) ? elementOrArray : [elementOrArray];
}
var mainQueueId, ContextWatchdog, ActionQueues;
var init_contextwatchdog = __esm({
  "node_modules/@ckeditor/ckeditor5-watchdog/src/contextwatchdog.js"() {
    init_watchdog();
    init_editorwatchdog();
    init_areconnectedthroughproperties();
    init_getsubnodes();
    mainQueueId = Symbol("MainQueueId");
    ContextWatchdog = class extends Watchdog {
      /**
       * The context watchdog class constructor.
       *
       * ```ts
       * const watchdog = new ContextWatchdog( Context );
       *
       * await watchdog.create( contextConfiguration );
       *
       * await watchdog.add( item );
       * ```
       *
       * See the {@glink features/watchdog Watchdog feature guide} to learn more how to use this feature.
       *
       * @param Context The {@link module:core/context~Context} class.
       * @param watchdogConfig The watchdog configuration.
       */
      constructor(Context, watchdogConfig = {}) {
        super(watchdogConfig);
        /**
         * A map of internal watchdogs for added items.
         */
        __publicField(this, "_watchdogs", /* @__PURE__ */ new Map());
        /**
         * The watchdog configuration.
         */
        __publicField(this, "_watchdogConfig");
        /**
         * The current context instance.
         */
        __publicField(this, "_context", null);
        /**
         * Context properties (nodes/references) that are gathered during the initial context creation
         * and are used to distinguish the origin of an error.
         */
        __publicField(this, "_contextProps", /* @__PURE__ */ new Set());
        /**
         * An action queue, which is used to handle async functions queuing.
         */
        __publicField(this, "_actionQueues", new ActionQueues());
        /**
         * The configuration for the {@link module:core/context~Context}.
         */
        __publicField(this, "_contextConfig");
        /**
         * The watched item.
         */
        __publicField(this, "_item");
        this._watchdogConfig = watchdogConfig;
        this._creator = (contextConfig) => Context.create(contextConfig);
        this._destructor = (context) => context.destroy();
        this._actionQueues.onEmpty(() => {
          if (this.state === "initializing") {
            this.state = "ready";
            this._fire("stateChange");
          }
        });
      }
      /**
       * Sets the function that is responsible for the context creation.
       * It expects a function that should return a promise (or `undefined`).
       *
       * ```ts
       * watchdog.setCreator( config => Context.create( config ) );
       * ```
       */
      setCreator(creator) {
        this._creator = creator;
      }
      /**
       * Sets the function that is responsible for the context destruction.
       * Overrides the default destruction function, which destroys only the context instance.
       * It expects a function that should return a promise (or `undefined`).
       *
       * ```ts
       * watchdog.setDestructor( context => {
       * 	// Do something before the context is destroyed.
       *
       * 	return context
       * 		.destroy()
       * 		.then( () => {
       * 			// Do something after the context is destroyed.
       * 		} );
       * } );
       * ```
       */
      setDestructor(destructor) {
        this._destructor = destructor;
      }
      /**
       * The context instance. Keep in mind that this property might be changed when the context watchdog restarts,
       * so do not keep this instance internally. Always operate on the `ContextWatchdog#context` property.
       */
      get context() {
        return this._context;
      }
      /**
       * Initializes the context watchdog. Once it is created, the watchdog takes care about
       * recreating the context and the provided items, and starts the error handling mechanism.
       *
       * ```ts
       * await watchdog.create( {
       * 	plugins: []
       * } );
       * ```
       *
       * @param contextConfig The context configuration. See {@link module:core/context~Context}.
       */
      create(contextConfig = {}) {
        return this._actionQueues.enqueue(mainQueueId, () => {
          this._contextConfig = contextConfig;
          return this._create();
        });
      }
      /**
       * Returns an item instance with the given `itemId`.
       *
       * ```ts
       * const editor1 = watchdog.getItem( 'editor1' );
       * ```
       *
       * @param itemId The item ID.
       * @returns The item instance or `undefined` if an item with a given ID has not been found.
       */
      getItem(itemId) {
        const watchdog = this._getWatchdog(itemId);
        return watchdog._item;
      }
      /**
       * Gets the state of the given item. See {@link #state} for a list of available states.
       *
       * ```ts
       * const editor1State = watchdog.getItemState( 'editor1' );
       * ```
       *
       * @param itemId Item ID.
       * @returns The state of the item.
       */
      getItemState(itemId) {
        const watchdog = this._getWatchdog(itemId);
        return watchdog.state;
      }
      /**
       * Adds items to the watchdog. Once created, instances of these items will be available using the {@link #getItem} method.
       *
       * Items can be passed together as an array of objects:
       *
       * ```ts
       * await watchdog.add( [ {
       * 	id: 'editor1',
       * 	type: 'editor',
       * 	sourceElementOrData: document.querySelector( '#editor' ),
       * 	config: {
       * 		plugins: [ Essentials, Paragraph, Bold, Italic ],
       * 		toolbar: [ 'bold', 'italic', 'alignment' ]
       * 	},
       * 	creator: ( element, config ) => ClassicEditor.create( element, config )
       * } ] );
       * ```
       *
       * Or one by one as objects:
       *
       * ```ts
       * await watchdog.add( {
       * 	id: 'editor1',
       * 	type: 'editor',
       * 	sourceElementOrData: document.querySelector( '#editor' ),
       * 	config: {
       * 		plugins: [ Essentials, Paragraph, Bold, Italic ],
       * 		toolbar: [ 'bold', 'italic', 'alignment' ]
       * 	},
       * 	creator: ( element, config ) => ClassicEditor.create( element, config )
       * ] );
       * ```
       *
       * Then an instance can be retrieved using the {@link #getItem} method:
       *
       * ```ts
       * const editor1 = watchdog.getItem( 'editor1' );
       * ```
       *
       * Note that this method can be called multiple times, but for performance reasons it is better
       * to pass all items together.
       *
       * @param itemConfigurationOrItemConfigurations An item configuration object or an array of item configurations.
       */
      add(itemConfigurationOrItemConfigurations) {
        const itemConfigurations = toArray3(itemConfigurationOrItemConfigurations);
        return Promise.all(itemConfigurations.map((item) => {
          return this._actionQueues.enqueue(item.id, () => {
            if (this.state === "destroyed") {
              throw new Error("Cannot add items to destroyed watchdog.");
            }
            if (!this._context) {
              throw new Error("Context was not created yet. You should call the `ContextWatchdog#create()` method first.");
            }
            let watchdog;
            if (this._watchdogs.has(item.id)) {
              throw new Error(`Item with the given id is already added: '${item.id}'.`);
            }
            if (item.type === "editor") {
              watchdog = new EditorWatchdog(null, this._watchdogConfig);
              watchdog.setCreator(item.creator);
              watchdog._setExcludedProperties(this._contextProps);
              if (item.destructor) {
                watchdog.setDestructor(item.destructor);
              }
              this._watchdogs.set(item.id, watchdog);
              watchdog.on("error", (evt, { error, causesRestart }) => {
                this._fire("itemError", { itemId: item.id, error });
                if (!causesRestart) {
                  return;
                }
                this._actionQueues.enqueue(item.id, () => new Promise((res) => {
                  const rethrowRestartEventOnce = () => {
                    watchdog.off("restart", rethrowRestartEventOnce);
                    this._fire("itemRestart", { itemId: item.id });
                    res();
                  };
                  watchdog.on("restart", rethrowRestartEventOnce);
                }));
              });
              return watchdog.create(item.sourceElementOrData, item.config, this._context);
            } else {
              throw new Error(`Not supported item type: '${item.type}'.`);
            }
          });
        }));
      }
      /**
       * Removes and destroys item(s) with given ID(s).
       *
       * ```ts
       * await watchdog.remove( 'editor1' );
       * ```
       *
       * Or
       *
       * ```ts
       * await watchdog.remove( [ 'editor1', 'editor2' ] );
       * ```
       *
       * @param itemIdOrItemIds Item ID or an array of item IDs.
       */
      remove(itemIdOrItemIds) {
        const itemIds = toArray3(itemIdOrItemIds);
        return Promise.all(itemIds.map((itemId) => {
          return this._actionQueues.enqueue(itemId, () => {
            const watchdog = this._getWatchdog(itemId);
            this._watchdogs.delete(itemId);
            return watchdog.destroy();
          });
        }));
      }
      /**
       * Destroys the context watchdog and all added items.
       * Once the context watchdog is destroyed, new items cannot be added.
       *
       * ```ts
       * await watchdog.destroy();
       * ```
       */
      destroy() {
        return this._actionQueues.enqueue(mainQueueId, () => {
          this.state = "destroyed";
          this._fire("stateChange");
          super.destroy();
          return this._destroy();
        });
      }
      /**
       * Restarts the context watchdog.
       */
      _restart() {
        return this._actionQueues.enqueue(mainQueueId, () => {
          this.state = "initializing";
          this._fire("stateChange");
          return this._destroy().catch((err) => {
            console.error("An error happened during destroying the context or items.", err);
          }).then(() => this._create()).then(() => this._fire("restart"));
        });
      }
      /**
       * Initializes the context watchdog.
       */
      _create() {
        return Promise.resolve().then(() => {
          this._startErrorHandling();
          return this._creator(this._contextConfig);
        }).then((context) => {
          this._context = context;
          this._contextProps = getSubNodes(this._context);
          return Promise.all(Array.from(this._watchdogs.values()).map((watchdog) => {
            watchdog._setExcludedProperties(this._contextProps);
            return watchdog.create(void 0, void 0, this._context);
          }));
        });
      }
      /**
       * Destroys the context instance and all added items.
       */
      _destroy() {
        return Promise.resolve().then(() => {
          this._stopErrorHandling();
          const context = this._context;
          this._context = null;
          this._contextProps = /* @__PURE__ */ new Set();
          return Promise.all(Array.from(this._watchdogs.values()).map((watchdog) => watchdog.destroy())).then(() => this._destructor(context));
        });
      }
      /**
       * Returns the watchdog for a given item ID.
       *
       * @param itemId Item ID.
       */
      _getWatchdog(itemId) {
        const watchdog = this._watchdogs.get(itemId);
        if (!watchdog) {
          throw new Error(`Item with the given id was not registered: ${itemId}.`);
        }
        return watchdog;
      }
      /**
       * Checks whether an error comes from the context instance and not from the item instances.
       *
       * @internal
       */
      _isErrorComingFromThisItem(error) {
        for (const watchdog of this._watchdogs.values()) {
          if (watchdog._isErrorComingFromThisItem(error)) {
            return false;
          }
        }
        return areConnectedThroughProperties(this._context, error.context);
      }
    };
    ActionQueues = class {
      constructor() {
        __publicField(this, "_onEmptyCallbacks", []);
        __publicField(this, "_queues", /* @__PURE__ */ new Map());
        __publicField(this, "_activeActions", 0);
      }
      /**
       * Used to register callbacks that will be run when the queue becomes empty.
       *
       * @param onEmptyCallback A callback that will be run whenever the queue becomes empty.
       */
      onEmpty(onEmptyCallback) {
        this._onEmptyCallbacks.push(onEmptyCallback);
      }
      /**
       * It adds asynchronous actions (functions) to the proper queue and runs them one by one.
       *
       * @param queueId The action queue ID.
       * @param action A function that should be enqueued.
       */
      enqueue(queueId, action) {
        const isMainAction = queueId === mainQueueId;
        this._activeActions++;
        if (!this._queues.get(queueId)) {
          this._queues.set(queueId, Promise.resolve());
        }
        const awaitedActions = isMainAction ? Promise.all(this._queues.values()) : Promise.all([this._queues.get(mainQueueId), this._queues.get(queueId)]);
        const queueWithAction = awaitedActions.then(action);
        const nonErrorQueue = queueWithAction.catch(() => {
        });
        this._queues.set(queueId, nonErrorQueue);
        return queueWithAction.finally(() => {
          this._activeActions--;
          if (this._queues.get(queueId) === nonErrorQueue && this._activeActions === 0) {
            this._onEmptyCallbacks.forEach((cb) => cb());
          }
        });
      }
    };
  }
});

// node_modules/@ckeditor/ckeditor5-watchdog/src/augmentation.js
var init_augmentation = __esm({
  "node_modules/@ckeditor/ckeditor5-watchdog/src/augmentation.js"() {
  }
});

// node_modules/@ckeditor/ckeditor5-watchdog/src/index.js
var src_exports = {};
__export(src_exports, {
  ContextWatchdog: () => ContextWatchdog,
  EditorWatchdog: () => EditorWatchdog,
  Watchdog: () => Watchdog
});
var init_src = __esm({
  "node_modules/@ckeditor/ckeditor5-watchdog/src/index.js"() {
    init_contextwatchdog();
    init_editorwatchdog();
    init_watchdog();
    init_augmentation();
  }
});

// node_modules/@ckeditor/ckeditor5-react/dist/index.js
var require_dist = __commonJS({
  "node_modules/@ckeditor/ckeditor5-react/dist/index.js"(exports, module) {
    !function(t, e) {
      "object" == typeof exports && "object" == typeof module ? module.exports = e(require_react(), require_prop_types(), (init_src(), __toCommonJS(src_exports))) : "function" == typeof define && define.amd ? define(["react", "prop-types", "@ckeditor/ckeditor5-watchdog"], e) : "object" == typeof exports ? exports.CKEditor = e(require_react(), require_prop_types(), (init_src(), __toCommonJS(src_exports))) : t.CKEditor = e(t.react, t["prop-types"], t["@ckeditor/ckeditor5-watchdog"]);
    }(self, (t, e, o) => (() => {
      "use strict";
      var r = { 546: (t2) => {
        t2.exports = o;
      }, 949: (t2) => {
        t2.exports = e;
      }, 155: (e2) => {
        e2.exports = t;
      } }, i = {};
      function n(t2) {
        var e2 = i[t2];
        if (void 0 !== e2) return e2.exports;
        var o2 = i[t2] = { exports: {} };
        return r[t2](o2, o2.exports, n), o2.exports;
      }
      n.n = (t2) => {
        var e2 = t2 && t2.__esModule ? () => t2.default : () => t2;
        return n.d(e2, { a: e2 }), e2;
      }, n.d = (t2, e2) => {
        for (var o2 in e2) n.o(e2, o2) && !n.o(t2, o2) && Object.defineProperty(t2, o2, { enumerable: true, get: e2[o2] });
      }, n.o = (t2, e2) => Object.prototype.hasOwnProperty.call(t2, e2), n.r = (t2) => {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
      };
      var a = {};
      return (() => {
        n.r(a), n.d(a, { CKEditor: () => u, CKEditorContext: () => c, useMultiRootEditor: () => f });
        var t2 = n(155), e2 = n.n(t2), o2 = n(949), r2 = n.n(o2);
        const i2 = new Array(256).fill("").map((t3, e3) => ("0" + e3.toString(16)).slice(-2));
        var s = n(546);
        const d = e2().createContext("contextWatchdog");
        class c extends e2().Component {
          constructor(t3, e3) {
            super(t3, e3), this.contextWatchdog = null, this.props.isLayoutReady && this._initializeContextWatchdog(this.props.config);
          }
          shouldComponentUpdate(t3) {
            return this._shouldComponentUpdate(t3);
          }
          async _shouldComponentUpdate(t3) {
            return t3.id !== this.props.id && (this.contextWatchdog && await this.contextWatchdog.destroy(), await this._initializeContextWatchdog(t3.config)), t3.isLayoutReady && !this.contextWatchdog ? (await this._initializeContextWatchdog(t3.config), true) : this.props.children !== t3.children;
          }
          render() {
            return e2().createElement(d.Provider, { value: this.contextWatchdog }, this.props.children);
          }
          componentWillUnmount() {
            this._destroyContext();
          }
          async _initializeContextWatchdog(t3) {
            this.contextWatchdog = new s.ContextWatchdog(this.props.context, this.props.watchdogConfig), this.contextWatchdog.on("error", (t4, e3) => {
              this.props.onError(e3.error, { phase: "runtime", willContextRestart: e3.causesRestart });
            }), this.contextWatchdog.on("stateChange", () => {
              "ready" === this.contextWatchdog.state && this.props.onReady && this.props.onReady(this.contextWatchdog.context);
            }), await this.contextWatchdog.create(t3).catch((t4) => {
              this.props.onError(t4, { phase: "initialization", willContextRestart: false });
            });
          }
          async _destroyContext() {
            this.contextWatchdog && (await this.contextWatchdog.destroy(), this.contextWatchdog = null);
          }
        }
        c.defaultProps = { isLayoutReady: true, onError: (t3, e3) => console.error(t3, e3) }, c.propTypes = { id: r2().string, isLayoutReady: r2().bool, context: r2().func, watchdogConfig: r2().object, config: r2().object, onReady: r2().func, onError: r2().func };
        const h = "Lock from React integration (@ckeditor/ckeditor5-react)";
        class u extends e2().Component {
          constructor(t3) {
            super(t3), this.editorDestructionInProgress = null, this.domContainer = e2().createRef(), this.watchdog = null;
            const { CKEDITOR_VERSION: o3 } = window;
            if (o3) {
              const [t4] = o3.split(".").map(Number);
              t4 < 37 && console.warn("The <CKEditor> component requires using CKEditor 5 in version 37 or higher.");
            } else console.warn('Cannot find the "CKEDITOR_VERSION" in the "window" scope.');
          }
          get editor() {
            return this.props.disableWatchdog ? this.instance : this.watchdog ? this.watchdog.editor : null;
          }
          shouldComponentUpdate(t3) {
            return !!this.editor && (t3.id !== this.props.id || (t3.disableWatchdog !== this.props.disableWatchdog || (this._shouldUpdateEditor(t3) && this.editor.data.set(t3.data), "disabled" in t3 && (t3.disabled ? this.editor.enableReadOnlyMode(h) : this.editor.disableReadOnlyMode(h)), false)));
          }
          async componentDidMount() {
            await this._initializeEditor();
          }
          async componentDidUpdate() {
            await this._destroyEditor(), await this._initializeEditor();
          }
          async componentWillUnmount() {
            await this._destroyEditor();
          }
          render() {
            return e2().createElement("div", { ref: this.domContainer });
          }
          async _initializeEditor() {
            await this.editorDestructionInProgress, this.props.disableWatchdog ? this.instance = await this._createEditor(this.domContainer.current, this._getConfig()) : this.watchdog || (this.context instanceof s.ContextWatchdog ? this.watchdog = new l(this.context) : this.watchdog = new u._EditorWatchdog(this.props.editor, this.props.watchdogConfig), this.watchdog.setCreator((t3, e3) => this._createEditor(t3, e3)), this.watchdog.on("error", (t3, { error: e3, causesRestart: o3 }) => {
              (this.props.onError || console.error)(e3, { phase: "runtime", willEditorRestart: o3 });
            }), await this.watchdog.create(this.domContainer.current, this._getConfig()).catch((t3) => {
              (this.props.onError || console.error)(t3, { phase: "initialization", willEditorRestart: false });
            }));
          }
          _createEditor(t3, e3) {
            return this.props.editor.create(t3, e3).then((t4) => {
              "disabled" in this.props && this.props.disabled && t4.enableReadOnlyMode(h);
              const e4 = t4.model.document, o3 = t4.editing.view.document;
              return e4.on("change:data", (e5) => {
                this.props.onChange && this.props.onChange(e5, t4);
              }), o3.on("focus", (e5) => {
                this.props.onFocus && this.props.onFocus(e5, t4);
              }), o3.on("blur", (e5) => {
                this.props.onBlur && this.props.onBlur(e5, t4);
              }), setTimeout(() => {
                this.props.onReady && this.props.onReady(t4);
              }), t4;
            });
          }
          async _destroyEditor() {
            this.editorDestructionInProgress = new Promise((t3) => {
              setTimeout(async () => this.watchdog ? (await this.watchdog.destroy(), this.watchdog = null, t3()) : this.instance ? (await this.instance.destroy(), this.instance = null, t3()) : void t3());
            });
          }
          _shouldUpdateEditor(t3) {
            return this.props.data !== t3.data && this.editor.data.get() !== t3.data;
          }
          _getConfig() {
            const t3 = this.props.config || {};
            return this.props.data && t3.initialData && console.warn("Editor data should be provided either using `config.initialData` or `content` property. The config value takes precedence over `content` property and will be used when both are specified."), { ...t3, initialData: t3.initialData || this.props.data || "" };
          }
        }
        u.contextType = d, u.propTypes = { editor: r2().func.isRequired, data: r2().string, config: r2().object, disableWatchdog: r2().bool, watchdogConfig: r2().object, onChange: r2().func, onReady: r2().func, onFocus: r2().func, onBlur: r2().func, onError: r2().func, disabled: r2().bool, id: r2().any }, u._EditorWatchdog = s.EditorWatchdog;
        class l {
          constructor(t3) {
            this._contextWatchdog = t3, this._id = function() {
              const t4 = 4294967296 * Math.random() >>> 0, e3 = 4294967296 * Math.random() >>> 0, o3 = 4294967296 * Math.random() >>> 0, r3 = 4294967296 * Math.random() >>> 0;
              return "e" + i2[255 & t4] + i2[t4 >> 8 & 255] + i2[t4 >> 16 & 255] + i2[t4 >> 24 & 255] + i2[255 & e3] + i2[e3 >> 8 & 255] + i2[e3 >> 16 & 255] + i2[e3 >> 24 & 255] + i2[255 & o3] + i2[o3 >> 8 & 255] + i2[o3 >> 16 & 255] + i2[o3 >> 24 & 255] + i2[255 & r3] + i2[r3 >> 8 & 255] + i2[r3 >> 16 & 255] + i2[r3 >> 24 & 255];
            }();
          }
          setCreator(t3) {
            this._creator = t3;
          }
          create(t3, e3) {
            return this._contextWatchdog.add({ sourceElementOrData: t3, config: e3, creator: this._creator, id: this._id, type: "editor" });
          }
          on(t3, e3) {
            this._contextWatchdog.on("itemError", (t4, { itemId: o3, error: r3 }) => {
              o3 === this._id && e3(null, { error: r3, causesRestart: void 0 });
            });
          }
          destroy() {
            return "ready" === this._contextWatchdog.state ? this._contextWatchdog.remove(this._id) : Promise.resolve();
          }
          get editor() {
            return this._contextWatchdog.getItem(this._id);
          }
        }
        const p = "Lock from React integration (@ckeditor/ckeditor5-react)", g = ({ editor: o3 }) => {
          const r3 = (0, t2.useRef)(null);
          return (0, t2.useEffect)(() => {
            const t3 = r3.current;
            if (!o3 || !t3) return;
            const e3 = o3.ui.view.toolbar.element;
            return t3 && t3.appendChild(e3), () => {
              t3 && t3.removeChild(e3);
            };
          }, [o3 && o3.id]), e2().createElement("div", { ref: r3 });
        }, f = (o3) => {
          const r3 = (0, t2.useRef)(null), i3 = (0, t2.useRef)(null), n2 = (0, t2.useContext)(d), [a2, c2] = (0, t2.useState)(null), [h2, u2] = (0, t2.useState)(o3.data), [f2, y] = (0, t2.useState)(o3.rootsAttributes || {}), [m, b] = (0, t2.useState)([]), w = (0, t2.useRef)(true);
          (0, t2.useEffect)(() => ((async () => {
            await i3.current, false !== o3.isLayoutReady && await v();
          })(), () => {
            x().then(() => {
              i3.current = null;
            });
          }), [o3.isLayoutReady]), (0, t2.useEffect)(() => {
            a2 && (o3.disabled ? a2.enableReadOnlyMode(p) : a2.disableReadOnlyMode(p));
          }, [o3.disabled]), (0, t2.useEffect)(() => {
            if (a2 && !i3.current) {
              const t3 = a2.getFullData();
              u2({ ...t3 }), y({ ...a2.getRootsAttributes() }), b([...Object.keys(t3).map((t4) => C(a2, t4))]);
            }
          }, [a2 && a2.id]);
          const E = () => {
            const t3 = o3.config || {};
            return o3.data && t3.initialData && console.warn("Editor data should be provided either using `config.initialData` or `data` property. The config value takes precedence over `data` property and will be used when both are specified."), { ...t3, rootsAttributes: f2 };
          }, C = (t3, o4) => e2().createElement("div", { id: o4, key: o4, ref: (e3) => {
            if (e3) {
              const r4 = t3.ui.view.createEditable(o4, e3);
              t3.ui.addEditable(r4), t3.editing.view.forceRender();
            }
          } }), R = (t3, e3) => o3.editor.create(t3, e3).then((t4) => {
            o3.disabled && o3.disabled && t4.enableReadOnlyMode(p);
            const e4 = t4.model.document, r4 = t4.editing.view.document;
            return e4.on("change:data", (e5) => ((t5, e6) => {
              const r5 = t5.model.document;
              if (!o3.disableTwoWayDataBinding) {
                const e7 = {}, o4 = {};
                r5.differ.getChanges().forEach((o5) => {
                  let r6;
                  if (r6 = "insert" == o5.type || "remove" == o5.type ? o5.position.root : o5.range.root, !r6.isAttached()) return;
                  const { rootName: i4 } = r6;
                  e7[i4] = t5.getData({ rootName: i4 });
                }), r5.differ.getChangedRoots().forEach((r6) => {
                  if (r6.state) return void (void 0 !== e7[r6.name] && delete e7[r6.name]);
                  const i4 = r6.name;
                  o4[i4] = t5.getRootAttributes(i4);
                }), Object.keys(e7).length && u2((t6) => ({ ...t6, ...e7 })), Object.keys(o4).length && y((t6) => ({ ...t6, ...o4 }));
              }
              o3.onChange && o3.onChange(e6, t5);
            })(t4, e5)), t4.on("addRoot", (e5, r5) => ((t5, e6, r6) => {
              const i4 = r6.rootName, n3 = C(t5, i4);
              o3.disableTwoWayDataBinding || (u2((e7) => ({ ...e7, [i4]: t5.getData({ rootName: i4 }) })), y((e7) => ({ ...e7, [i4]: t5.getRootAttributes(i4) }))), b((t6) => [...t6, n3]);
            })(t4, 0, r5)), t4.on("detachRoot", (e5, r5) => ((t5, e6, r6) => {
              const i4 = r6.rootName;
              b((t6) => t6.filter((t7) => t7.props.id !== i4)), o3.disableTwoWayDataBinding || (u2((t6) => {
                const { [i4]: e7, ...o4 } = t6;
                return { ...o4 };
              }), y((t6) => {
                const { [i4]: e7, ...o4 } = t6;
                return { ...o4 };
              })), t5.detachEditable(r6);
            })(t4, 0, r5)), r4.on("focus", (e5) => {
              o3.onFocus && o3.onFocus(e5, t4);
            }), r4.on("blur", (e5) => {
              o3.onBlur && o3.onBlur(e5, t4);
            }), c2(t4), o3.onReady && o3.onReady(t4), t4;
          }), x = async () => {
            c2(null), u2({}), y({}), b([]), i3.current = new Promise((t3) => {
              setTimeout(async () => r3.current ? (await r3.current.destroy(), r3.current = null, t3()) : a2 ? (await a2.destroy(), t3()) : void t3());
            });
          }, v = async () => {
            if (o3.disableWatchdog) return void await R(o3.data, E());
            if (r3.current) return;
            n2 instanceof s.ContextWatchdog ? r3.current = new l(n2) : r3.current = new s.EditorWatchdog(o3.editor, o3.watchdogConfig);
            const t3 = r3.current;
            t3.setCreator((t4, e3) => R(t4, e3)), t3.on("error", (t4, { error: e3, causesRestart: r4 }) => {
              (o3.onError || console.error)(e3, { phase: "runtime", willEditorRestart: r4 });
            }), await t3.create(h2, E()).catch((t4) => {
              (o3.onError || console.error)(t4, { phase: "initialization", willEditorRestart: false });
            });
          };
          (0, t2.useEffect)(() => {
            if (a2 && w.current) {
              w.current = false;
              const t3 = Object.keys(h2), e3 = Object.keys(f2);
              if (!t3.every((t4) => e3.includes(t4))) throw new Error("`data` and `attributes` objects must have the same keys (roots).");
              const o4 = a2.getFullData(), r4 = a2.getRootsAttributes(), { addedKeys: i4, removedKeys: n3 } = W(o4, h2 || {}), s2 = t3.some((t4) => void 0 !== o4[t4] && JSON.stringify(o4[t4]) !== JSON.stringify(h2[t4])), d2 = e3.filter((t4) => JSON.stringify(r4[t4]) !== JSON.stringify(f2[t4]));
              a2.model.change((t4) => {
                _(i4), k(n3), s2 && O(), d2.length && D(t4, d2);
              });
            }
          }, [h2, f2]);
          const W = (t3, e3) => {
            const o4 = Object.keys(t3), r4 = Object.keys(e3);
            return { addedKeys: r4.filter((t4) => !o4.includes(t4)), removedKeys: o4.filter((t4) => !r4.includes(t4)) };
          }, _ = (t3) => {
            t3.forEach((t4) => {
              a2.addRoot(t4, { data: h2[t4] || "", attributes: (null == f2 ? void 0 : f2[t4]) || {}, isUndoable: true });
            });
          }, k = (t3) => {
            t3.forEach((t4) => {
              a2.detachRoot(t4, true);
            });
          }, O = () => {
            a2.data.set(h2, { suppressErrorInCollaboration: true });
          }, D = (t3, e3) => {
            e3.forEach((e4) => {
              Object.keys(f2[e4]).forEach((t4) => {
                a2.registerRootAttribute(t4);
              }), t3.clearAttributes(a2.model.document.getRoot(e4)), t3.setAttributes(f2[e4], a2.model.document.getRoot(e4));
            });
          }, j = (0, t2.useCallback)((t3) => {
            w.current = true, u2(t3);
          }, [u2]), S = (0, t2.useCallback)((t3) => {
            w.current = true, y(t3);
          }, [y]);
          return { editor: a2, editableElements: m, toolbarElement: e2().createElement(g, { editor: a2 }), data: h2, setData: j, attributes: f2, setAttributes: S };
        };
      })(), a;
    })());
  }
});
export default require_dist();
/*! Bundled license information:

react-is/cjs/react-is.development.js:
  (** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

object-assign/index.js:
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)

@ckeditor/ckeditor5-watchdog/src/watchdog.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-watchdog/src/utils/getsubnodes.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-watchdog/src/utils/areconnectedthroughproperties.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)
  (* istanbul ignore next -- @preserve *)

@ckeditor/ckeditor5-watchdog/src/editorwatchdog.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-watchdog/src/contextwatchdog.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-watchdog/src/augmentation.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-watchdog/src/index.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-react/dist/index.js:
  (*!
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md.
   *)
*/
//# sourceMappingURL=@ckeditor_ckeditor5-react.js.map
